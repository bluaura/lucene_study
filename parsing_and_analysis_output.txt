Starting parsing for file: C:\Users\c\OneDrive\문서\TestDocs\AndroidInternals.pdf
Parsing completed. Parsed content:

RL





Android Internals

A Confectioner's Cookbook

Volume I: The Power User's View

By Jonathan Levin

Cambridge, MA

 In memoriam: Frank R. Dye.  I missed you by a day, and will miss you for a lifetime. 

With updates for Android M, Preview Release 1 (6/2015)



Android Internals - A Confectioner's Cookbook - Volume I - The Power User's View

© 2015 by Jonathan Levin.
All rights reserved. No part of this work may be reproduced, transmitted in any form or any means,
electronic or mechanical, including photocopying, recording, or by any information storage or
retrieval system, without the prior written permission of the author. 

Printed in Cambridge, MA, USA

First Printing��Y���5-Mp1-as��� 
ISBN-10: 9910555-2-4 
ISBN-13: 978-0-9910555-2-4

Publisher: Technologeeks.com
Production Editor: Jonathan Levin
Interior Design: Jonathan Levin
Technical Reviewers: Moshe Kravchik, Arie Haenel
Cover Illustration: Dino Tsiopanos

For information on distribution, translations, or bulk sales, please contact Jonathan Levin, at:

Jonathan Levin
Phone: (617)-3000-667
Email: j@NewAndroidBook.com
Web: www.NewAndroidBook.com

Company and product names mentioned in this work may be trademarked by their respective
owners. Any and every such name is used solely in an editorial fashion, to the benefit of the
trademark owner, with no intention whatsoever of infringement.
The Android robot is reproduced and/or modified from work created and shared by Google,
according to the terms of the Creative Commons 3.0 Attribution License. 

Limit of Liability/Disclaimer of Warranty: The author neither makes or implies any
representations or warranties with respect to the accuracy or completeness of the contents of this
work. Further, this paragraph explictly and specifically serves to disclaim all warranties, including
without limitation warranties of fitness for a particular purpose. No warranty may be created or
extended by sales or promotional materials. The advice and strategies contained herein may not be
suitable for every situation. This work is sold with the understanding that the author is not engaged
in rendering legal, accounting, or other professional services. If professional assistance is required,
the services of a competent professional person should be sought. The author shall not be liable for
damages arising herefrom. The fact that an organization or Web site is referred to in this work as a
citation and/or a potential source of further information does not mean that the author endorses the
information the organization or Web site may provide or recommendations it may make. Further,
readers should be aware that Internet Web sites listed in this work may have changed or
disappeared between when this work was written and when it is read.

Information in this book is distributed on an "As Is" basis, with no warranty. Android is a shifting
landscape, with versions being released faster than any work can keep up with. Every effort and
precaution has been taken to update this work to reflect up to and Including Android Lollipop
(5.0.2). Bear in mind, however, that different versions of Android may add, modify, or remove APIs
and features with no notice. The author hereby disclaims any liability to any and every person or
entity with respect to any loss or damage, whether caused or alleged to be caused directly or
indirectly, by this work.

To report errors or omissions, please contact the author.

This copy is specifically licensed for RedLattice, Inc, Ashburn VA, for training conducted 6/2015
and not meant to be used outside the purposes of said specific training 



About the [Author/Editor/Formatter/Publisher]

I started in my teens by hacking (mostly in the good sense of the word) and trying to figure out
how things worked back in 1993, from an XT with a 2400 baud modem onto a shell I'm not even
sure was mine. With no help per se, I had to  and then ..

A lot has happened in the two decades since, and from UNIX to Linux, I got to Windows and OS
X. Over the years, I took up consulting and training - initially, in security. I then realized security is
largely a projection of internals. Finally, I gathered a few good men and started Technologeeks.com
- which is where I presently pass my time and function as CTO.

Authoring is somewhat new: I first took on Apple's OSes with "Mac OS X and iOS Internals"�
(Wiley, 2012), which was well received. It was a painful process, but the dopamine rush was�
awesome. Now an addict, I took on Android, and the first part of the result is what you see before�
you. This was also my first foray into the world of self publishing. With this done, I'm turning to the�
2nd Edition of MOXiI��EXW�\RX�FDQ�H[SHFW�9ROXPH�,,�RI�WKLV�VHULHV���7KH�'HYHORSHU
V�9LHZ���VRRQ.

About the Technical Reviewers

Moshe Kravchik of Cisco helped review my previous book, and immediately volunteered to
help with this one. With his eye for detail and accuracy, he helped me lay out the contents of this
book, expanded them with many a question a reader would pose, and caught my (oh-so-many)
typos, or areas wherein I wasn't clear enough. For that, my thanks!

Arie Haenel, also of Cisco, is hands-down the most gifted reverse engineer I've ever known,
and certainly one of the outright smartest people, period. A reviewer of my previous book, it was
only natural I would seek his help for this one. He's already got the dubious pleasure of reviewing
the 2nd Edition of MOXiI, as well.





viii

1

Table Of Contents

0. About This Book............................................................

1. Introduction......................................................................
Android version history

Cupcake

Donut

Éclair

Froyo

Gingerbread 

Honeycomb

Ice Cream Sandwich 

JellyBean

KitKat

Lollipop

M (Preview)

Android vs. Linux
Not just another Linux Distribution

And then came Android.

Commonalities and Divergences from Linux

The Android Frameworks

The Dalvik Virtual Machine

JNI

Native Binaries

Bionic

Android Native Libraries

External Native Libraries

Hardware Abstraction Layer

The Linux Kernel



2�

Android Derivatives
Google offshoots

Non-Google ports

Pondering the Way Ahead
64-Bit compatibility

Android RunTime (ART)

Split-Screen

Android as a desktop OS

Android and Project ARA

2. Partitions & FileSystems..................................................
Partitions

The need for separate partitions

The GUID Partition Table

Flash Storage Systems

File Systems

Android Device Partitions

Android Filesystem Contents
The root file system

/system

/data

/cache

/vendor

The SD card

Protected Filesystems
OBB - Opaque Binary Blobs

ASec - Android Secure Storage

The Linux pseudo-Filesystems
cgroupfs

debugfs

functionfs (/dev/usb-ffs/adb)

procfs (/proc)

pstore (/sys/fs/pstore)

selinuxfs (/sys/fs/selinux)

sysfs (/sys)



��

9�

3. Boot, Backup & Recovery...............................................
Android Images

The Boot Loader

Boot Images

The Kernel

The RAM disk

System and Data Partitions

The Boot Process
Firmware Boot

Kernel Boot

Shutdown & Reboot

Application Backup & Restore
Command line tools

Local backups

Monitoring backup operations

System Recovery & Updates
Over-The-Air (OTA) Updates

Customizing images

Resources for image modding

4. Init..............................................................................
The roles and responsbilities of init

System Properties

The .rc Files

Putting it all together: The flow of 

Init and USB

The Other Roles of init
ueventd

watchdogd



11�

1��

5. Daemons......................................................................
Core Services

adbd

servicemanager

healthd

lmkd (L)

logd (L)

vold

Network Services
netd

mdnsd

mtpd

racooon

rild

Graphics and Media Services
surfaceflinger

bootanimation

mediaserver

drmserver

Other Services
installd

keystore

debuggerd

sdcard

zygote[64]

6. The Framework Service Architecture..............................
Revisiting servicemanager

The Service Calling Pattern
Advantages and Disadvantages

Serialization and AIDL

The Binder
A Little History

So what, exactly, is Binder?

Using Binder

Tracing Binder



17�

���

system_server
Startup and Flow

Modifying startup behavior

7. Android Through a Linux Lens.......................................

/proc, revisited
The symlinks: cwd, exe, root

fd

fdinfo

status

User mode memory management
Virtual Memory classification and lifecycle

Memory statistics

Out Of Memory conditions

Tracing system calls
The  tool

wchan and syscall

The  utility

8. Security........................................................................
Threat Modeling Mobile Security�

Security at the Linux Level

Linux Permissions

Linux Capabilities

SELinux

Other noteworthy features



Security at the Dalvik Level
Dalvik Level Permissions� 

Dalvik Code Signing� 

User Level Security
The Lock Screen

Multi-User Support

Key Management
Certificate Management

Secret and Private Key Management

Storage Security
/data Encryption

Secure Boot

Rooting Android
Boot-To-Root

Rooting via Exploiting

Security Aspects of Rooting



About This Book

Overview

If you got this book, no doubt you recognize the importance of Android. From a start-up started�
back in 2003, it has been assimilated by Google, and morphed into one of its largest arms. Taking�RQ 
Apple's iOS head on (some would say, too closely), it has not only achieved hegemony over�mobile 
operating systems worldwide (with a staggering 82% of the market as this book goes to�print) but 
has also permeated other platforms, becoming an operating system for wearable devices,�TVs, and 
embedded devices.

Android is open source and freely available, meaning anyone can get it, and adopt it to any
platform - indeed, it owes its overwhelming popularity to this. It's surprising, however, that some
seven years since its public inception, no book to date has taken on the task of documenting and
explicating its internals. A previous work on the subject - Embedded Android: Porting, Extending,
and Customizing, by Karim Yaghmour - provides a good deal of detail about the general structure of
the OS, but focuses on building and adapting the sources to new platforms, and stops shy of
describing the structure of the operating system itself. In fact, in his "Internals Primer", Yaghmour
states that "Fully understanding the internals of Android's system services is like trying to swallow a
whale".

The analogy is very much an understatement, Which is why this work requires not one, but
multiple volumes. The first (the one you are reading), focuses on Android from the perspective of
the power user or administrator. In it, I try to tackle various aspects of the operating system - its
design, filesystem structure, boot sequence, and native services, along with the Linux foundations
and legacies which affect the operation. All this, without going into code, and trying to provide an
illustrated, conceptual view as possible. This book can be considered, in a sense, a successor to
Yaghmour's work, which remains a great resource and a recommended read.

The second volume of this work (to be published soon) dives far deeper, and looks at the
structure of Android's frameworks - which is where its appeal to developers lies: Through a rich set
of Java-level frameworks, developers obtain powerful abstractions of input devices, sensors,
graphics and what not. All these abstractions, come at the price - the complexity that lies "under the
hood" - which most developers are quite blissfully ignorant of (and would likely prefer to stay this
way). There is no knowledge that is not power, however, and so deep familiarity with the
frameworks is instrumental for anyone dealing with the low level implementations, and
customizations for performance, hardware or security.

Android is a constantly shifting landscape. This work was started halfway through KitKat, and� 
was postponed several times as Android mutated further to become Lollipop (L). This constant� 
evolution is still ongoing, with $QGURLG�0�DQQRXQFHG�HYHQ�DV�/�LV battling quite a few bugs. 
Nonetheless, it�was about time to publish the book once L showed signs of stabilization - and so I 
can proudly say�this book is updated till the latest and greatest.. at least at the time of publication.� 
)RUWXQDWHO\��WKDQNV�WR�WKH�ZRQGHUV�RI�VHOI�SXEOLVKLQJ��,�FDQ�NHHS�WKH�ERRN�DORQJ�ZLWK�WKH�ZLQGLQJ� 
FXUYH��DQG�WKH�YHUVLRQ�\RX
UH�UHDGLQJ�KDV�EHHQ�XSGDWHG�IRU�0�3UHYLHZ�5HOHDVH����-XQH�������

http://www.amazon.com/gp/product/1449308295/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449308295&linkCode=as2&tag=newosxbookcom-20&linkId=3J6JWRLXMYZUAWEG


I tried to learn from "mistakes" of my previous book, "Mac OS X and iOS Internals" (MOXiI).
One of the main criticisms I had was that said work was far too technical, and riddled with source
code, which made it hard for the non-developer type to get by. My own personal belief is of "Read
the Source, Luke", in that source code - unlike natural language - contains (almost) no ambiguities,
and is thus the right way of depicting facts. Nonetheless, in this book I've tried to provide as many
illustrations as possible, all without sacrificing detail. (I'm also adopting this book to the 2nd edition
of MOXiI, out later this year - not so much out of choice, but because the book dives into far deeper
and shadier aspects of both systems, for which there is no open source).

The book is also a lot more "hands-on", taking some of the hands-on exercises from our
Android training and recasting them in the form of Experiments. These are invaluable if you want to
get a good sense of the topics in the relevant section. Android is a UN*X derivative (by virtue of
Linux), and the only way one learns UN*X is through the fingers, and neither eyes nor ears. The
experiments demonstrate many useful commands from the Android command-line-interface (CLI),
and also techniques for looking deeper into the operating system. Furthermore, the experiments will
likely produce different outputs on different strains of Android - which makes them worthwhile to try
on your own device(s), so as to get different perspectives or implementations which may vary by
vendor or OS version.

Contents, at a glance

The book is designed to be read either cover-to-cover or as random, quick access. Each chapter
is largely self contained, and hyperlinks on topics allow quick associative navigation when reading
the book in e-Form. For print edition, relevant chapter numbers (for internal links) or URLs (for
external links) are provided. I have also added the paths to the AOSP files referenced, where
relevant - albeit in abbreviated form, so as to conserve space in the tables as the paths can be a
mile long.

Chapter One provides an introduction to the operating system: Examining the evolution of the
OS over its versions (since Froyo, which is the only obsolete version which you might still encounter
in the wild, and up to L. It also explains the architecture (at a high level view), and the Linux
underpinnings, by traversing each layer of the Android stack. It then looks at Android derivatives,
both Google's and other vendors (e.g. Amazon's FireOS), before concluding with some thoughts and
ideas for future directions.

Chapter Two dives right into the technical bits - specifically, Android Partitions and filesystems.
Starting with an examination of the partitioning scheme used by Android (which, unfortunately, is
far from standardized across vendors), and filesystems - Ext4 and F2FS. What follows is a tour of
filesystem contents, which should prove useful if you ever need to figure out what a specific system
directory or file contains. A few of the built-in apps data directories are also covered, which is handy
if you're doing forensics. The chapter also discusses the Android "Protected Filesystems" (OBB and
ASEC), though those fail miserably on rooted devices. Finally, the role of the Linux pseudo-
filesystems - cgroupfs, debugfs, procfs, sysfs and others - is described.

Chapter Three builds on its predecessor - which covered partitions - to explain the role of
partitions in the Android boot process. Starting with a discussion of the Android boot images (what
some refer to, albeit incorrectly, as ROMs), and how to flash them onto the device's boot partitions.
The default Android boot loader is explained (with the more heavily technical aspects left as a bonus
article on the book's companion website), and the other components of the boot image - the kernel,
device tree, and initramfs - are described in detail. Experiments demonstrate how to unpack,
customize and repack these components (assuming an unlocked bootloader). The chapter also
discusses the images sent as over the air (OTA) updates, as well as the processes of
backup/restore, and shutdown.

Chapter Four is dedicated in its entirety to one process - /init. This, like its UN*X namesake, is
responsible for starting up the system in user mode. The process of startup is explained in detail,
through examination of the /init.rc file syntax. Other roles of /init, such as maintaining system
properties and watching for hardware changes (as ueventd) are detailed as well.

http://newandroidbook.com/Articles/aboot.html?book


Chapter Five discusses the native services - i.e. those listed in the /init.rc and loaded as Linux
binaries (in contrast to the Dalvik-level framework services, which are loaded as threads in
system_server and covered in Volume II). This chapter provides a detailed reference of each and
every daemon you're likely to find on your device - and there are quite a few of them.

Chapter Six provides a gentle introduction to Android's framework service architecture, by
explaining the roles of the  and  processes, which together form
the fulcrum on top of which all of Android's frameworks rest. Binder, the elephant in the chapter, is
described but briefly, leaving most of the meticulous detail for Volume II, but hopefully explaining
just enough to provide more insight as to how Android Inter Process Communication and Remote
Procedure Calls work.

Chapter Seven is a view of Android through a Linux lens - that is, looking at Android system
processes and apps through the /proc filesystem and Linux-level tools. This chapter is a "two-fer" in
the sense that you can apply most (if not all) of the techniques shown there on your Linux system
for native-level debugging.

Chapter Eight - the last chapter of this volume - concerns itself with Security. This chapter was
made available as a preview (originally, as Chapter 21, back when I naively thought I could fit
everything into one book!). It provides a detailed walk through of security features, both at the
Linux level and that of the frameworks, as well as a special section on rooting Android devices -
both in the "approved" ways, as well as some unexpected ones.

Conventions used in this book

Keeping this simple:

filenames are specified like this

,  or framework  are specified thus. The numbers
in parentheses refer to the manual section describing them, using the Linux man

Additionally, this book is full of Figures, Listings and Outputs. Figures are illustrations of�
components or message flows. Listings are generally static files, as opposed to Outputs which are�
sequences of commands��often included as part of an experiment�. In outputs, the idea was to 
show�the flow as well as usage of the commands, so the outputs are fully annotated, e.g.

Output 0-1: A sample output

Attention has been paid to detail - the username (as well as the prompt sign, $ or #) will tell��
you if the command requires shell or root privileges� 7he hostname shows you the device the��
command was tried on��with "generic" being the emulator, "flounder" being the nexus 9 (L), and��
otherwise the device name (s3, s4, kindle, nexus5, etc)�� DQG��)RUJH��EHLQJ�WKH�/LQX[�KRVW.�,�WULHG�� 
WR�DYRLG�VQLSSHWV�RI�FRGH��DW�OHDVW�LQ�9ROXPH�,���DQG�LQ�WKRVH�SODFHV�ZKHUH�LW�SURYHG�YLWDO��,�KDYH�� 
DOVR�SURYLGHG�DQQRWDWLRQV� The color scheme was (finally) adjusted to be easy on the eyes in both 
color (if you're reading the PDF) or black & white (for the print edition). 

 
   

 
 



.....Now let's get to it!

Finally....

The book proved to be a massive undertaking. Sifting through Android's sources is akin to
inspecting an organism down to the cellular level. For those who still wish to examine the sources
themselves, I have pinpointed the relevant files pertaining to each discussion, and hyperlinked them
(or put them as a table, for the print edition of the book). The interested reader should most
definitely obtain the sources of the latest version, either by using  and , as explained in
http://source.android.com/, or by looking through Google's Android Source Website.

The book has also been a one-man-project: With the exception of the cover art (provided for�me 
by the gifted Dino Tsiopanos, a great engineer who's an even greater illustrator!), everything in�this 
work - text, images, formatting, editing - has been done by myself. Thankfully, I enlisted the�help of 
my regular reviewers - Moshe Kravchik and Arie Haenel, to whom I am both indebted.�Nikolay Elenkov, 
who wrote the excellent "Android Security Internals: An In-Depth Guide to�Android's Security 
Architecture" contributed very helpful insights and feedback as well. Aviv�Greenberg - who at the last 
moment performed a binge reading and review - helped me with critical�comments. $OPRVW�Oast, but 
hardly least - Eddie Cornejo - who not only caught even more typos which�somehow eluded other eyes 
- but also made sure I was as unbiased as I should, given the "Other"�OS.�$QG���ILQDOO\��,�WKDQN�1LNROD�
9HOMNRYLF���ZKR�PHWLFXORXVO\�FDXJKW�IXUWKHU�W\SRV�HYHU\RQH�HOVH�PLVVHG�

 
 

A special, personal and most intimate thanks and gratitude goes to Amy, the Yin to 
my Yang, who provided infinite support and encouragement - as with my previous book 
(and with everything else). This is one thanks I will forever reiterate and never forget!

The book was painstakingly authored with , hand-typing standards-compliant HTML5 (yes,
I'm serious, and no, I probably wouldn't try this again). Illustrations are either SVG (another
traumatic ordeal), or drawn with PowerPoint. This should hopefully help explain why this book so
long to take out, though the good news is that Volume II (which is double the size of this work!)
should be available very soon. Pagination is a non-standard A4, meaning less pages than the usual
tech-book, but far more detail per page. Crafting an index for the book would have proved so
Sisyphean a task, I decided to not even go there (You can just search the PDF). Please keep all this
in mind if you spot any styling errors or (gasp) technical ones - Errare est humanum. For technical
errors only I offer rewards - a la Knuth - 0x100 cents will come your way if you report any (I'm
hoping for rampant inflation when QE subsides ! ).

I maintain a companion web site with bonus material and quite a few custom tools - at
http://NewAndroidBook.com/. Updates to this book, as well as typos and/or errata (which I probably
have), will be published through that site.

For those of you more into Tweeting, my company - @Technologeeks often tweets about
updates and bonus material to both my works. Technologeeks also provides expert consulting and
training services - on Android, OS X, iOS, Linux and more - so I encourage you to check out
http://Technologeeks.com/! The training on both Android and OSX/iOS, specifically, is based on my
books. The company also heads the "Android Kernel Developers" group on LinkedIn - if you feel like
dropping by and saying hi (or asking questions).

I do hope you find the book both interesting and entertaining (well, as entertaining as a 
technical book can get, I guess). I'm always available for comments/feedback through the 
companion web site, throu h a dedicated forum I have set up there.

2QFH�PRUH��,�RZH�WKDQNV�WR�<RDY�&KHUQLW]��,Q�D�ZD\��DOO�P\�ERRNV�ZLOO���EHFDXVH�LW�ZDV�KLV� 
LQFHSWLRQ�ZKLFK�VWDUWHG�P\�FDUHHU�DV�DQ�DXWKRU��0D\EH�EHFDXVH�WR�PH��WKLV�JRHV�ZLWKRXW�VD\LQJ��it 
actually did - TKH�SUHYLRXV�HGLWLRQ��EHIRUH�WKH�$QGURLG�0�XSGDWH��GLG�QRW�LQFOXGH�WKLV�PXFK�QHHGHG� 
WKDQNV��%XW�LQ�WKLV�FDVH��<RER�GHVHUYHV�extra VSHFLDO�PHQWLRQ�IRU�KDYLQJ�SXVKHG�PH�LQWR�$QGURLG. It was 
he who SURYLGed�7HFKQRORJHHNV�ZLWK�UHTXLUHPHQWV�IRU��/LQX[�WR�$QGURLG��DQG�ODWHU��$QGURLG�,QWHUQDOV�� 
��7ZR�FRXUVHV�ZKLFK�EHFDPH�EHVW�VHOOHUV��DQG�XSRQ�ZKLFK�WKLV�ZRUN
V�WZR�YROXPHV�DUH�EDVHG�

http://source.android.com/source/index.html
http://android.googlesource.com/
http://www.amazon.com/gp/product/1593275811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275811&linkCode=as2&tag=newosxbookcom-20&linkId=HYQWZPUY2IUS3BQR
http://newandroidbook.com/
http://twitter.com/Technologeeks
http://www.technologeeks.com/?ab


I: The Evolution of Android's Architecture
Though Android is built on Linux and relies heavily on much of its infrastructure - most 

notably�the kernel - Android has become an operating system in a class by itself. Unlike OS X 
and iOS, which�share the majority of their code base (with the exception of the UI and several 
frameworks),�Android introduces a vast collection of frameworks, as well as a runtime to support 
them (Dalvik).�Indeed, most of the user-facing features and enhancements in between versions 
have to do with�additional frameworks and APIs being added, with only a relatively small portion 
of them at the�system level.

This Chapter explores the evolution of Android, and examines its architecture. Beginning 
with�the Android version history, from Cupcake (1.5) to /ROOLSRS (�����),�DQG�EH\RQG� we cover 
system-related features�and enhancements in each. We then turn to examine the Android 
architecture, comparing and�contrasting with that of Linux. Each layer is described in detail, 
laying the foundations for the even�deeper exploration carried out in the next chapters (and 
next volume) of this work. Finally, we�consider the multitude of Android derivatives, as well as 
future enhancements which may be�expected in the next versions of this rapidly evolving OS. 

As this book ZHQW�to print, Android 5.0 (Lollipop) Zas made available for select��
Google Nexi, and is scheduled for rollout by vendor. Android is moving so fast, in��
fact, chances are that no matter when you read this, a new version of Android will��
only be months away, as the mobile OS arms race ensues. This book KDV�QRZ�EHHQ

updated to reflect changes iWKURXJK� 0� �SUHYLHZ� UHOHDVH� ���� EXW� $QGURLG
V� UDPSDQW�
DGYDQFH�FRQWLQXHV�RQZDUGV��It's�WKHUHIRUH a good idea to check the companion web site 
(NewAndroidBook.com) for��updates.

�

file:///Users/morpheus/Documents/Android/Book/Introduction.html#versions
file:///Users/morpheus/Documents/Android/Book/Introduction.html#vslinux
file:///Users/morpheus/Documents/Android/Book/Introduction.html#derivatives
file:///Users/morpheus/Documents/Android/Book/Introduction.html#wayAhead
http://newandroidbook.com/


Android version history

Over its seven short years, Android has already undergone no less than a dozen versions. 
When�one considers the API versions (which map the internal set of APIs to the catchier 
condiment type),�this number increases to 2�. Enumerating the many framework features 
introduced in each version�would be tedious and likely miss out on a few, so this section instead 
aims to provide a more�technical look, focusing on those API differences at the system (rather 
than framework) level, as well�as other noteworthy observations. Those seeking more 
information about changes are suggested to�read the comprehensive Wikipedia Entry1, or check 
the Android documentation for the respective�versions.

Table 1-1 shows the Android version history, and maps the official release version to that 
of the�API and the kernel. Note that the kernel versions don't necessarily match in all devices, 
as some�vendors compile their own kernel, or backport newer kernels.

Table 1-1: Android Versions, to date

Date Code Name Release API Kernel

3/2015
Lollipop

5.1������ 22 3.4(armv7)/3.10(arm64)

11/2014 5.0-5.0.2 21

10/2013 KitKat 4.4-4.4.4 19 (20)

3.407/2013 JellyBean (MR2) 4.3 18

11/2012 JellyBean (MR1) 4.2-4.2.2 17

07/2012 JellyBean 4.1-4.1.1 16
3.0.31

12/2011 Ice Cream Sandwich (MR1) 4.0.3-4.0.4 15

10/2011 Ice Cream Sandwich 4.0-4.0.2 14 3.0.1

07/2011 Honeycomb (MR2) 3.2-3.2.6 13

2.6.3605/2011 Honeycomb (MR1) 3.1 12

02/2011 Honeycomb 3.0 11

02/2011 Gingerbread (MR1) 2.3.3-2.3.7 10
2.6.35

12/2010 Gingerbread 2.3-2.3.2 9

05/2010 Froyo 2.2-2.2.3 8 2.6.32

10/2009 Éclair 2.0-2.01, 2.1 5-7 2.6.29

09/2009 Donut 1.6 4 2.6.29

Actual usage (and probably some behavioral) data is compiled by Google, and is made 
available�through the Dashboards on the Android Developer Website2. Since there are virtually 
no devices�remaining with versions older than Froyo, this work does not make any attempt to 
discuss them.

Froyo

FroYo (Frozen Yogurt) was the first version of Android to support application�
installation on external media (i.e. SDCards). It additionally introduced the notion�
of Android Secure Containers (ASEC), in order to provide security for files on�
external media, which by its nature is usually FAT formatted volumes (The ASEC�
mecKDQLVP�LV�GLVFXVVHG�LQ�&KDSWHU�����$QRWKHU�XVHIXO�IHDWXUH�LQWURGXFHG�LQ�WKLV�
YHUVLRQ�ZDV�86%�WHWKHULQJ��FRQQHFWLQJ�WKH�GHYLFH�DQG�XVLQJ�LWV�,QWHUQHW�FRQQHFWLRQ��
DV�GLVFXVVHG�LQ�9ROXPH�,,���/DVWO\��)UR\R�EURXJKW�VLJQLILFDQW�VSHHG�LPSURYHPHQWV�WR�
'DOYLN��ZLWK�WKH�LQWURGXFWLRQ�RI�-XVW�,Q�7LPH��-,7��FRPSLODWLRQ�E\�D�GHGLFDWHG�WKUHDG�

2

Late 2015 M (final name unknown) 5.2 (Likely) 22MRC

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://en.wikipedia.org/wiki/Android_version_history
http://developer.android.com/about/dashboards/index.html
http://developer.android.com/about/versions/android-2.2-highlights.html
file:///Users/morpheus/Documents/Android/Book/Volume%20I/FileSystems.html#asec


Gingerbread

Gingerbread was the first version of Android to gain widespread adoption, and
with good reason: It introduced significant enhancements to the system. At the Dalvik
layer, concurrent garbage collection was introduced, which improved application
response time by running GC in parallel, rather than pausing the application during the
process. Likewise, the JIT mechanism improved on Froyo's. The sensor APIs
underwent a complete revamp, extending the sensor HAL to support more sensor
types, and making them more accessible to native code. Support for native code was bolstered in�
other areas as well, providing native access to audio, graphics, storage and even the activity�
manager. Gingerbread was also first to introduce support for Near-Field-Communications (NFC),�
though it was only till later (with ICS) that NFC was to be adopted into ubiquity by Android vendors.

Another noteworthy addition is support for OBB - opaque binary blobs (referred to as "APK�
expansion files") as a workaround to the size limitation of application package sizes, and to 
provide�optional encryption. OBB files are discussed in Chapter 2. Last, but not least, 
Gingerbread adopted�Ext4 in place of YAFFS as the default filesystem.

All these improvements aside, Gingerbread is actually most notorious for being the most�
insecure version of Android to date. Apart from glitches with the stock SMS app (which 
routed�messages to the wrong recipients), it was riddled with quite a few vulnerabilities 
which led to an�explosion in rootkit-grade malware.

Honeycomb

Honeycomb brought Android to tablets. In fact, it was a "tablet-only" 
release,�in that the source tree was never fully released nor meant to be used 
for phones�(though some vendors still tried to use it nonetheless). The main 
change was the�introduction of fragments, which - like Windows' Multiple 
Document Interface�(MDI) allow several client areas to coexist simultaneously, 
rather than the single�layout architecture which was previously used.

Honeycomb also offered significant improvements in graphics - introducing
hardware accelerated OpenGL rendering for 2D, and introduced Renderscript, which is 
Android's�own GL-like language.

Another feature of importance was the advent of storage encryption. Honeycomb was the 
first�version of Android to offer low level encryption of the user data partition, bringing it in line 
with iOS�4, which introduced it as well. The disk encryption in Android is carried out by the 
Linux device�mapper, and can be thought of as the next step, following the Android Secure 
Storage which was�introduced in Froyo.

More important than the user space features was the introduction of multi-core support 
into�Android. Primarily, this involved a recompilation of the Linux kernel to support SMP (as 
can be seen�ZLWK�WKH�%XV\%R[�XQDPH�WRRO��RU��SURF�YHUVLRQ���7DEOHWV�ZHUH�WKH�ILUVW�GHYLFHV
 to utilize multi-core�architectures, which have since proliferated to all but the cheapest 
devices. The Android�Documentation6 details the changes required for code to be SMP safe - 
most of these are primarily�in native code, though some aspects apply to Java as well.

Honeycomb was the only version of Android whose source code was not made open (aside 
from�select portions). This made some vendors wary, and brought to mind the fact that even 
though�Android is free, Google still controls the system, and its licensing may change at any 
point in the�future, if Google so sees fit.

�

&KDSWHU�,��,QWURGXFWLRQ

http://developer.android.com/about/versions/android-2.3-highlights.html
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#obb
http://developer.android.com/about/versions/android-3.0-highlights.html
http://developer.android.com/training/articles/smp.html


Ice Cream Sandwich

Ice Cream Sandwich (ICS) brought many changes to Android, as can 
be�expected from a 4.0 release. Aside from the myriad UI enhancements, 
those�changes which were noticeable to users included significant 
connectivity�enhancements - The Android VPN Framework, WiFi Direct 
and Android Beam.

ICS adds another API often overlooked by developers - the  callback, 
which�is called at times of memory pressure. According to the integer code specified, an 
application should�release as much memory as possible. Note, however, that this API is advisory 
- applications can just�choose to ignore the callback (which all too many, in fact, do).

JellyBean

JellyBean's most prominent user-facing feature is in its support for multiple users 
on�the same device. This feature, more useful on tablets than phones (and formally 
only�enabled on the former), allows several users to operate the device. Though only 
one�user can be actively logged on, each user has a different UI, with separate 
widgets and�applications and - most importantly - isolation of application data. We 
discuss the�implementation of this feature in detail in Chapter 8.

In addition to this, and alongside the slew of UI features, JellyBean also provided�
application encryption and forward locking, building on Froyo's ASEC containers. One of the 
main�drawbacks of Android's open nature at the time was that it was trivial to pirate apps by 
moving�them between devices via the SDCard. ASEC provides a secure container for data, 
which can be�encrypted by the application, and made readable only by the application's uid 
(but still fails�miserably on rooted devices). This will, as mentioned, be covered in Chapter 2.

JellyBean went through three API versions, which introduced many changes, both over and�
under the hood. API 17 also brought SELinux to Android for the first time (as detailed in 
Chapter 8),�and sealed a gaping USB debugging hole by forcing authentication over ADB. 
Notable changes in�API 18 were support for OpenGL ES 3.0, Bluetooth Audio-Video Remote 
Control Profile (AVRCP) 1.3�and Bluetooth Low Energy (LE) support, as well as the App Ops 
service (whose UI was later�removed in 4.4.1), which allows tweaking application permissions.

KitKat

Version 4.4 of Android was codenamed "KitKat" (and was actually launched in�
partnership with Hershey's). It represents a genuine attempt by Google to combat 
the�fragmentation of the Android universe: Though JellyBean is the single most 
popular�version, a large percentage of devices still use old versions - notably 
GingerBread, which�are not only obsolete, but hamper apps from running due to 
their old API versions.�Additionally, middle and high-end market become saturated, 
and in the entry-level�category Android faces competition from FireFox OS and 
others.

KitKat's "pet project" was "svelte", an initiative to enable a smooth experience on virtually 
any�device, including low-end devices, with 512MB of RAM. Part of the rationale behind it is that 
a�smoother OS with less resource requirements would enable all vendors - even those with 
entry level�devices - to offer the latest OS version, thereby ending fragmentation. Doing so 
involved many�under-the-hood changes, such as rewriting framework code to use less memory, 
and starting�services in a serial manner (to reduce memory pressure). A new API was added to 
detect low RAM�GHYLFHV��$FWLYLW\0DQDJHU�LV/RZ5DP'HYLFH����ZKLFK�UHWXUQV�WKH�YDOXH�RI�WKH

 property). Using this API, developers can detect the amount of 
RAM�available, and plan resources accordingly. KitKat also added the  service to 
give�developers as much information as possible on their application's footprint.

�

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://developer.android.com/about/versions/android-4.0-highlights.html
http://developer.android.com/about/versions/jelly-bean.html
file:///Users/morpheus/Documents/Android/Book/Security.html#MultiUser
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#asec
file:///Users/morpheus/Documents/Android/Book/Security.html#selinux
http://developer.android.com/about/versions/kitkat.html


For those devices which do have RAM, KitKat utilizes a new feature of the Linux Kernel, 
called�zRAM. This feature is in fact newer than KitKat itself, having only been officially stabilized 
and�merged in version 3.14 (KitKat uses 3.4), but Google was an early adopter in both 
ChromeOS and�Android. The features enables swapping to RAM, and thus overcomes one of the 
major limitations of�mobile devices - the lack of swap on flash devices. While swapping to RAM 
might sound somewhat�counterproductive, it is in fact a dramatic improvement, as the swapped 
pages are compressed (thus�saving overall RAM usage) and quite fast to retrieve. Devices which 
use compressed RAM will have a�special block device (e.g. /dev/block/zram0), indicated by 
the /proc/swaps file.

Compressed memory also made its debut in iOS version 7.0, a few months before KitKat 
was�announced. Several other interesting features in KitKat may have borrowed from iOS 7.0 
include a�VWHS�FRXQWHU��VRIWZDUH�GHILQHG�VHQVRU��DV�DQ�DQVZHU�WR�$SSOH
V�0����DV�ZHOO�DV�
WLPHU�FRDOHVFLQJ�DQG�VHQVRU�EDWFKLQJ��7KH�ODWWHU�WZR�DUH�D�VLJQLILFDQW�LPSURYHPHQW�WKDW�
KHOSV�PD[LPL]H�EDWWHU\�OLIH��7R�GR�VR��$QGURLG�DFWXDOO\�UHGXFHV�WKH�JUDQXODULW\�RI�WLPHUV�DQG�
XSGDWHV�IURP�VHQVRUV��PDNLQJ�WKHP�PRUH�FRDUVH��EXW�DOVR�PRUH�OLNHO\�WR�FRLQFLGH��7KLV�FDQ�
JUHDWO\�LPSURYH�EDWWHU\�WLPH���ERWK�GLUHFWO\��ORQJHU�SHULRGV�RI�&38�LGOH�WLPH���DQG�LQGLUHFWO\�
�UHGXFLQJ�WKH�RYHUDOO�QXPEHU�RI�ZDNHXSV��ZKLFK�DUH�FRVWO\�ERWK�LQ�SRZHU�DQG�SHUIRUPDQFH��

Other notable features in Kitkat include Bluetooth MAP support, Infrared Blaster 
(ConsumerIr)�APIs, A new printing framework, and NFC host card emulation. Probably the most 
far reaching�change, however, was unannounced and kept under the scenes: introducing the 
Android RunTime�(ART), as an optional replacement to Dalvik.

At the time of writing, KitKat has undergone four minor revisions, and its most recent 
version is�4.4.4. Those revisions are mostly bug fixes and camera enhancements, and do not 
change the API�version, though internal APIs have been modified.�.LW.DW�UHPDLQV�WKH�PRVW� 
FRPPRQ�$QGURLG�YHUVLRQ��LQVWDOOHG�RQ�����RI�GHYLFHV��DV�RI�ODWH�$SULO������� 

Lollipop

The latest version of Android (at the time of writing) is Android Lollipop. The most�
obvious user-facing change in this version is the introduction of "Material Design", a 
flat�interface which aims to provide realistic lighting and motion effects, and print-
based design�which is strangely reminiscent of iOS 7's overhaul. Another emphasis in 
this release is on�notifications, support for which has been greatly expanded.

Under the hood�are far more significant changes: First and foremost is the�adoption of 
the Android Runtime (ART), which brings performance improvements by�compiling Dalvik 
code to native code Ahead Of Time (AOT), rather than Just In Time (JIT). Aside�from 
performance, ART also allows Android apps to exploit the benefits of 64-bit architecture��DV�
GLVFXVVHG�LQ�GHSWK�LQ�9ROXPH�,,. The�graphics stack has been updated with support for 
OpenGLES 3.1, and the audio frameworks have�been upgraded, particularly for better audio 
input handling. Likewise,�camera APIs have been revamped. Sensor support (via the 
Hardware Abstraction Layer) has been�upgraded, with support for more complicated 
gestures, and even a heart rate monitor. The "pet-project" of this release is "Project Volta", 
which aims to both improve battery life (through the new�MRE�VFKHGXOLQJ�$3,��DQG�SURYLGH�
EHWWHU�SRZHU�PRQLWRULQJ�WRROV��QRWDEO\��WKH�������������������� �� service). Lollipop also serves as 
the foundation�IRU� WKH�QHZ��$QGURLG�79��

�

&KDSWHU�,��,QWURGXFWLRQ

http://developer.android.com/about/versions/lollipop.html


Android M (final name as yet is unknown) is oo le's latest version of Android - It was 
announced in oo le I/  on 5/2 /2015. Havin  learnt from the mistakes made with L, oo le 
has committed to a strict timeline consistin  of three developer releases, each a month apart, 
with a final release date by the end of  2015. oo le provided both mulator and factory 
ima es (for the oo le exi), includin  - for the first time - ima es for ARM64, which the 

M  emulator in the Android SDK now supports. Sources are also available throu h the 
Android IT repository. 

rom a feature perspective, M seems more of an evolutionary update, than a revolutionary 
one. While it adds several noteworthy features, these are mostly in response to i S, and 
include support for payments, built-in fin erprint authentication (which was introduced in 
Lollipop, but is now made available for use by apps), and floatin  toolbars for text selection.

An important improvement comes int the form of revampin  the App permission model, 
which finally moves the permission enforcement to runtime, rather than install time. This brin s 
Android in line with the i S model, by promptin  the user to allow sensitive operations when 
they happen, rather than approve a mile lon  list of permissions in bulk upon installation 
(discussed more in Chapter ), and reatly miti ates the potential for tro an apps surreptitiously 
tryin  to access your personal information or camera, while entertainin  you with a flappin  
bird.

M also aims to improve on two drawbacks of its predecessors  Data encryption (which was 
introduced with HoneyComb and enabled by default in Lollipop) is now extended to external 
stora e, by means of adopted devices. Power mana ement - always a challen in  issue - is 
further improved with Do e  mode, sleepin  for lon  intervals between periodic wakeups for 
app syncin  and pendin  work. M also introduces App idle detection (somewhat reminiscent of 

S 's App ap  feature, which suspends apps which are not in use.

ther, more ori inal features include Direct Share, App Linkin , improvements to audio/
video syncin  (includin  fast or slow motion playback), MIDI support, direct flashli ht (torch) 
support, camera API extensions, improved notifications, and si nificant enhancements for 
Android for Work . A full list of chan es can be found on the Android Developer Website 

(http //developer.android.com/preview/api-overview.html).

  If oo le is true to their own advertised schedule, M may overtake Lollipop, (whose 
adoption rate is still dwindlin  in the low teens, as best) . endors may choose to wait a bit, 
rather than have to o throu h the lon  process of up radin  to Lollipop - only to be forced to 
up rade a ain when M comes out shortly after. 

M

Lollipop
V�release was quite lengthy and somewhat painful - It took Google about six 
months from�announcement ���������to official launch����������, and even at the time of 
writing, it is supported mainly on the�Google Nexi��ZLWK�D�SHQHWUDWLRQ�UDWH�RI�DERXW���� 
(DQG�WKDW��WRR��IRU�YHUVLRQV�EHIRUH�����. Major bugs�(ironically, relating to power management 
and performance) have been discovered in the earlier�releases, and ��PXFK�WR� WKH� FKDJULQ�RI 
YHQGRUV�ZKR�DUH�VWLOO�SOD\LQJ�FDWFK�XS���SXVKHG�*RRJOH�WR�XSGDWH�Lollipop �DV� RI�����������to 
5.1�, with $3,�OHYHO�����DQG�numerous bugfixes. 5.1 adds�P\ULDG�8,�WZHDNV, and - more  
LPSRUWDQWO\���QRWDEOH�IHDWXUHV�VXFK�DV��+'�9RLFH�FDOOLQJ��'XDO�6,0�VXSSRUW��DQG�"Device
3URWHFWLRQ���WKH�PXFK�QHHGHG��NLOO�VZLWFK��WR�ORFN�VWROHQ�GHYLFHV�UHPRWHO\��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://developer.android.com/preview/
http://developer.android.com/preview/api-overview.html


 Experiment: Figuring out your device's Android version

Though vendors customize Android in a variety of ways, the basic underlying system is 
the�same. Most Android users are familiar with the Settings >> System >> About Phone 
GUI, which�provides details about the Android version used*. The relevant class is

 (found under the AOSP's
packages/apps/settings), which uses the android.os.Build class. The values, however, 
are obtained�from system properties, so an often simpler way of getting to those values is 
directly, using the�JHWSURS�WRRO��7KLV�LV�VKRZQ�LQ�)LJXUH�����

Figure 1-1: Mappings between the Settings app  and system properties

The property settings, which are generated from the AOSP and placed into /system/
build.prop,�hold true on modified builds as well - even those as heavily customized as 
Amazon's "FireOS". The�most useful properties are  (API version), 
and� , which is itself an amalgam of several other properties, for 
example:

 

Property Describes
ro.product.manufacturer Vendor id

ro.product.name Device code name. For Google - fish names

ro.build.product:version.release Product name and Android base version

ro.build.id first letter: version (rest described in the documentation11)

ro.build.version.incremental Internal build number, auto-incremented by AOSP build system

ro.build.type user: user facing, eng: Engineers/internal

ro.build.tags release-keys: production system, actual certificates. 
test-keys: development

* - As of JellyBean, the "Build Version" provides the backdoor functionality to the Developer Settings (which include
ADB), by clicking seven times on the view.

�

Chapter I: Introduction

https://source.android.com/source/build-numbers.html#platform-code-names-versions-api-levels-and-ndk-releases


Android vs. Linux

Not just another Linux Distribution

Linux, the core of Android, has been around for well over a decade before Android was 
even�conceived. Linux is a fully open source operating system, whose kernel started as a 
Master's Thesis�of one, Linus Torvalds, and has since gained worldwide fame and adoption. A 
kernel alone,�however, does not a full operating system make. Torvalds decided to release his 
work as open�source, and attracted developers who extended it further, by providing 
components for it - binaries�both ported from other UN*X systems, as well as original ones. 
Linux exploded in popularity as a�free alternative to the expensive UN*X systems of the time, 
effectively undercutting them and�leading to the demise of most.

Along its rapid evolution, Linux attracted commercial interest. Companies, whose sole 
purpose�was to package the kernel along with additional binaries, sprouted and provided 
"distributions" of�Linux. These companies often provided Linux for free, basing their entire 
business model on�support. At times, "professional" or "enterprise" grade distributions, 
containing custom tweaks or�specialized tools, were provided, costing money to license.

Linux quickly became the de facto operating system of the embedded space. Contrary to 
other�players in the field, such as Windows CE (which required too many resources), and real 
time�operating systems such as PSOS or VxWorks (both of which involved heavy licensing fees), 
Linux�offered a platform that was not only free, but fully customizable and light weight. One 
company,�MontaVista, based its entire business model on porting Linux to the embedded space - 
notably, the�ARM, MIPS and PowerPC architectures. The port provided for Embedded platforms 
the same�functionality as that which was provided on the desktop - a fully featured shell 
environment. All for a�generous licensing fee.

But developers needed more. Long gone are the days of shell interfaces, and all users (save 
for�battle-hardened veterans) expect a graphical user interface from their operating system. 
Linux relied�on X-Windows, the traditional UN*X Windows architecture, for its GUI. Setting up a 
GUI on an�embedded platform was far from straightforward. Graphics programming using X-
Windows API was�also quite cumbersome. Additionally, vendors such as Montavista provided 
just the basic platform.�Developers still had to port additional components and create their own, 
often having to start from�scratch.

And then came Android.

Google spotted the promise in a mobile operating system back in 2005, when they 
acquired�Android, then a small startup by Andy Rubin. Android disappeared off the map, till 
its resurgence�some years later (shortly after Apple's "iPhoneOS"). Mobile vendors, trying to 
adapt to the�revolutionary device, quickly wanted to provide a similar experience - and 
needed to catch up�quickly.

Android's novelty arises from what it aims to provide - not just another Linux distribution - 
but a�full software stack. The term "stack" implies several layers. Android provides not just 
the basic�kernel and shell binaries, but also a self-contained GUI environment, and a rich set of 
frameworks.�Coupled with a simple to use development language - Java - Android gives 
developers a true Rapid�Application Development (RAD) environment, as they can draw on pre-
written, well-tested code in�the frameworks to access advanced functionality - such as Cameras, 
motion sensors, GUI Widgets�and more - in a few lines of code. With features that at first 
borrowed heavily from iOS and later�improved on them, Android became the de-facto OS for 
Mobile, much as Windows is for the�Desktop, or Linux was elsewhere.

�

Android Internals::A Confectioner's Cookbook (Volume I)



Android has since had its hegemony constantly reinforced by the feedback loop of its 
ecosystem�- Android's "App MarketPlace", (which quickly followed Apple's "App Store"), adopted 
that model to�allow developers to quickly distribute their apps in a manner far more (and some 
would say, too)�relaxed with virtually no hurdles. The result is that Google Play (as the 
MarketPlace is now known)�has surpassed the App Store and offers millions of apps. Adopting 
Android provides a mobile vendor�with instant access and compatibility with those apps, but only 
if they comply with Google's Mobile�Application Distribution Agreement (MADA), which mandates 
full integration of Google's apps and�services.

In a sense, Android has done to MontaVista and other Embedded Linux firms what Linux 
has�done to UN*X and other competitors - undercutting by providing a totally free alternative. 
Google�pushes Android for free, with no licensing fees (at least, for now), and fairly relaxed 
terms of use��WKRXJK�WKRVH�DUH�JHWWLQJ�WLJKWHU��VORZO\�EXW�VXUHO\���,W
V�QR�ZRQGHU��WKHQ��WKDW
Android has risen in only�a few years to achieve almost total hegemony of about 80% of the 
global mobile market, leaving�only a persistent bastion of iOS (presently at about 20%), along 
with nigh-insignificant dregs of�Windows Mobile and BlackBerry. A mobile vendor basically has 
only very limited options in a choice�of operating system: develop a homegrown one, or go with 
a ready made one. Nearly all opt for the�latter*, and then the choice boils down to Android, or 
Windows Mobile. Microsoft has tried to follow�the Android model and offer its system for free - 
but the effort was too little, and far too late - as it�lacks the ecosystem. BlackBerry, on its own 
part, has ported the Android runtime to its own OS,�hoping to win back market share by 
providing runtime compatibility with the multitude of Android�Apps.

Commonalities and Divergences from Linux

Android is built on top of Linux, but modifies it in substantial ways - including some which 
break�compatibility with the mainstream. The Android kernel source tree diverged from the 
mainline kernel�around version 2.6.27, but has been converging since version 3.3. In user-
mode, Google maintains�the frameworks and runtime of the AOSP (Android Open Source 
Project) in an entirely separate�repository. From a high-level perspective, though it's hard to 
quantify exactly how much the two�OSes differ, a safe estimate would be that Android and Linux 
are about 95% alike at the kernel�level, and about 65% or so at the user-mode.

This guesstimate is drawn by taking into consideration that, at the kernel level, aside from 
a�few differences (ARM platform and drivers not withstanding), the rest of the kernel source is�
unmodified. Those differences (which include IPC, memory and logging enhancements) are�
collectively referred to as Androidisms, and most have in fact by now been merged into the�
mainline - either replaced with similar kernel functionality, or included in the drivers/staging/
android)�directory.

At the user-mode level, there is more of a divergence, introducing two entirely new 
components�- the Dalvik runtime and the Hardware Abstraction Layer - as well as replacing glibc 
with Bionic, and�providing a custom version of init, the system startup daemon. The underlying 
OS, however, still�remains for the most part unmodified, with native binaries, processes and 
threads behaving as they�do on Linux. This enables the approach taken in this book, of 
discussing low-level Linux-based�approaches for debugging and tracing, as is discussed in 
Chapter 7.

Android also makes more clever use of features present in Linux, though left unused in 
most�desktop distributions. These include control groups, low-memory conditions (Linux OOM, 
which�Android expands on with its Low Memory Killer), and security features - capabilities and 
SElinux (as�discussed in Chapter 8).

Android also uses quite a few open source projects which were of limited popularity in 
Linux,�but form the backbone of its feature set. These projects (in the external/ folder of the 
AOSP) are�ODUJHO\�UHVSRQVLEOH�IRU�LPSOHPHQWLQJ�$QGURLG
V�QHWZRUN�FDSDELOLWLHV��DQG�LQFOXGH�

 (vpn),�  (service discovery and Wi-Fi Direct),  and  (tethering 
and Wi-Fi Direct), and�  (Wi-Fi). Other open source projects provide library-
level support (discussed and�shown later in Table 1-3).

* - Mobile device vendors are becoming increasingly uneasy with several shortcomings of Android: The first, is the common
feature base, which makes it hard to differentiate their product from others. The second, is increased dependency on
Google, which actually strives to enforce the Android look and feel across devices. Lastly, Google's Mobile Application
Distribution Agreement (MADA), which forces the inclusion of all Google Apps in order to gain access to the Play Market.
This has led some vendors (notably, Samsung) to look at alternatives (e.g. Tizen). At present, Android seems to be fully
entrenched and not likely to lose dominance any time soon.

�

Chapter I: Introduction

file:///Users/morpheus/Documents/Android/Book/LinuxLens.html
file:///Users/morpheus/Documents/Android/Book/Security.html


Figure 1-2 compares and contrasts the software stacks provided by Linux and Android. We 
then�move to explore the notable differences, in turn.

Figure 1-2: The Android Architecture, compared with that of mainstream Linux

Most developers are probably familiar with the Google-provided architectural diagram
(returned by searching for "Android Architecture") ad nauseam (virtually all other
books on Android include it in their introduction - often with the exact same colors).

That diagram, in this author's opinion, is simplified and not at all accurate in its representation
of layers (For example, JNI is entirely overlooked). As the layers unfold, this slightly different
rendition of the architecture will hopefully "make sense" just as much as, if not more than, the
traditional diagram. (Only as this book goes to print has Google finally provided a more
accurate (and visually appealing) diagram at the Android Source website12)

The Android Frameworks

Android owes a key part of its success to its rich set of frameworks. Without them, Android�
would have likely ended up as just another embedded Linux distribution (and would have in fact�
gone the way of MontaVista, which was highly popular before Android made its debut). By 
providing�the frameworks, Android facilitates the application creation process, allowing 
developers to use the�higher-level Java language, rather than low-level C/C++. The addition of 
the frameworks further�expedites the process, as developers can draw on the plentiful APIs, 
which handle graphics, audio�and hardware access. Unlike X-Windows and GNOME/KDE, these 
are far simpler, and operate in a�much more straightforward manner.

Through the use of Java package naming, Android frameworks are divided into separate�
namespaces, according to their functionality. Packages in the android.* namespace are 
available for�use by developers. Packages in com.android.* are internal. Android also supports 
most of the�standard Java runtime packages in the java.* namespace. Table 1-2 shows the 
breakdown of the�commonly used frameworks by package, sorted by the API version they were 
introduced in, so as to�give an idea as to the evolution of the operating system features. Note 
that the table only shows�when frameworks made their debut, and does not show their 
expansion, which does occur in�between API versions, as more classes are added.

�

Android Internals::A Confectioner's Cookbook (Volume I)

http://source.android.com/images/android_framework_details.png


 Table 1-2: The Android Frameworks

Package Name API Contents
android.app 1 Application Support

android.content Content providers

android.database Database support, mostly SQLite

android.graphics Graphics support

android.opengl OpenGL Graphics support

android.hardware Camera, input and sensor support

android.location Location support

android.media Media support

android.net Network support built over java.net APIs

android.os Core OS Service and IPC support

android.provider Built-in Android content-providers

android.sax SAX XML Parsers

android.telephony Core Telephony support

android.text Text rendering

android.view UI Components (similar to iOS's UIView)

android.webkit Webkit browser controls

android.widget Application widgets

android.speech 3 Speech recognition and Speech-to-Text

android.accounts
4

Support for account management and authentication.

android.gesture Custom gesture support

android.accounts
5

User account support

android.bluetooth Bluetooth support

android.media.audiofx

9

Audio Effects support

android.net.sip Support for VoIP using the Session Initiation Protocol (RFC3261)

android.os.storage Support for Opaque Binary Blobs (OBB)

android.nfc Support for Near Field Communication

android.animation

11

Animation of views and objects

android.drm Digital Rights Management and copy protection

android.renderscript RenderScript (OpenCL like computation language)

android.hardware.usb

12

USB Peripheral support

android.mtp MTP/PTP support for connected cameras, etc

android.net.rtp Support for the Real-Time-Protocol (RFC3501)

android.media.effect

14

Image and Video Effects support

android.net.wifi.p2p Support for Wi-Fi Direct (Peer-To-Peer)

android.security Support for keychains and keystores

android.net.nsd
16

Neighbor-Service-Discovery through Multicast DNS (Bonjour)

android.hardware.input Input device listeners

* - This table, while detailed, is not comprehensive, and only reflects the more important classes. A full list can be found at
http://developer.android.com/sdk/api_diff/##/changes.html, replacing ## with the API level

��

Chapter I: Introduction



Figure 1-3: Dalvik, Iceland (photo by Author)

Table 1-2 (cont.): The Android Frameworks

Package Name API Contents
android.hardware.display

17
External and virtual display support

android.service.dreams "Dream" (screensaver) support

android.graphics.pdf
19

PDF Rendering

android.print[.pdf] Support for external printing

android.app.job

21

Job scheduler

android.bluetooth.le Bluetooth Low-Energy (LE) support

android.hardware.camera2 The new camera APIs

android.media.[browse/projection/session/tv] Media browsing and TV support

android.service.voice Activation by "hot words" (e.g. "OK Google")

android.system ,  and 

In practice, the entire set of frameworks is bundled into several Java ARchive (.jar) files on 
the�device, in /system/framework and - in L - precompiled into the boot.art file. Although 
the AOSP is�open source, it can come in quite handy to locate a package directly in the JAR 
itself, which you can�GR�E\�LQYRNLQJ�GH[GXPS��RU�WKH�GH[WUD�WRRO��RQ�WKH�FODVVHV�GH[��ILOHV�
LQVLGH�WKH�-$5V�

The Dalvik Virtual Machine

Android's other notable addition is the 
introduction�of the Dalvik Virtual Machine. This VM 
became key to�making Android workable on mobile 
devices back when�256M of memory was considered 
"plenty". Dalvik was�not the first type of Virtual 
Machine to be attempted on�mobile devices - Sun 
Microsystems hoped to push Java�2 Mobile Edition 
(J2ME), but with very little success.

Dalvik is largely the brainchild of Dan Bornstein,�
whose Google I/O 2008 presentation serves as a great�reference as to its design. The QDPH���
'DOYLN ��was FKRVHQ LQ�KRQRU RI�D�fishing village in northern Iceland�

The Dalvik VM, though seemingly java-esque, is actually not a Java Virtual Machine. Though 
not�too far-removed from one, it runs a different form of bytecode (called DEX, for Dalvik 
Executable),�and is more optimized for efficiency and sharing memory than the JVM designed by 
Sun/Oracle.�Those very optimizations enabled it to prevail despite the strict constraints of mobile 
platforms,�which have felled Java (specifically, J2ME) from gaining ground outside limited 
implementations.

Android used a subset of the Apache Harmony files as basis for its core classes. Harmony 
was�chosen as a free (Apache-license) open source clone of (then Sun's, now Oracle's) JVM. 
Oracle�actually sued Google in 2010 for never properly acquiring a license for the Java class 
libraries, and�the saga is far from conclusion even in early 2015.

As this book goes to print, Dalvik is being superseded by the Android RunTime (ART), 
as�described later in this chapter. Contrary to popular belief, however, this does not mean 
Dalvik is�going away: Only the Just-In-Time (JIT) compilation aspect of it has been 
replaced, but the file�format (DEX) is still very much alive, as are the key architectural 
concepts. We therefore discuss�both Dalvik DnG ART in great detail in Volume II.

��

android.sHUYLFH�FDUULHU 606�006�VXSSRUW��&DUULHU0HVVDJLQJ6HUYLFH�2�

Android Internals::A Confectioner's Cookbook (Volume I)

https://www.youtube.com/watch?v=ptjedOZEXPM
file:///Users/morpheus/Documents/Android/Book/Introduction.html#art


JNI

Android Applications run in the virtual machine, but at times need to escape it - usually to�access 
hardware or other device (or chipset) specific features. Dalvik therefore allows the inclusion�of native 
libraries (ELF shared objects) in application code, through the Java Native Interface (JNI).

Android has somewhat of a love/hate relationship with JNI. No doubt vendors would be happier�
with pure Dalvik applications, as those are confined in the VM, and thus remain agnostic to the�
underlying architecture. In this way, Android applications would run universally - on Intel, ARM,�MIPS, 
and other architectures - with no modification. On the other hand, the VM environment is not�without 
its limits (especially when it concerns graphics) and drawbacks (notably decompilation). It is�therefore 
not at all uncommon to see JNI used in applications optimizing for performance, or�seeking resistance 
to reverse engineering. Google therefore provides the Native Development Kit�(NDK) (GRZQORDGDEOH�
DW�Android Developer14), which developers can use to build native libraries (and�binaries).

Not all applications use JNI, but in those that do, JNI libraries can be easily seen in the package�
(.apk) since they are in a separate folder: /lib/architecture. A good example of this can be found 
in�the DropBox App (here in an output from a Galaxy Tab 3 10.1), providing JNI support for no less�
than four different architectures:

Output 1-1: Demonstrating JNI Libraries in an APK

JNI normally works seamlessly across ARM devices (which comprise the vast majority), 
though�processor version differences (e.g. ARMv6, ARMv7) do require different libraries (hence 
"armeabi"�and "armeabi-v7a" in the output). When it comes to x86 architectures, JNI is a 
major headache for�Intel, who would like to see more vendors use its chipsets for Android. 
Rather than depend on the�app developers to compile an x86 specific version (most don't), 
Intel provides a closed-source ARM�emulation called Houdini (extending Dalvik/ART, as 
discussed later in Volume II) as part of their�Android distribution. This emulator, (along with a 
few minor modifications in Dalvik), enables ARM�native libraries to work on Intel architectures.

Native Binaries

From the Linux perspective, all executables are ELF binaries. Android's critical system�
component are implemented in C/C++, and are compiled into native binaries. User applications 
are�compiled into Dalvik bytecode, but the bytecode runs (or, in ART, is compiled ahead-of-
time) in the�context of a Dalvik Virtual machine, which is, in and of itself, an ELF binary. Thus, 
while most�developers remain oblivious to binaries, they nonetheless play an important role in 
Android.

Binaries are usually located in /system/bin, and /system/xbin (with a few critical 
binaries located�in /sbin). Most binaries are usually the same across all devices, being part of 
the AOSP, but it is not�XQFRPPRQ�WR�ILQG�DGGLWLRQDO�ELQDULHV�IURP�WKH�YHQGRU�RU�FKLSVHW
 manufacturer (e.g. ,�on Qualcomm MSM multi-core devices). You can see a list 
of processes loaded from native binaries�DW�DQ\�WLPH�E\�ILOWHULQJ�WKH�SV�FRPPDQG��7KLV�LV�
shown in Output 1-2 (from an HTC One M8), with�the AOSP binaries highlighted:

��

* - 1RW�WR�EH�FRQIXVHG�ZLWK�WKH�FRPPHUFLDO�DSS�RI�WKH�VDPH�QDPH��XVHG�WR�IRU�FORXG�VWRUDJH

Chapter I: Introduction

http://developer.android.com/tools/sdk/ndk/index.html


Output 1-2: Native binaries executing on an an HTC One M8

Because ELF is a standard file format, you can use any of the Linux ELF parsing tools (such as
, , or other tools in the set of ) to handle the Android binaries. The�

Android NDK provides the full toolset (cross compiled so it can run on the host) in the 
toolchains/directory, supporting x86, MIPS, ARM and - as of r10d - ARM64 - as shown in Output 
1-3: Output 1-3: Locating the Android NDK's binutils

��

Android Internals::A Confectioner's Cookbook (Volume I)



Bionic

Contrary to Linux distributions, which use GNU's LibC (GLibC) as their core runtime (the familiar�
libc.so), Android elects to use its own C-runtime library, which is called Bionic. This is touted as�
being motivated chiefly by simplicity15, though in practice there is a legal consideration as well - The�
GNU public license (GPL) places limitations on code which can use GLibC (similar iQ�some respects to�
GPL portions in the kernel), and Google sought to avoid that*. Bionic is open�source, but uses a�
hybrid of the BSD license (which is far more permissive for third party linkage)� as well as Android's�

own license.

Omissions

Legal issues aside, Bionic is more lightweight than GLibC, and more efficient for Android's�
purposes, leaving out features deemed unnecessary or too complicated. Notable omissions are:

Streamlined system call support: Since system calls are called frequently, Bionic aims 
to�optimize them by providing the thinnest wrappers possible. The system call stubs are�
generated with the help of bionic/libc/SYSCALLS.TXT. Some system calls are not at all�
exported.

No support for System V IPC: Among the system calls not exported by Bionic are those
dealing with UN*X System V Inter-Process-Communication (  and 
Shared�Memory ( ). This was a design decision in Android, 
deprecating these�forms of IPC in favor of Android's own (ASHMem and Binder, described 
in Volume II).
Limited Pthread functionality: On the one hand, Pthread support is built-in to Bionic 
(i.e.�not a separate libpthread.so). On the other, the pthread support is not full, with the 
most�QRWDEOH�IHDWXUH�PLVVLQJ�LV�VXSSRUW�IRU�WKUHDG�FDQFHOODWLRQ��YLD�SWKUHDGBFDQFHO��
 Mutex�support is also stripped down, made more efficient by relying on the kernel's fast 
mutex (the�IXWH[����V\VWHP�FDOO���EXW�KLJKHU�OHYHO�,3&�REMHFWV��H�J��UZORFNV��KDYH�EHHQ�OHIW�
RXW�
Limited C++ support: Though C++ is supported (indeed, most of Android's code is�
written in C++), exceptions are not. Likewise, the Standard Template Library (STL) is not�
included, though there is no restriction for linking against it manually (a port can be found in�
external/stlport project).
No support for Locales and/or wide characters: Bionic natively needs only ASCII,
though Unicode is also supported via libutils.so

The omissions make sense, considering that most code is meant to be done in the virtual�
machine, and the VM itself is written to avoid needing these functions: For example, the VM has its�
own thread management and Unicode support (via ICU). These omissions do, however, pose�
challenges to native code developers, especially those who seek to port libraries and executables�
from Linux to Android, as we discuss later.

Additions

Bionic also adds quite a few features to the standard LibC, which are optimized for Android.�
These include:

System Properties: Properties are a unique feature of Android, which allow both the�
system as well as applications to supply various configuration and operational parameters 
in�a simple key/value store. This is similar to the notion of Java properties (and, in fact, is�
accessible through Java's System.properties). Android relies heavily on this 
mechanism, which�is supplied through a shared memory region, accessible and read-only 
to all processes on the�system, but settable only through /init. We discuss the 
implementation of properties in�Chapter 4.

* - Google is avoiding GPL and licensing issues not just in Bionic, but in other components (e.g. udevd). GPL has
strict (legal) restrictions requiring linkage with likewise GPL open source components. Avoiding GPL maintains an
option for them to close the source at any time in the future (as they did once with parts of Honeycomb).

��

Chapter I: Introduction

http://android-platform.googlegroups.com/attach/0f8eba5ecb95c6f4/OVERVIEW.TXT?view=1&part=4
file:///Users/morpheus/Documents/Android/Book/Services.html#systemproperties


Hard-coded UID/GID implementation: Rather than rely on the passwd and group files as� 
traditional UN*X does, Android opts instead to hard-code the ids, and emulate getpwnam(3)� 
and friends. The reasoning for this becomes clear when Android's security model is�considered: 
Every application is assigned its own UID and GID (beginning with 10000) and�those IDs are 
then mapped to the human readable app_uXXX (or, as of JellyBean, uXX_aYYY)�format. 
Additionally, Android reserves the lower UID/GID range (1000-9999) for its own�subsystems. The 
AIDs (defined along with directory permissions in�android_filesystem_config.h) are described 
in more detail in Chapter 8, which deals with�VHFXULW\�

Built-in DNS resolution: Bionic integrates the DNS name-to-IP resolution code
(traditionally in libresolv.so). The code used in Bionic is more secure (randomizes both source�
port and query ID, to mitigate birthday attacks), and introduces a novel feature - per-process�
DNS resolution. This allows capturing and redirecting DNS requests by specific applications,�
through the definition of net.dns.pid system properties. The DNS configuration itself is also�
stored in properties (net.dns#). The nsswitch.conf, which on Linux allows name resolution�
through alternate protocols (e.g. NIS, LDAP) is understandably not supported, though�
resolv.conf is still supported (in /system/etc).

Hard coded services and protocols: Doing away with libresolv.so entirely, Android�
removes support for the protocols and services files (commonly found in /etc on UN*X), and
emulates  through its internal __res_get_static(). Other APIs, such as�

, are not supported.

Porting Challenges

As with the omissions, the additions pose a challenge when trying to port code the other 
way�around - that is, from Android to Linux. If these could be overcome, one could ostensibly 
port Dalvik�to Linux or other OSes (as indeed some developers have, discussed in Volume II), 
and have Android�apps working on desktops, as well.

Bionic presents the main hurdle for porting code to and from Android. While to some extent�
compatible with GNU LibC, the additions and omissions described above do mean that some 
more�advanced features - notably multithreading - will not port. For some source packages, 
however, all it�takes is recompilation with the NDK. In this way, many tar ball packages can be 
ported for Android�DV�ZHOO��WZHDNLQJ�WKH�FRQILJXUH�VFULSW�DQG�0DNHILOH�

Keeping in mind both Android and Linux export the same system calls, it should come as no�
surprise that statically linked binaries are often fully compatible (keeping in mind the same�
underlying CPU architecture). Static linking imports the specific dependencies from the various�
libraries into the core of the executable. A noteworthy example is Intel's Houdini (discussed in�
Volume II), which is provided on x86/64 versions of Android. A more common example still is�
BusyBox, which is an all-in-one binary supplying various shell command functionality: An ARM�
compiled static binary of Busybox taken from embedded Linux is mostly compatible, although 
minor�aspects (such as displaying Android AIDs) don't always work well.

It's worth noting that there are open issues in Bionic, specified in bionic/ABI-bugs.txt, 
which�affect some esoteric, but nonetheless potentially important datatypes, such as (at the time 

RI�writing)  (32-bit time, which will blow up in 2038) and  (32-bit file offsets). 
Also,�Bionic itself is optimized for 32-bit, and Apple's move to 64-bit will force Bionic (and, 
indeed, all of�Android) to be ported to 64-bit, as is already the case with L, and discussed later in 
this chapter.

��

Android Internals::A Confectioner's Cookbook (Volume I)

http://newandroidbook.com/src/Android/system/core/include/private/android_filesystem_config.h
file:///Users/morpheus/Documents/Android/Book/Security.html#uids
file:///Users/morpheus/Documents/Android/Book/Introduction.html#64Bit


Android Native Libraries

In addition to Bionic, Android contains quite a few other important libraries, which provide
runtime support for Dalvik, the frameworks, and the system processes. Those are strewn around the
source tree, so the following classifies them by the directories they are in .

Core Libraries

The libraries in system/core mostly provide wrappers over kernel Androidisms, or implement
additional functionality in user-mode, and include:

libcutils: Provides convenient support functions for kernel exported data (e.g. /proc/cpuinfo),
socket support, and Androidisms such as ASHMem.

liblog: Which wraps the Android /dev/log mechanism, to provide a fast and efficient, ring-
buffer based mechanism for logging.

libion: Wrapping the ION Memory Allocator, which was introduced in ICS.

libnl_2: Which wraps the Linux NetLink socket mechanism.

libpixelflinger: Used primarily by the SurfaceFlinger (the core of Android's Graphics stack,
described in Volume II). "Flinging" refers to the act of composing two or more inputs so that
in the case of graphics, for example, the resulting pixel is a (potentially alpha-blended) color
combination of the ones merged.

libsuspend: Which abstracts some aspects of power management, particulary those relating
to sleep and suspension of the operating system.

Lesser libraries include:

libdiskconfig: Abstracting disk (flash) configuration and partition management.

libcorkscrew: Used by the debuggerd to unwind stacks and symbolicate application crashes
("tombstones").

libmemtrack: providing process memory tracing services, with the help of hardware
modules, if any.

libmincrypt: providing basic implementations of RSA and SHA-[1|256], required for digital
signature processing.

libnetutils: Simplifying interface configuration and DHCP support.

libsync: Which wraps the kernel's  Androidism.

libsysutils: Provides primitives used by system utilities. Includes
Framework[Client|Listener|Command], Netlink[Event|Listener], Socket[Client|Listener] and
ServiceManager

libzipfile: Providing wrappers over zlib to handle zip files. Android uses zip extensively, with
application packages (.apk files) being a special case of zip.

��

Chapter I: Introduction



Framework support libraries

Libraries in frameworks/ provide native support services for the Android frameworks. 
Despite not�being part of the "core", they are nonetheless important, and further classified by 
subdirectories.

The frameworks/base/core/jni directory contains the very important libandroid_runtime.so,
which provides the low level JNI support for the Dalvik VM. The directory contains the JNI
components of over 85 framework (Dalvik-level) classes.

The frameworks/base/services/jni directory contains the equally important libandroid_servers.so,
which provides the low level JNI support the Android services.

The frameworks/base/native/android directory contains libandroid.so, which provides a native
interface to assets, storage manager, and more.

Libraries in base/libs include libandroidfw.so and libhwui.so. The former provides miscellaneous
support services such as zip file parsing and asset managements. The latter provides
hardware accelerated UI rendering, via OpenGL and SKIA.

Libraries in av handle media, audio and video. These include:

Camera HAL libraries - libcamera_client.so and libcamera_metadata.so (q.v. Volume II)

DRM Framework support (libdrmframework.so) supporting Android's Digital Rights
Management mechanism.

Media support libraries - including libeffects.so, libmedia.so, libnbaio.so,
libmediaplayerservice.so, and libstagefright.so.

The subdirectory av/services contains further support libs for services -libcameraservice.so, 
libaudioflinger.so and libmedialog.so.

Libraries in native/libs include:

libbinder: Binder support functions, discussed in depth in Volume II.

libdiskusage A tiny library providing directory sizing functions.

libgui: Provides GUI abstractions (such as the surface), built on top of libui.so

libinput: Provides basic primitives used by Android's input stack, as described in
Volume II.

libui: Provides the native APIs for Windows and Buffers, used by surfaceflinger (not
user events).

The native/ subdirectory also contains the opengl/ directory, which hold EGL and�
OpenGLES, discussed in Volume II).

External Native Libraries

Android relies on quite a few "external" libraries. The name refers to their location in the�
Android source tree, and the fact that they are not formally a part of Android - rather, they are 
open�source projects which lend powerful capabilities to the operating system.

There are well over 150 such external projects in the Android source tree, so this work does 
not� make an attempt to cover them all. Table 1-3 nonetheless attempts to touch on the 
important ones,�providing library support:

��

Android Internals::A Confectioner's Cookbook (Volume I)



Chapter I: Introduction

 Table 1-3: External library projects in the Android source tree 

Directory Contents

bluetooth Bluedroid library (libbluedroid.so), which supports user-mode bluetooth capabilities

icu4c libicuuc and libicui18n, handling Unicode support and internationalization

mdnsresponder Apple's Multicast DNS (Bonjour) - contains daemon (mdnsd) and library (libmdssd.so)

libselinux
libsepol SELinux support (JellyBean and later)

skia The SKIA 2D graphics library (discussed in Volume II)

sqlite The SQLite3 DB support, providing the core for many Android databases

svox libttspico and libttscompat, for SVOX Pico Text-To-Speech Engine

tinyalsa Minimal version of the Linux Advanced Sound Architecture (ALSA) library

webkit The webkit browser core, used by  controls

zlib Zlib - a library providing compression support for gzip and the like

Note that, once deployed on the device, external libraries are largely indistinguishable from� 
those of the AOSP, since all libraries end up alongside one another in . Similarly, it 
is� possible your device has additional vendor-specific libraries in  (though by 
convention�those should be placed in ).

Hardware Abstraction Layer

Android is meant to run on so many types of different devices - tablet, phones, STBs,�
treadmills, and what not - that the underlying hardware may greatly differ in its scope and 
support.�In an effort to combat this, Android defines a Hardware Abstraction Layer (HAL) which 
aims to�promote standardization by defining an adapter. Hardware vendors are free to implement 
their own�drivers in kernel mode, but must supply a shim, to conform to the interface Android 
(and�particularly, Dalvik) expects. The Hardware Abstraction Layer defines what an abstract 
camera, GPS,�sensor, and other components look like to Android. This does not preclude vendors 
from extending�or modifying functions - it only requires the vendor to drop the shim into /
system/lib/hw, and the�HAL - libhardware.so will automatically load them. Output 1-4 shows 
the HAL libraries used in the S5:

Output 1-4: Hardware Abstraction Layer libraries in the Galaxy S5

The Hardware Abstraction Layer is naturally a very important aspect of Android - both 
because�it represents a divergence from Linux, and because it is instrumental in supporting 
the slew of�Android devices. It is thus deserving of its own chapter, in olume II.

��

file:///Users/morpheus/Documents/Android/Book/Devices.html


The Linux Kernel

The Linux kernel, due to its open source and free license nature, provides an excellent 
substrate�for Android*. Now parsecs away from Linus Torvalds' initial version, the kernel keeps 
evolving at�remarkable speeds, with new features added every weeks or months. Android's own 
capabilities are�significantly affected by the kernel's, with notable examples being compressed 
RAM and 64-bit�support. The latter helps explain Table 1-1, which pits kernel version 3.10 as the 
minimum version�for Lollipop: The kernel officially supports ARM64 (AArch64) as of 3.7.

Android kernels are compiled slightly differently than those of Linux, with the config files 
being� generated by merging Android's base and recommended configuration templates with 
those of the� default kernel distribution (as shown in the source.android.com website's kernel 
section)16.

As previously mentioned, Android introduces its own idiosyncrasies, or Androidisms, into the
kernel. A few of these are in the kernel core, guarded by  statements for conditional�
compilation, with the rest being in drivers/staging/android directory. These Androidisms, 
as of 3.10�and later, include:

Anonymous Shared Memory (ASHMem): A mechanism to allow shared memory.�
Applications can open a character device (/dev/ashmem) and create a memory region which�
can then be mapped into memory. This is requireG to work around the restriction of no 
world-writable directories and System V IPC.

Binder: The crux of all IPC in Android. A legacy of BeOS, Binder presents a character device
(/dev/binder) which all applications can open. Android services register with Binder, and
clients can connect to them, with the help of . Binder provides efficient,
advanced IPC, as discussed in Chapter 6, and explained in depth in Volume II.

Logger: providing kernel-based ring buffers for fast, file-less logging. Android logs are
maintained by character devices in /dev/log. Android L augments this with a user mode
daemon, , discussed in Chapter 5.

The ION Memory Allocator: Introduced in ICS, and offers efficient memory allocation to
kernel drivers and user mode alike (through /dev/ion). ION replaces an older Androidism,
PMEM, and aims to standardize memory management in the various SoC architectures.

Low Memory Killer: A layer on top of Linux's own Out-Of-Memory (OOM) killer, which
terminates processes in case of memory exhaustion. While the latter is heuristic driven, the
former provides a more deterministic way of controlling process termination, and allows
defining memory pressure levels. Android L augments this with a user mode daemon, ,
discussed in Chapter 5.

RAM Console: A mechanism for preserving kernel panic output (thread dump and last
 log). This has been deprecated in newer releases in favor of the Linux kernel's

own  (described in Chapter 2).

Sync driver: The latest Androidism, introduced to allow fast synchronization primitives, used
primarily by Android's Graphics stack (in particular, ).

Timed Output and GPIO: Allowing user mode programs to access GPIO registers�from user 
space, and automatically reset their values after a timeout. The main client of this�is the 
device vibrator functionality: The framework (via the HAL) can write a millisecond value�into /
sys/classtimed_output/vibrator/enable, to start the device vibration, which automatically�quiets 
down after the timeout specified.

Wakelocks: Originally a separate Androidism to control power management and prohibit the
kernel's sleep functionality, wakelocks have gradually been merged with the kernel's own
wakeup source mechanisms. (Power Management is detailed in Volume II, with a relevant
excerpt on the book's companion website).

* The kernel, in fact, provides a substrate for myriad Linux offshoots, including Samsung's Tizen, Jolia's Sailfish, Firefox OS,
and Ubuntu on Smartphones. All of these are seen as potential competitors to Android, though their market share, at least
as of early 2015, is infinitessimal.

��

Android Internals::A Confectioner's Cookbook (Volume I)

https://source.android.com/devices/tech/kernel.html
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#Binder
file:///Users/morpheus/Documents/Android/Book/Services.html#logd
file:///Users/morpheus/Documents/Android/Book/Services.html#lmkd
file:///Users/morpheus/Documents/Android/Book/Filesystems.html#pstore


Figure 1-4: Android Wear launcher UI

Android Derivatives

Google offshoots

Google has made it clear that it wants to make Android ubiquitous in all kinds of devices - not�
just phones and tablets. True to their vision, they announced three new offshoots of Android.

Android Wear

With rumors of Apple supposedly working on an
"iWatch", it's no surprise Google quickly rushed to�announce 
"Android Wear" back around KitKat. Android�Wear is a version 
of Android optimized for wearable�devices (which, at the time of 
writing, are a single-category�domain, watches, though could 
ostensibly be extended to�other wearable devices). At the core, 
Android Wear is the�same Android used in phones and tablets, 
but the home�activity (main screen) has been replaced by a 
simpler�interface, owing to a watch's diminutive display. This�
includes an emphasis on voice commands (by tapping on�the 
Google icon), notifications, and cue-cards. Some wear�devices 
also support round screens, as well.

Android Wear, identified by "clockwork" in the

 UR�EXLOG�ILQJHUSULQW�SURSHUW\��can be thought of as�a "slimmed down" version of Android. 
Unnecessary�frameworks and services have been removed, both to conserve memory, as well as 
CPU (battery life�being a major limiting factor of wearable devices). A comparison between the 
phone and Wear�flavor of KitKat reveals that all telephony services (phone, iphonesubinfo, 
simponebook, isms), as�well as print, appwidget, backup, usb, wallpaper, device_policy, and the 
drmManager have been�removed in Wear. Applications have likewise been slashed from over 
180MB (in about 60 packages)�to a mere 12MB in only 16 packages, leaving only watch specific 
applications��&ORFNZRUN6HWXS�DSN��&ORFNZRUN6HWWLQJV�DSN�DQG�WKH��3UHEXLOW&ORFNZRUN+RPH�DSN�
launcher), or those that can operate on a small screen (in other words, the default�SDFNDJHV�RI

 from KK are not present or loaded in Wear). The SDK for Wear has been 
released�with documentation available in the Android Developer website17.

Android Wear devices are, at present, designed to serve as satellites for more capable devices,�
such as a smartphone or tablet. Their only connectivity is via BlueTooth, and most of their�
frameworks are stubs, which connect to the full featured ones on a phone. Samsung, an early�
adopter for its "Galaxy Gear" watch, is migrating away from Wear in favor of its homegrown Tizen,�
citing issues with battery life and limited functionality as being the key drivers.

Android Auto

Shortly after Apple announced "CarPlay",�
integrating iOS 7 with cars, Google happened 
to�announce "Android Auto", which aims to 
do�surprisingly similar things: Provide a 
convenient�interface to use mobile devices in 
cars, with access�to useful apps such as 
navigation, the music�player, and (of course) 
the phone. As with Android�Wear, there's an 
emphasis on voice commands�and 
notifications - this time not because of screen�
limitations, so much as the requirement for 
hands-free operation.

Figure 1-5: Android Auto UI (source: Google)

��

Chapter I: Introduction

http://developer.android.com/training/building-wearables.html


From the developer perspective, the important difference is that there is no need for a separate�
car-specific UI. In fact, there's no need for any UI in Android Auto, because the built-in system UI�
communicates with specific aspects of app functionality, and presents them as the "drawers", which�
are list driven menus. This enables the driver to select functions with the navigation buttons found�
on most steering wheels. Apps can still customize the built-in UI, by specifying icons and�background 
images, but don't need to display any custom UI Views, as they would normally.�'HYHORSHUV�QHHG�
to declare an additional XML file, with an  element, and specify�which features 
they use - with "media" and "notification" presently being the supported features.

The XML file is connected to the App via a  element in the App's�
, specifying the 

reserved value for the name attribute.

Google has detailed the interface changes, such as the launcher, and the drawer-based UI 
at�the Android Auto website��.

Android TV

TV Makers have long been using proprietary OSes to run their device - Samsung's Tizen and�
LG's WebOS (formerly Palm/HP's) being the two most prominent examples. Google wishes to 
extend�Android's hegemony into this space, as well (gaining the fringe benefits in the trove of user 
viewing�habits). This is Google's second attempt at entering television, with their "Google TV" being 
less of a�niche product than "Apple TV" is.

Android TV has been announced and released alongside Android L, with ample documentation�
on the Android TV website19. From the emulator images, one can discern the main difference is in
the launcher ( , in /system/app/LeanbackLauncher.apk), the built 
in TV�app ( , in /system/priv-app/TV.apk), and the TV Content provider
(  in /system/priv-app/TvProvider.apk). The content provider 
exports�URIs in android.media.tv for  (the remote control), ,  and

. The latter three are stored in the provider database,
/data/user/0/com.android.providers.tv/databases. Other features have also been adapted for 
TVs,�notably remote-control based navigation, and huge screen sizes.

Android TV will likely evolve considerably in the future (perhaps evolving to compete 
with�Apple's plans for extending Apple TV and iOS). Future enhancements would likely 
involve better�streaming support, enhanced EPG (Electronic Programming Guide) 
functionality, integration with�ChromeCast, and gaming platform support. But there is 
another foe to consider in the TV space -Amazon.

Non-Google ports

Because of its open nature, vendors are free to customize Android in oh-so-many ways. Most�
enhance (or detract) from the standard UI, in an effort to differentiate their device from "yet�
another Android". Notable examples include HTC and Samsung, with their "Sense" and TouchWiz�
UIs, repectively. Others pack Android into new types of devices - for example NVidia with their�
Shield console. In all the above cases, however, the base system is still very much the same�
Android. Further, Google provides the "Compatibility Test Suite" (cts/ subtree of AOSP), which�
vendors must pass in order to get the official blessing (and be assured that apps will function�
correctly). Additionally, Google makes the Play Market inseparable from its other services. As an�
price to enter the ecosystem, vendors must bundle the entire set of Google utilities - Maps, Mail, 
etc�- making it more likely the device will be tied to a Google account (and thus, an identity).

Other vendors, however, only take Android as a substrate, and make vast modifications. 
They�willingly give up the ecosystem, because they often create their own. One such example is 
Chinese�smartphone maker XiaoMi, whose top-of-the-line devices at rock-bottom prices has 
propelled it to be�one of China's (and possibly the world's) largest. XiaoMi built an entire 
business by investing in its�own ecosystem, and has willingly abandoned Google's services, most 
of which are blocked in China�anyway. One can imagine Google can't be too happy with it 
(missing out on order of 100 million or�more users), but this is just a consequence of Android's 
open source nature. And it could be worse -Nokia, for example, experimented with versions of 
Android that have been "converted" to Microsoft's�cloud services. And on this side of the ocean, 
there's Amazon. 

��

Android Internals::A Confectioner's Cookbook (Volume I)

http://developer.android.com/training/auto/index.html
http://developer.android.com/training/tv/index.html


FireOS

Amazon is one of the vendors that has no doubt benefitted the most from Android. The giant�
retailer made its foray into the tablet market with its Kindle line, which was based on a proprietary�
embedded Linux distribution, and an e-Ink display. With the Kindle Fire, Amazon modernized their�
tablet, using Android as the core operating system.

Much to Google's chagrin, however, Amazon fully customized their version of Android, and�
rebranded it as "FireOS". The interface was entirely revamped (sporting a "carousel" like selection of�
apps), the devices are locked and keyed to Amazon only - effectively useless without an Amazon ID,�
and any trace of Google - search, Play store, accounts, or otherwise - has been eradicated.

From a technical perspective, FireOS's core is still very much Android. Changes in it, 
however,�are quite radical and include removal of all things Google, and replacement with 
Amazon.�Specifically:

Carousel as the home activity: The familiar Android launcher has been replaced by Amazon's
custom launcher, com.amazon.kindle.otter.

Default Browser is "Silk": or, by its other name, com.amazon.cloud9. This is a WebKit based
browser, heavily modified and optimized to use Amazon's Elastic Compute Cloud (EC2) to
optimize web browsing.

Google Play replaced by Amazon App Store: Internally referred to as com.amazon.windowshop
and com.amazon.venezia.

Amazon Offers as screen saver: Utilizing Android's "Dreams" functionality to install a screen
saver filled with ads. Internally, this is done by several components in the com.amazon.dcp
package, and ads stored in /data/securedStorageLocation/dtcp/ (incidentally, revoking
permissions on this folder effectively disables ads).

Aggressive OTA updates: The com.amazon.dcp package contains a host of services meant to
ensure the device is constantly up to date. Unlike other Android versions, FireOS doesn't ask
to update - it just goes ahead and does so. (Automatic updates are explained in Chapter 3)

Amazon has taken several pages from Apple's playbook, most notably locking down the system�
to resist rooting (or at least, try) as well as prevent downgrading of the operating system once an�
update has been installed (which it often is, automatically). With FireOS as a whole, Amazon steps�
further away from the Google vision of Android, launching its own "Fire Phone", and its "Fire TV",�
each with proprietary interfaces and APIs.

Headless Android

Take Android, and remove Dalvik and its accompanying frameworks, and you are left with a�
operating system that has no GUI support, nor any use for an ecosystem. Such an OS, however, is�
still valuable in its own right, as a base embedded Linux distribution, which has already been�
adapted to work with ARM and MIPS processors. Before the advent of Android, embedded Linux was�
a complicated and highly difficult environment, owing in large part to the complexity of building the�
cross-compiler toolchain, and the user mode libraries. Companies which provided this toolchain and�
environment (along with support) were highly sought after.

Android, however, completely disrupted the realm, turning the tables on the major Embedded�
Linux players. Rather than acquire a license for tens of thousand of dollars, embedded Linux now�
became entirely free - by simply downloading the Android sources and NDK, anyone can build and�
customize the system to their own needs. Android in its headless deployment now forms the basis�for 
many systems which don't need GUI - sensors, appliances and others, and is likely to be a major�
player in the "Internet-of-Things" revolution, which promises to embed ARM and MIPS (and maybe�
Intel) processors in everything but the kitchen sink.

It's possible in Android to enjoy the best of both worlds - that is, both the rich frameworks, and
a system with no UI. The system can be made to operate with no UI by setting the 
system property. This allows developers to use the frameworks for various non-UI related tasks
(such as interfacing with sensors), as well as benefit from the object orientation and other advanced�
aspects of the Dalvik and ART environments.

��

Chapter I: Introduction

file:///Users/morpheus/Documents/Android/Book/Boot.html#OTA


Pondering the Way Ahead

Prophecy is the gift of fools, but it's interesting to contemplate the next direction to be taken by�
Android. The war between iOS and Android rages on, with Android quickly adopting (and, by some�
claims, blatantly copying) features from iOS - and in some cases vice versa. Still, it seems rather�clear 
from the present landscape as to some features will very likely be included in the next Android�- 
Macaroon, Meringue or whatever condiment name Google will choose for it.

64-Bit compatibility

With the introduction of the iPhone 5S, Apple caught the entire mobile industry by surprise,�with 
the first 64-bit mobile architecture. This perplexed many, which were quick to dismiss it as�useless 
marketing. 64-Bit support was initially discounted because its chief advantage, address�spaces larger 
than 4GB, is in fact questionable in a mobile environment. Though some tablets�already ship with RAM 
of 2GB, 4GB are still beyond the needs of most devices. 64-bit memory�access is also slightly less 
efficient than 32-bit (involving more page table lookups), so many were�quick to mock Apple for such a 
"feeble attempt at innovating" and a useless gimmick*.

In practice, however, there's more to 64-bit than meets the eye. Though ARM 64-bit processors�
still support 32-bit code, the native 64-bit (ARMv8) instruction set has been completely rewritten to�be 
more efficient. Add to that, the width of 64-bit registers (and the larger register set), and the�
advantage quickly becomes apparent. The 64-bit architecture (along with some remarkable designs�in 
Apple's custom A7 chip), blew past the performance of all other mobile processors, while�maintaining 
an impresively low power footprint. In fact, this proved that the boasting quad and�octo-cores was the 
useless gimmick, as Apple's flagship processor was still a dual-core. Further,�adding more cores directly 
impacts power performance, so most cores are actually powered off the�overwhelming majority of a 
device's life time.

The move - a vertical, rather than a horizontal expansion, thus proved to be a brilliant one, and�an 
especially efficacious stratagem: Though requiring virtually no work in iOS other than a�recompilation 
of the app, porting Android to 64-bit is a lengthy process. Android's core components�- notably Dalvik 
and Bionic - are 32-bit optimized, and therefore need to be completely rewritten. Of�all vendors, Intel 
has been quickest to jump on the 64-bit wagon, since its mobile processors are�already fully 64-bit 
native. The various ARM vendors, however, need to adapt to the move (though�Samsung was quick to 
announce their "next big thing" will naturally be 64-bit). HTC's Nexus 9 ZDV�DPRQJ�WKH�ILUVW 64-Bit 
ARM processorV (Nvidia's Tegra K1), and Qualcomm�VRRQ followHG with the Snapdragon 
810��+7&�2QH� 0����DQG�6DPVXQJ�ZLWK�WKHLU�([\QRV��LQ�WKH�6��. QEmu (which powers the�Android 
emulator) KDV finally been updated to support ARM64 emulation with the M Preview Release 1 SDK.

Android RunTime (ART)
Android still proves inferior to iOS in several aspects, not the least of which is power�

management. This can be traced back to its Linux foundations (which are geared towards an�
immobile desktop or server, where power is rarely a concern), but also due to its many layers. 
While�layers provide for elegant abstrations, portability and other aspects of fine design, they 
are often�dismal in terms of performance and power management, as they require more 
processing. The main�layer in Android - Dalvik - involves significant processing, and even its 
many enhancements (e.g JIT�compilation) still require much more work than native code would. 
By comparison, iOS's runtime and�frameworks are implemented in Objective-C, which is an 
extension of standard C, and still very�much native**. 

* - One of the strongest rebukes of this move was made by none other than Qualcomm's senior VP and CMO, who claimed
"they are doing a marketing gimmick. There's zero benefit a consumer gets from that". A week later Qualcomm retracted
his comment, and he was shortly after "reassigned"20. 

** - In iOS 8, Apple has made the first moves to break away from Objective-C with the introduction of Swift, a featureful
yet lightweight programming language which boasts impressive runtime performance when compiled, but also when
interpreted.

��

Android Internals::A Confectioner's Cookbook (Volume I)

http://www.cnet.com/news/after-apple-64-bit-a7-criticism-qualcomm-exec-reassigned/


The Android RunTime (ART) provides an alternative. Silently introduced in KitKat and dubbed�
"experimental", ART aims to use Ahead-of-Time (AOT) compilation, to LLVM and even native code,�
thus bring it on par with iOS performance. ART presently offers only small advantages in power and�
performance over Dalvik (on order of 10-20%), and in some tests also falls behind it. Nonetheless,�
as of Lollipop, ART is the chosen runtime, and is vital in order for Android to provide 64-bit�support*.

As alluded to earlier in this chapter, however, Dalvik is far from dead: Applications will still be�
packaged with Dalvik bytecode (classes.dex), with ART taking over and compiling to native code 
only�when deployed on the device (replacing the on-device optimization stage usually carried out by�
GH[RSW���%RWK�'DOYLN�DQG�$57�DUH�GLVFXVVHG�LQ�GHSWK�LQ�9ROXPH�,,���

Split-Screen

Android already has the necessary foundations to allow different activities to run in parallel to�
one another on a split screen: Samsung has extended the GUI for this capability, which is also�
supported in Windows 8, and with rumors abuzz for this feature to be added to the iPad in iOS 8.1,�
it makes sense to see it mainstream on Android. This is a purely framework-level feature, since from�
the native perspective there's no real change - the activities as processes run concurrently anyway.�
This could be a major step on the road to making Android a full desktop OS replacement, as well.

Android as a desktop OS

With so many tablets vying to become a desktop replacement, why not make Android a desktop�
OS? Microsoft introduced Windows 8, which took desktop Windows, and improved(?) it to support�
mobile devices - tablets and phones. Android would need to make the reverse transition, bringing its�
mobile support to desktops, which could then run Android apps.

Doing so is not necessarily that hard - as we discuss in Volume II, Dalvik's open source nature�
makes it quite portable, and implementations for other OSes - naturally, Linux, but also Windows,�OS 
X and even iOS(!) exist. None of those are sponsored nor supported by Google, but with iOS and�OS 
X edging closer and closer still to one another, some have postulated that OS X will soon run iOS�
apps (some have even go so far as to suggest Apple will make the transition to ARM on its Macs). If�
that were the case, the binding between the ecosystems would become a strong differentiator in�
iOS's favor, which Google will surely not ignore for long.

There are a few obstacles, however. For one, it's not trivial to support full desktop applications.�
The Linux OpenOffice and most other apps are already built on top of X-Windows (and GNOME or�
KDE), and thus would have to be adapted to Android. In addition, Android would have to be�
extended to support mice (though arguably its InputManager already supports cursor devices), and�
multiple windows (again, technically supported to an extent by the WindowManager). Last but not�
least is ChromeOS, which Google is developing as its answer to Windows, in the hopes of ousting�the 
latter the same way Chrome usurped the lead to become the world's most popular browser.

Android and Project ARA

ARA21 is the code name for a project developed by Google with the goal of producing a fully�
modular smartphone. The idea is to make all system components swappable - the CPU, display,�
storage - are all replaceable, much in the same way in the PC world it's a farily simple matter to�
install a new hard drive or graphics adapter. ARA is a vestige of Google's Motorola Mobility�acquisition 
(since sold off to Lenovo), developered by the former's Advanced Technology and�Projects (ATAP) 
division, which was retained by Google.

* - It's important to note that Dalvik code is still 32-bit, rather than 64-bit optimized. While Dalvik does support "wide" data
types, most operations are 32-bit. This means that, while compiling to native code does offer some benefits of the 64-bit
architecture, the code is still not as efficient as "pure" 64 bit.

��

Chapter I: Introduction

http://www.projectara.com/


Figure 1-6: Modular smartphones (from the Motorola blog)ARA makes the device, in
effect, a chassis (more
accurately, an endo skeleton),
and components are separate
modules - not unlike a PC.
Electro permanent magnets
(that can be turned on/off
electronically, but do not require
power for everyday use) hold
modules in place. In theory, all
components (save for the CPU,
and possibly the display) are hot
swappable (i.e. they can be
replaced while the device is
working). Coupled with 3D
printing, this could lead to
"printable" phone designs which�could be downloaded, and an array of upgradeable 
modules which would render the annual full�upgrades of mobile devices extinct.

As ARA is developed by Google, it's only natural that Android be the OS of choice for it.�
Supporting ARA, however, will require heavy modifications in Android - at the framework level, 
but�even more so at the underlying Linux layers, all the way down to the kernel. Google has 
partnered�with Linaro for these purposes, and is investing ridiculous sums of money at 
developing both the�software and hardware necessary to standardize all the modules. ARA is 
still in its infancy as this�book goes to print, with an estimated release (initially, in Puerto Rico) 
later in 2015. If successful,�however, a truly modular mobile device would amount to nothing 
less than a second coming of the�mobile revolution - and this time, Google wants to be there 
first.

Summary

This chapter explored the evolution of the Android architecture to the present day (KitKat), 
with�an emphasis on its low-level features. It compared and constrasted the Android 
architecture with�that of its parent - Linux, to show the two are in many cases not at all that far 
apart, though at�present not interchangeable. Next, the many derivatives of Android were 
introduced, and though of�different skins and appearance, they all, at their core, function as 
Android does, so you should find�this work applicable to them just the same. The chapter 
concluded with pondering future directions�for Android (L, and beyond), and the features it is 
likely (or not) to support.

The next chapters explore the various aspects of Android, each in as much detail as 
possible.�We begin with the Android Filesystem - naturally based on that of Linux - but using 
defined�partitions and filesystems (some more clearly defined than others).

��

Android Internals::A Confectioner's Cookbook (Volume I)

http://motorola-blog.blogspot.com/2013/10/goodbye-sticky-hello-ara.html


References

1. Android version History, WikiPedia: http://en.wikipedia.org/wiki/Android_version_history

2. Android Dashboards (usage statistics):
http://developer.android.com/about/dashboards/index.html

3. Froyo feature summary: developer.android.com/about/versions/android-2.2-highlights.html

4. Gingerbread feature summary: developer.android.com/about/versions/android-2.3-
highlights.html

5. Honeycomb feature summary: developer.android.com/about/versions/android-3.0-
highlights.html

6. SMP Primer for Android: http://developer.android.com/training/articles/smp.html

7. Ice Cream Sandwich feature summary: developer.android.com/about/versions/android-4.0-
highlights.html

8. Jellybean feature summary: developer.android.com/about/versions/jelly-bean.html

9. Kitkat feature summary: developer.android.com/about/versions/kitkat.htmlKitkat feature
summary

10. Lollipop feature summary: developer.android.com/about/versions/lollipop.html

11. Android version numbering convention: https://source.android.com/source/build-
numbers.html#platform-code-names-versions-api-levels-and-ndk-releases

12. A much better Android architecural diagram:
http://source.android.com/images/android_framework_details.png

13. Dan Bornstein presenting Dalvik, Google I/O 2008: https://www.youtube.com/watch?
v=ptjedOZEXPM

14. Android NDK: http://developer.android.com/tools/sdk/ndk/index.html

15. Google Groups Bionic discussion: http://android-
platform.googlegroups.com/attach/0f8eba5ecb95c6f4/OVERVIEW.TXT?view=1&part=4

16. Android Kernel Configuration: https://source.android.com/devices/tech/kernel.html

17. Android Wear Developer Website: http://developer.android.com/training/building-
wearables.html

18. Android Auto Developer Website: http://developer.android.com/training/auto/index.html

19. Android TV Developer Website: http://developer.android.com/training/tv/index.html

20. Qualcomm reassigns exec after 64-bit criticism: http://www.cnet.com/news/after-apple-64-
bit-a7-criticism-qualcomm-exec-reassigned/

21. Project ARA official Website: http://www.projectara.com

��

Chapter I: Introduction

http://en.wikipedia.org/wiki/Android_version_history
http://developer.android.com/about/dashboards/index.html
http://developer.android.com/about/versions/android-2.2-highlights.html
http://developer.android.com/about/versions/android-2.3-highlights.html
http://developer.android.com/about/versions/android-3.0-highlights.html
http://developer.android.com/training/articles/smp.html
http://developer.android.com/about/versions/android-4.0-highlights.html
http://developer.android.com/about/versions/jelly-bean.html
http://developer.android.com/about/versions/kitkat.html
http://developer.android.com/about/versions/lollipop.html
https://source.android.com/source/build-numbers.html#platform-code-names-versions-api-levels-and-ndk-releases
http://source.android.com/images/android_framework_details.png
https://www.youtube.com/watch?v=ptjedOZEXPM
http://developer.android.com/tools/sdk/ndk/index.html
http://developer.android.com/tools/sdk/ndk/index.html
http://android-platform.googlegroups.com/attach/0f8eba5ecb95c6f4/OVERVIEW.TXT?view=1&part=4
https://source.android.com/devices/tech/kernel.html
http://developer.android.com/training/building-wearables.html
http://developer.android.com/training/auto/index.html
http://developer.android.com/training/tv/index.html
http://www.cnet.com/news/after-apple-64-bit-a7-criticism-qualcomm-exec-reassigned/
http://www.projectara.com/


Android Internals::A Confectioner's Cookbook (Volume I)



II - Android Partitions and Filesystems
This chapter begins with a discussion of the substrate for filesystems - the partitions

themselves. The device's storage is broken up into disjoint chunks, each of them individually
formatted and purposed. We discuss how you can analyze the partition layout, and investigate many
of the partitions which are otherwise reserved and inaccessible.

We then turn our attention to the Android filesystems which the system does regularly use:
/system (where the OS itself is installed), /data (where user data is stored), and others. The
directory structure of these filesystems is discussed, with important files and folders pointed out.

Finally, we consider the Linux pseudo-filesystems, which - although not a part of Android per se
(but of the Linux kernel), nonetheless serve important functions during system operation, primarily
for diagnostics and hardware access.

��



Partitioning Scheme

Android users are often surprised to find that their device, stated as coming with "X GB of
Flash", in practice has less than the advertised space. Power users, who go into ADB and type 'df' to
add the numbers find that not only does the Android OS take up a sizeable chunk, the amounts
reported under "used" and "free" simply don't add up to the stated device capacity.

Some of the difference can be explained by the fine print, which usually states that the 
definition of "GB" is a loose one. Rather than follow the 210 convention, wherein 1KB = 1024 bytes, 
1MB = 1024KB and 1GB = 1024MB - # On device: use chmod as root to allow adb to read drive 
sectorswhich would define 1 GB to be 1,073,741,824 bytes, marketing pits 1GB at 1,000,000,000 
bytes - already a noticeable 7% evaporated by false advertising. But the difference still leaves tens, 
and sometimes hundreds of MB or more unaccounted for. The missing megabytes stem from the 
device partitioning: most of the flash is used for Android - but some space is left for other purposes. 
Android flash storage is often partitioned into dozens of partitions, of which Android uses about 5. 
It's not uncommon to see 25 or more partitions on some devices, (such as the Kindle Fire or the 
Nexus 5), or even 70(!) in the case of the HTC One M9. Of those, the user can only write to one 
partition - /data and no other. In fact, most are not even mounted during regular use. This section 
discusses the partitioning scheme used, and how you can use tools to uncover those otherwise 
hidden partitions, which often may contain interesting content.

The exact partitioning scheme of Android may vary significantly in between vendors, and
even individual devices. For the most part, however, the partitions use the same semantics,

those size and number will surely vary. Most of the examples in this chapter are from Qualcomm
chipset (msm) devices, which make up the vast majority of Android devices, anyway.

The need for separate partitions

Most desktop users, especially in the Windows world, are probably used to having one, or in 
some cases two partitions. The classic desktop view has always been that fewer partitions suffice - 
a view no doubt linked to the legacy MBR partitioning scheme, which by design allowed only four 
partitions. In UNIX, however, using multiple partitions has been much more of a norm, as it allows 
for greater flexibility during system upgrades, and other administrative operations. Multiple 
partitions do have one notable disadvantage - which is imposing artificial limitations on available 
space, as it is subdivided by partitioning. UN*X administrators have always found clever ways 
around that, however, by using symbolic links, or - when more space is needed - adding new disk 
space and redirecting to it, by means of mounting.

In the mobile domain, using multiple partitions makes sense as well, albeit for somewhat
different reasons. One of the chief concerns of mobile devices is that they must always be
repairable, and so some type of "recovery mode" must be enabled on them. To allow for system
recovery or upgrades, there must be some way to boot the system from a known "safe" copy of an
operating system. In fact, it is not uncommon on some devices to find multiple copies of the boot
loader components - identical copies - to ensure bootability, just in case. Additionally, some
components, such as the modem or other firmware components (and the bootloader itself), need
their own storage space for storing configuration files or images.

Note, that not all partitions are actually mounted by Android: In fact, only a scant few often
are, with the remainder either meant for use during recovery, or exclusively by system components.
The latter are also unmountable by definition, because they often contain proprietary formatting,
which the Linux kernel does not recognize.

The GUID Partition Table

Taking all the above considerations into account, the need for multiple partitions becomes clear,
as does the realization that quite a few of them would be necessary. The MBR partition scheme is,
therefore, ruled out, leaving the GUID Partition Table (GPT) as the viable option. MBR is still
"technically" used, in the sense that the first sector of the device often contains a dummy MBR
record, with one partition spanning the entire drive. The second sector contains the GPT header,
which in turn maps out all the partitions. This is demonstrated in the following experiment:

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



A full discussion of GPT is beyond the scope of this book, and is also quite unncessary: The
Linux kernel can figure out the partition map, and export it to user space via /proc - commonly,
/proc/partitions. This is discussed next.

Experiment: Obtaining the Partition Table from a Device

The GPT table is normally inaccessible from user mode, as it resides outside the partitions themselves, and
therefore requires raw access to the disk device. If your device is rooted, however, you can examine it if you
copy the first sectors and use  (on your host) to analyze.

Output 2-1: Reading and identifying the GPT

Because  normally runs as uid:shell, there are several ways to obtain raw disk access:

1. Re-run adb as root: This requires setting the  and 
properties during startup, or use a modified version of adbd which doesn't drop privileges.

2. Use  as root: to copy data from the block device node to a file, which you can then
place in /data/local/tmp, and  to be readable by uid shell (or anyone).

3. Use  directly: on the block device node, so it is readable by uid shell (and, in fact,
everyone). Note this might fail in some cases on KitKat and later, depending on SELinux.

All methods carry with them a certain amount of risk: Running  as root would compromise
your phone if it falls into the wrong hands. Using  incorrectly (e.g. confusing  and ) can
wipe entire partitions in a heartbeat. Using  to make a device readable to anyone could
ostensibly enable dormant malicious applications on your device to access data which would
otherwise be well protected.

Though commonly the second method is used for handling raw devices, the last approach is
the one employed in this book. Of the three, the author believes it carries with it the least risk: For
one, it is perfectly reversible (and will not persist across a reboot). Additionally, it only provides
read access (and therefore does not risk data corruption.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV



Flash Storage Systems

The storage used on Android devices is not entirely standardized - some devices use MTD
(Memory Technology Devices), whereas others (e.g. HTC One) use eMMC (Embedded MultiMedia
Card), and others still use MMC (MultiMedia Card). Depending on the system used, the partition map
is made available to user mode via /proc/mtd, /proc/emmc (respectively), or the Linux standard
/proc/partitions (often in addition to one of the former two).

For the most part, whatever system is actually used is largely transparent to most. At a high
level, the chief difference between the systems is that MTD is an abstraction layer over raw flash,
whereas the MMC and eMMC have their own Flash Translation Layer (FTL) and appear to the kernel
as block devices. Most modern devices therefore use one of the latter two, as this makes them far
more suitable for use with block based filesystems such as ext4, which has inherited YAFFS as the
filesystem of choice in modern Android versions.

File Systems

Android enforces no constraints as to the filesystem types, but eMMC and MMC devices
presently use the Linux Ext4 filesystem (as of Gingerbread, in place of the older YAFFS system),
since the storage layer exports a block device. Ext4 has become the default filesystem in Linux as of
2.6.27, and is a well tested filesystem, albeit not a necessarily flash-optimized one.

Some devices (notably the Moto X) have begun adopting the Flash Friendly File System (F2FS)
as the filesystem of choice for the data partition. As of L, this is also the default data filesystem of
choice for Google's Nexi. The filesystem (designed by Samsung) is a log-structured one, optimized
for NAND flash. It boasts performance improvements over Ext4, especially in random write requests.
Indeed, extensive benchmarking tests posted to XDA-Developers1 show F2FS has clear advantages
over Ext4.

A good discussion of F2FS's features can be found in a Samsung presentation2 and an article by
Neil Brown on LWN.net3. It has been integrated into the mainline Linux kernel as of 3.8, and - as
Android upgrades to a newer kernel - it is likely to be used on more devices.

Android also supports VFAT, an MS-DOS compatible filesystem which it uses for SD-Cards.
Because it originated in the DOS and Windows 9x world, VFAT doesn't support the notion of
permissions. Android therefore resorts to mounting the SDCard in a secondary mount using a
specialized mechanism, discussed later in this chapter.

The kernel maintains a list of all supported filesystems in /proc/filesystems. This pseudo-file lists
which filesystems are supported either natively (i.e. compiled into the kernel) or as a loaded module.
In Android kernels, vendors often compile support for filesystems directly into the kernel, although
it's quite possible to leave support for a filesystem in a module, and bundle the module as part of
the root filesystem.

The good news about filesystems is that, so long as they work, the user can remain blissfully
oblivious to which filesystem is in use. The bad news, however, hits when the filesystems don't work
- specifically, when filesystem corruption occurs. Corruption is (thankfully) a rare event, and usually
occurs when the device is improperly shut down (for example, due to power loss or an unexpected
crash), or underlying hardware failure. Android provides default binaries to check and repair
filesystems - ,  and , for the respective filesystems. The binaries
are run automatically when mounting a file system (by  or ).

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://forum.xda-developers.com/showthread.php?t=2697069
http://elinux.org/images/1/12/Elc2013_Hwang.pdf
http://lwn.net/Articles/518988/
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#sdcard


Experiment: Examining partitions on an Android device

You can view the partition map of your Android device by examining the /proc/partitions file. This is a
standard kernel /proc entry, which provides a listing of all block devices. The flash storage layer in MMC and
eMMC devices is displayed in the mmcblk#[p#] form, where numbering for devices starts with zero, and for
partitions with one. Block are 512-byte (½K) blocks. The "major" and "minor" refer to the device driver, with
"major" being, in effect, the index used by the driver in the kernel's block device table, and "minor" being the
index of the logical device (in this case, used to disambiguate the partitions from one another).

Output 2-3: /proc/partitions from a Nexus 5

Telling apart the partitions just by their cryptic name is hard, but thankfully most devices have symbolic
links, by-num and by-name, in the /dev/block/platform/name.# directory. The platform name refers to the
controller, in Qualcomm's case msm_sdcc.1 for the main storage:

Output 2-4: //dev/block/platform/.../by-name from a Nexus 5

Note, that your local Android device partition names can and likely will vary. While most MSM devices
generally adhere to the above conventions, NVidia based devices deviate from it (with nigh-incomprehensible
three letter abbreviations for partition names), as do OMAP-based ones.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

/system

/data



Android Device Partitions

As the previous experiment has shown, partitions on Android devices have set names, but most
of them are quick cryptic. To complicate matters, different device chipsets and vendors use different
partitions, as well as different names for the same functional partitions. To explicate, we break the
partitions into the following classes:

Standard Android Partitions

All devices find a common denominator in those partitions which are hard coded into Android
itself, in various locations around the source tree. These partitions comprise the core of the OS.

The standard partitions are mostly mountable, with the exception of the boot and recovery
partitions, which are (commonly) formatted with Android's proprietary bootimg format (explained in
the next chapter). Table 2-1 shows these partitions:

Table 2-1: Android Standard Partitions

Name format Notes

boot bootimg Kernel + initramfs. Contains kernel and RAMdisk to boot by default.

cache Ext4 Android's /cache: used for updates and recovery.

recovery bootimg Boot-to-recovery: Kernel + alternate initramfs to start system recovery.

system Ext4 Android's /system partition - OS Binaries and frameworks.

userdata Ext4/F2FS Android's /data partition - User data and configuration.

Android devices contain a file system mounting table. This table, in /system/etc/vold.fstab or (in
more recent versions of Android) /fstab.hardware, is loaded by the Volume Daemon ( ) during
system startup, and provides the partitions which are to be mounted automatically (much like the
classic UN*X /etc/fstab.

Chipset-specific Partitions

Chipset vendors often require dedicated partitions for their components. The most notable
example is Qualcomm, whose MSM chipset (arguably the most popular) uses the partitions shown in
table 2-2. The bootldr format is discussed in the next chapter.

Table 2-2: Partitions found on Qualcomm MSM devices

Name Format Notes

aboot bootldr Application Processor Boot:This contains the Android Boot Loader. Note
some devices may use custom boot loaders instead (e.g. HTC's HBoot).

modem MSDOS Contains various ELF binaries and data files to support device modem

modemst[1|2] proprietary Non-Volatile data for modem

rpm ELF 32-bit Resource Power Management: This provides the first stage bootloader

sbl[123] Proprietary Secondary Boot Loader optionally split into up to three stages.

tz ELF 32-bit ARM TrustZone

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Boot.html#bootimg
file:///Users/morpheus/Documents/Android/Book/Boot.html#bootldr


Vendor-specific Partitions

The rest of the partitions found on an Android device are specific to vendors, who use custom
partitions for their own purposes, mostly device configuration maintenance or upgrade operations.
The formatting used is often proprietary. A partial list of such partitions is shown in table 2-3:

Table 2-3: Vendor custom partitions

Name Vendor Notes

hboot HTC HTC's proprietary boot loader. Replaces aboot on HTC devices

efs Samsung Encrypted File System. Contains various configuration files

ssd Samsung Secure Software Download

ota,fota Samsung Firmware-Over-The-Air: Used in the process of phone updates

grow Samsung, LG Empty partition, to allow partition growth

laf LG (G2, Nexus5)
Contains an alternate bootimg which loads lafd (LG Advanced
Flash Daemon) used for device re-flashing. The laf partition is a
recovery image format.

imgdata LG (G-PAD, G2, Nexus5) RLE images in IMGDATA format, similar to BOOTLDR

The XDA-Developers forum maintains an on-going list of partition maps from various devices
(similar to the one in the previous experiment) in its El Grande Partition Table Reference4.

Experiment: Viewing mounted partitions on a Device

You can examine the mount points by using  or . The former provides disk usage
statistics for the mounted partitions. This is shown in listing 2-dfmount, which shows the output of
the command on a Nexus 9, with L:

Output 2-5: Demonstrating  on a Nexus 9

Note that the  output differs from the traditional Linux , since the command is
implemented as a  tool. Only filesystems mounted over actual storage (that is, "real"
devices) are shown.

By comparison, using  provides far more verbose information, as it provides
information on pseudo file systems - implemented in memory - as well as mount options, though
at the cost of reporting space. The mount options displayed may either be generic, or filesystem
specific. Table 2-4 provides an explanation on the options you are likely to encounter.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/FileSystems.html#f-ep
http://forum.xda-developers.com/showthread.php?t=1959445


Experiment: Viewing mounted partitions on a Device (cont.) 

Table 2-4: Commonly encountered mount options

Option Kind Specifies
ro
rw Generic Read-Only: Allows only read operations, and cannot be modified.

Read-Write: Allows both read and write operations

acl Generic Allow extended Access Control Lists, for finer control than
user/group/other

seclabel Generic SELinux labels are enabled on the filesystem

nosuid Generic The filesystem does not allow SetUID binaries

noatime Generic File operations do not record access time - only modification or creation.
This makes file access faster and reduces write activity

relatime Generic Update access time relative to creation/modification time

data= Ext3/4 ordered: commit data to filesystem before writing journal. 
journal: commit data to journal before filesystems.

errors= Ext3/4
continue: silently ignore errors
remount-ro: remount filesystem as read only if errors are encountered
panic: Crash the system

background_gc f2fs Reclaim space freed by deleted files in a kernel thread

The  command is shown in the following output. The pseXGo-filesystems are in italics, and�
can be recognized by the fact they are not mounted on a device (that is, the first column does not�
start with a /dev path.

Output 2-6: Demonstrating  on a Nexus 9

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Android Filesystem Contents

Irrespective of vendor, The Android standard partitions have a well defined filesystem layout.
Device vendors use the Android filesystem images provided by Google for the Android emulator as a
point of departure, but the journey is often a very short one. We next describe the contents of the
various filesystems starting at the root, and progressing by mount point.

 Note, that while the filesystems are largely the same across devices, your device's contents
can and will vary: many vendors, including Google, drop additional device specific binaries. These
are referred to as proprietary blobs, and you can see those dropped into /system in the device/
subdirectory of the AOSP, in files called proprietary-blobs.txt per device.

The root file system

Android's root file system is mounted from a RAM Disk (the "initramfs"). Upon every boot, the
boot loader (fastboot) loads the filesystem image from the boot partition onto RAM, and provides it
for the kernel. The process is detailed in the next chapter, but for the purpose of the present
discussion, the salient point is that the root filesystem image cannot be easily modified, unless the
device is "flashed". This is important, because the root filesystem contains the most important
component of the system - /init, which runs unfettered as root, and controls the system startup.

Vanilla Linux normally uses the initramfs to supply drivers (in the form of kernel modules) to the
kernel during the initial boot, and eventually discards it in favor of the real filesystem. Android,
however does not - Android's initramfs remains resident and provides the root filesystem
functionality, which is in practice limited to housing /init and several other configuration files and
binaries. These are shown in table 2-6:

Table 2-6: The contents of the Android root filesystem (excluding mount points)

Directory Notes

default.prop
"Additional default property" file, sourced by init to load system-wide properties. Loads
read-only properties which help enforce security

init The binary launched by the kernel on startup as PID 1. Described in Chapter 4.

init[...].rc
The configuration file(s) for /init. The main configuration file is always /init.rc, with
optional additional files which are device and vendor dependent. Likewise described in
Chapter 4.

property_contexts
Kitkat: Property contexts for SE-Linux. Restrict access to system properties. Described
in Chapter 8

seapp_contexts
Kitkat: Application contexts for SE-Linux. Restrict application operational scope.
Described in Chapter 8

sepolicy Kitkat: The compiled SELinux policy (q.v. Chapter 8)

sbin/
Contains critical binaries, such as adbd, healthd and (most importantly) recovery,
which the system needs even if /system cannot be mounted. May also contain vendor
binaries.

verity_key L: Contains the DM-Verity RSA key required to authenticate the /system partition.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file_contexts
Kitkat: File contexts for SE-Linux. Restrict access to system files and directories.
Described in Chapter 8

fstab.hardware The filesystem mount table used by fs_mgr and vold (described in Chapters 4 and 5)

file:///Users/morpheus/Documents/Android/Book/Boot.html#initramfs
file:///Users/morpheus/Documents/Android/Book/Security.html#SELinux
file:///Users/morpheus/Documents/Android/Book/Init.html
file:///Users/morpheus/Documents/Android/Book/Init.html
file:///Users/morpheus/Documents/Android/Book/Security.html#SELinux
file:///Users/morpheus/Documents/Android/Book/Security.html#SELinux
file:///Users/morpheus/Documents/Android/Book/Security.html#SELinux


/system

The system partition is the home of all Android components, as provided by Google and/or the
vendor. The directory and its contents are owned by root:root, and all have permissions of 0755
(rwxr-xr-x), but the filesystem is mounted read-only. A read-only mount makes sense for two
reasons:

Stability: Because the filesystem is mounted read-only, there is virtually no chance of it
being corrupted, even if the device is powered-off abruptly. This reduces the chance of an
error which might "brick" the device by preventing Android from booting.

Security: A read-only mount is another layer of defence to protect the Android system
components from being tampered with. In practice, though, it is trivial to remount the
partition as read-write.

Some vendors, notably HTC, also ensure /system is read-only using flash partition protections
(HTC calls this S-OFF). This means that even if /system is mounted read-write, any changes to it will
not be made persistent. As of KitKat, Google offers integrity checking for /system, using the Linux
kernel's dm-verity feature (discussed in Chapter 8).

The /system partition is (for the most part) the same on most devices. In a perfect world it
would be exactly identical, though in practice vendors and carriers sometimes add their own apps
and (rarely) directories, rather than in /vendor, which is the location designed for that. Table 2-7
shows the contents of the the /system partition you can expect on any Android device:

Table 2-7: The contents of the /system partition

Directory Notes

app
System applications: These include the prebundled apps from Google, as well as any
vendor or carrier-installed apps (though these should technically reside in /vendor/app,
instead).

bin
Binaries: These include the various daemons, as well as shell commands (mostly links 
to toolbox, or - as of M - toybox).

build.prop
Properties generated as part of the build process. This file is sourced by init to load
properties on boot

etc Miscellaneous configuration files. Symlinked from /etc. q.v. Table fs-etc for contents.

fonts True-Type Font (.ttf) files

framework
The Android frameworks. Frameworks are contained in .jar files, with their executable
dex files optimized alongside them in .odex.

lib
Runtime libraries - native ELF shared object (.so) files. This directory serves the same
role as /lib in vanilla Linux.

lost+found
Automatically generated directory for fsck operations on /system. Empty (unless the
filesystem crashed, in which case it may contain unlinked inodes)

media
Alarm, notification, ringtone and UI-effect audio files in .ogg format, and the system
boot animation (discussed in Chapter 5).

priv-app Privileged Applications

usr
Support files, such as unicode mappings (icudt511.dat), key layout files for keyboards
and devices, etc.

vendor
Vendor specific files, if any. Usually placed into subdirectories mirroring /system itself
(e.g. bin/, lib/, and media/).

xbin

Special purpose binaries, not needed for normal operation (unlike those in bin. On the
emulator, this is populated with various tools from the AOSPs /system/extras. On
devices, this directory is normally empty, or contains only dexdump. Various rooting
utilities drop "su" there as well.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#DiskVer


/system/bin

The /system/bin directory contains the native executables used by the Android, as well as a host
of debugging tools. Specifically, these binaries can be classified into the five categories:

Service binaries: Invoked by /init throughout the lifetime of the system. These binaries are
referenced in the rc files used by /init, and are required for system operation. Not all of these
are directly from the AOSP: Those marked in yellow are external projects.

Table 2-8: Service binaries in /system/bin

Binary Function

app_process[32/64]
Host process for Apps. Zygote (and all user apps) are instances of this binary, 
which initializes the DalvikVM/ART. On 64-bit devices both 32/64 are present.

applypatch[_static]
Used during OTA updates - applies patches according to scripts, as discussed
in Chapter 3. The _static binary is a statically linked version, used for updates
that would modify the dependencies of the normal (dynamically linked) binary.

bootanimation
Plays Android boot animation, while graphics subsystem (surfaceflinger) is
loading. Often customized by vendor.

clatd IPv4-to-IPv6 address translation

dalvikvm Starts an instance of the Dalvik Virtual Machine

debuggerd
Generates tombstones from process crashes, optionally connects to a remote
GDB

drmserver Host process for 3rd party Digital Rights Management (DRM) modules

dnsmasq
DNS Masquerade: Provides DNS proxying services when device is providing
tethering over Wi-Fi.

hostapd
Host Access Point Daemon: Provides access point emulation when device is
providing tethering over Wi-Fi.

keystore Android's key storage and management service

linker
Android's runtime linker. Not a service per se, but required for binary loading.
Messing with this is a surefire way to brick your device.

mdnsd Multicast DNS Daemon. Used for neighbor discovery over Wi-Fi Direct

mediaserver Audio/Video Recording/Playback

mtpd PPP/L2TP support

netd Manages network interfaces, firewalling and more.

pppd Point-to-Point Protocol Daemon. Required for VPNs

racoon Provides VPN support

rild Radio Interface Layer Daemon. In charge of all telephony services

sdcard
SDCard daemon. Manages SD-Cards so as to emulate multiple users via FUSE
(discussed later in this chapter).

sensorservice Sensor hub: coordiates reading from various sensors

servicemanager Service locator and fulcrum for all binder related services.

surfaceflinger Composes graphics surfaces and loads them onto the framebuffer

vold Volume Daemon: Mounts/unmounts filesystems, and optionally decrypts.

uncrypt Decrypts filesystem (for use before recovery)

wpa_supplicant
Wireless Protected Access Supplicant: Provides client support for Wi-Fi and Wi-
Fi P2P.

Services are described in reat detail in Chapter 5, in the context of their startup by /init.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

ate ee er M  ew daemon to handle authentication 

file:///Users/morpheus/Documents/Android/Book/Services.html


Debugging tools: These are native binaries left for debugging. The following list shows
those found in the emulator, though vendors (at their discretion) may decide to omit them
from production devices:

Table 2-9: Debugging tools in /system/bin

Binary Function

adb
Android Debugger Bridge (client) - this is essentially the same binary as the host

 (the server portion is in /sbin/adbd).

asanwrapper Address Sanitizer - Memory corruption detecting tool. 3rd party debugging tool

atrace Android tracing tool - uses Linux ftrace to debug and trace execution.

bdt BlueDroid (Bluetooth for Android) test app.

blkid Displays GUIDs of partitions

cjpeg JPG processing tool

dex2oat
DEX to ART conversion tool. Compiles the DEX file to device executable format.
Supersedes dexopt.

dexopt
DEX optimization tool. Creates device optimized DEX files (deprecated when using
ART)

dumpstate
Meta-tool combining several useful utilities (ps, dumpsys, etc) for capturing a
debug snapshot of system state.

dumpsys
Service dump utility: Connects to Android services and requests their Dump()
method, providing a plethora of debugging information.

e2fsck
fsck_msdos
fsck.f2fs

Ext2/3/4, VFAT and F2FS filesystem checkers. Run automatically by the system
before mounting filesystems.

gdbserver
GDB server tool. Used to connect GDB over TCP/IP from host in order to debug
processes. Omitted from most devices.

ip[6]tables Manage the kernel IPTables (firewall and network quota) from the command line.

keystore_cli Command line utility for interfacing with the keystore service

logcat
print the system logs (/dev/log/*) to stdout, with optional filters. This command is
so useful that it can be used directly as .

ndc Command line utility for interfacing with the Network Management Daemon (netd)

perf Extremely powerful profiling tool which uses the kernel's profiling support.

ping[6] Packet Internet Grouper (ICMP echo request/reply)

radiooptions Test utility for simulating Radio Interface Layer (RIL) events.

run-as Run an application under specific AID.

screencap Capture framebuffer to stdout or to a PNG file (used by ADB)

screenrecord Record movie (as .mp4) of device display

screenshot As screencap, with optional sound to play on screen shot.

service Command line utility for interfacing with the servicemanager.

toolbox Android's multi-call binary, as discussed above

vdc Command line utility for interfacing with the Volume Daemon (vold)

wpa_cli Command line utility for interfacing with wpa_supplicant

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



UN*X commands: left as a convenience for the shell user. The UN*X commands are� packaged 
into a single binary - /system/bin/toolbox (or, as of M, toybox). ither box is an Android specific 
version� of the busybox binary, which is an all-in-one-tool common in embedded systems*. Rather� 
than providing every single UN*X command, the  commands contain basic� implementations 
of those commands, and can emulate the commands based on their�ar ument (e. . toolbox ls ) 
or when invoked via a symbolic link (i.e. "ln -s /system/bin/toolbox /system/bin/ls"). The 

 and  provide a reduced subset of the�  commands*, including several 
Android specific commands (e.g. DQG ) . 

Dalvik upcall scripts: allow the shell user to interact with the Dalvik runtime frameworks,�
mostly for debugging. All these scripts (with the exception of uiautomator) are cut-paste�
from the same template, which calls on /system/bin/app_process to load the Dalvik class*�
from its containing framework JAR, and directly passHV any arguments to it. To see the�
template, it suffices to look at the "am" script, presented in Listing 2-1:

Listing 2-1: The script template for the Dalvik upcalls

Table 2-10 shows the scripts and their purpose. Invocation with no arguments will yield
a usage message.

Table 2-10: The app_process wrapper scripts in /system/bin

script Usage

am Interact with ActivityManager. Start activities, fire intents and much more.

bmgr Backup Manager Interface

bu Start backup

content Interface to Android's content providers

ime Control Input-Method-Editors

input Interact with InputManager, inject input events (discussed in Volume II).

media Control the current media client (play/pause/etc)

monkey Run an APK with randomly generated input events

pm Interact with PackageManager, list/install/remove packages, list permissions, etc.

requestsync Sync accounts

settings Get/set system settings

svc Control the power , data, wifi and USB services

uiautomator Performs UI Automation tests, dumps view hierarchy, etc.

wm Interact with WindowManager, change display size/density, etc.

* - It's a good idea to install busybox on Android, as most custom ROMs do - busybox contains far more tools than
toolbox does, making it indispensable for the power user. M's toybox is far better as well, providin  (at last) ore  
** - Starting the Dalvik VM by means of app_process from the shell, rather than forking off of Zygote (which is itself 
an instance of app_process) is considerably slower, as you can see for yourself by running any of the above scripts. 

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

sm M  Stora e Mana ement

appwid et L  rant/Revoke ser Application Wid ets

dpm M  Device Admin/Profile Mana ement



Vendor specific binaries: These naturally vary with vendor, but are generally either
services or debugging tools. Qualcomm provides a set of binaries which are common to msm
based devices, including the following: 

Table 2-11: Qualcomm specific binaries in /system/bin

binary Function

mm-qcamera-daemon Qualcomm built-in camera daemon.

mpdecision

Multi-Processor Decision: Proprietary tool to manage CPU frequency.
Interacts with CPU governor to increase frequency and/or activate cores
when system is busy, and decrease frequency and/or shutdown cores
when system is idle.

qmuxd Qualcomm baseband access multiplexer

qseecomd Qualcomm Secure Execution Environment Communicator

thermal-engine-hh Thermal Daemon, responsible for monitoring device temperature and
preventing overheating

In addition to the chipset vendor (Qualcomm, NVidia, OMAP, etc), there may or may not
be other binaries, provided by the handset vendor (HTC, Samsung, etc). As you'll see in a bit,
these non-AOSP binaries can and should be placed elsewhere - specifically, /vendor. But
whether or not to observe this convention is left up for the vendors to decide.

Vendor specific binaries are commonly closed source - and regrettably so: In many
cases, these binaries can profoundly impact system performance or security, and

may contain exploitable vulnerabilities. Qualcomm's  is a prime example of
such a case, as is HTC's  (which gave rise to the WeakSauce exploit, as
detailed on the book's companion website)5.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://newandroidbook.com/Articles/HTC.html


/system/xbin

The /system/xbin directory is akin to Unix's /sbin in the sense that it contains binaries which
administrators find useful, but normal users are probably better off staying away from. The "x" was
chosen rather than an "s" to avoid confusion with Android's own /sbin, which is part of the root
filesystem, and contains binaries critical to system operation.

Binaries in this directory are compiled from the AOSP's system/extras directory. Because this
directory is not strictly required for normal operation, it is left to the vendor's discretion as to what
to populate it with. Some vendors, in fact, choose not to populate it at all, or leave only dexdump.
Table 2-12 shows the contents of the extra tools found in the emulator.

Table 2-12: AOSP binaries found in the /system/xbin directory on the emulator

binary Function

add-property-tag Add properties to a system .prop file

check-lost+found Check lost+found directory after a fsck operation

cpueater Tight loop to consume 100% cpu

cpustats Display CPU and governor (frequency controller) statistics

daemonize Turn an executable into a daemon by running in background and closing
stdin/stdout/stderr

dexdump DEX file dumping tool. Provides header and bytecode dump

directiotest Test I/O over block devices

kexecload Overwrite kernel image with new kernel using  system call

ksminfo Kernel Same-page Merger information. KSM saves RAM by detecting (via a hash) 
duplicate virtual memory pages, and keeping only one physical page.  

latencytop Displays data from /proc/sys/kernel/latencytop in a more readable form

librank Display VSS/RSS/PSS/USS by shared memory region

memtrack Tracks process memory utilization (via /proc/pid/smaps)

micro_bench Memory benchmarking tool

nc Netcat, the swiss army knife of TCP and UDP.

netperf
netserver Network performance tool (client and server)

procmem Show process memory statistics (from /proc/pid/status)

procrank Complement to librank, providing VSS/RSS/PSS/USS usage statistics, but by process.

rawbu Low-level backup/restore of /data

sane_schedstat A human-readable form of scheduler statistics

showmap Display process memory map (/proc/pid/maps)

showslab Display kernel slab allocator information (/proc/slabinfo)

sqlite3 SQLite3 command line tool. Becuase so many content providers in Android are backed
by SQLite3, this is an indispensable tool for debugging and forensics.

strace System call tracer, using the Linux ptrace(2) system call. Unbelieveably powerful tool
for tracing and reverse engineering.

su Switch user (to root or other)

taskstats Provides detailed statistics using Linux's taskstats interface (if kernel supports it)

tcpdump Packet capture tool. Capture files can then be opened with Wireshark.

timeinfo Print realtime, uptime, awake percentage, and sleep percentage

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

iperf3 Handy profiling and benchmarking utility

perfprofd M: perf profiling daemon. Collects data to /data/misc/perfprofd



The precompiled binaries are exceptionally useful as debugging tools on a real device. Moving
them is a straightforward matter, as simple as using  into a directory on
the host, and then using  to the device (assuming a writable
/system). Nearly all binaries, however - both those in /system/xbin and /system/bin - require shared
libraries to work correctly. These, found in /system/lib, are discussed next.

/system/lib[64]

The /system/lib (and, on 64-bit devices, /system/lib64) directory contains the shared libraries
used by the binaries in /system/bin and /system/xbin (The previous chapter provided a cursory glance
at the various libraries). In most devices, /system/lib has several subdirectories. While some of these
are device dependent, common ones include:

drm/ (Providing DRM engines, such as libfwdlockengine.so, for forward-locking)

egl/ (For Android's OpenGLES implementation, discussed in Volume II)

hw/ (containing HAL modules, as discussed in the the previous chapter)

ssl/engines (containing libkeystore.so, which allows OpenSSL integration with Android Keystore
mechanism)

On Intel devices, /system/lib normally contains an additional subdirectory called arm/, which
contains copies of the same libraries, compiled for the ARM architecture. These are used by Intel's
binary translation layer - Houdini - to provide a full environment for any ARM binaries (commonly in
APKs which contain native libraries).

Nexus devices contain even more subdirectories, containing JNI libraries for various Google
services, such as Chrome/, Drive/, Wallet/, and others.

Nearly all of Android's binaries are dynamically linked. An exception to the rule are the binaries
in/sbin, which (following the traditional UN*X model) are meant to be used in instances wherein
/system (and therefore /system/lib) is not mounted. The following experiment demonstrates how you
can find precisely which libraries a given binary requires.

Experiment: Displaying the dependent binaries for a given library, or vice versa

One tool sorely lacking from the Android NDK is , which is used in Linux to show loader
dependencies. The Linux version of ldd actually simulates the loading of a binary, which is why it fails when
processing a binary on a machine of a different architecture. The  tool, found on the book's companion
website, will enable you to display the dependencies of an executable, similar to ldd(1), but also scan all
executables in a given path to see which depend on a given library.

As hinted previously, the tool can be quite useful when moving binaries between devices, or from the
emulator to the device. Many of the binaries in the emulator's /system/xbin are invaluable for debugging and
tracing on a real device. It's a fairly simple matter to move them from the emulator to device (when both use
the same version of Android), provided all the dependencies are met as well. For example,  and

, depend on . Using the  tool will show you this:

Output 2-7: Using the  utility

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Introduction.html
file:///Users/morpheus/Documents/Android/Book/Introduction.html#hal


/system/etc

Much like its UN*X namesake, Android's /system/etc contains miscellaneous configuration files -
et cetera. The directory is also symbolically linked to from /etc, to maintain compatibility with
external projects in AOSP, which expect to find their configuration there. Table 2-13 shows the
contents commonly found in this directory:

Table 2-13: Files and directories commonly found in /system/etc

Name Description

NOTICE.html.gz
Legal notices for the myriad open source components of Android, required for various
obscure licenses and legal reasons. As these aren't read frequently (or ever..) they are
put into one hyperlinked file and gzipped.

audio_effects.conf
audio_policy.conf

Used by the Android audio HAL (described in Volume II)

apns-conf.xml
Telephony provider configuration file, listing carriers supported by device (used by

)

asound.conf
On some devices, the Advanced Linux Sound Architecture (ALSA) configuration file for
the device

bluetooth/ The BlueDroid configuration files

clatd.conf Configuration file for CLATd (handles IPv4 over IPv6)

event-log-tags Log tags for various Android system components (used by )

fallback_fonts.xml
List of fallback fonts to load for families not specified in system_fonts.xml. Used by
Android's layoutlib's FontLoader.

gps.conf GPS configuration file

hosts Hosts map, containing localhost (127.0.0.1) for compatibility

media_codecs.xml StageFright's codec list (q.v. Volume II).

media_profiles.xml LibMedia's profile list (q.v. Volume II).

ppp/ Contains binaries for starting/stopping VPN and PPP connectivity

permissions/
XML files containing permissions for built-in apps (AOSP's and Vendor's). Used by the
PackageManager.

security/
Directory containing the device's hard coded certificate authorities (cacerts/), OTA
update certificates (otacerts.zip) and SELinux labels for signed APKs. Detailed in
Chapter 8.

system_fonts.xml
List of system fonts, organized by families and namesets, mapping font styles to TTF
files in /system/fonts. Used by Android's layoutlib's FontLoader.

wifi/
Configuration directory for WPA supplicant, controlling Wi-Fi and Wi-Fi P2P
Connectivity (see Volume II)

Depending on the device vendor (and, in particular, the chipset provider), /system/etc may hold
any number of additional files. Table 2-14 shows some files commonly found on Qualcomm devices
with the MSM chipset:

Table 2-14: Files in /system/etc on Qualcomm (MSM) devices

Name Description

*.acdb
Miscellaneous Audio Calibration DataBase files, used by libacdbloader.so on Qualcomm
devices

snd_msm/ ALSA files for Qualcomm MSM SoC sound device

thermal*.conf Configuration file for the thermald daemon, which monitors device temperature

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Security.html#KeyMgmt


/data

The /data partition is where all the user's personal data resides. Providing a separate partition
for this provides several important advantages:

/data is decoupled from the underlying Android OS version: System upgrade and recovery�
can thus wipe and rewrite the entire /system partition, without affecting the user's data in�
any way. Conversely, the device can quickly be reset and all personal data wiped by�
formatting /data, which is exactly what happens during a "factory reset".

/data may be encrypted, if the user requires it: Encryption, however efficient, adds a degree
of latency, since reading and writing involves decryption and encryption, respectively.
Because, by design, /system contains no sensitive information, there is no need to encrypt it,
and therefore this latency is avoided.

/data may also be made non-executable (i.e. mounted with the  option, or enforced
with SELinux). As of KitKat, this isn't a default option. Doing so, however, would not only
would make it more true to its name, but would greatly mitigating an attack vector for
malware, since the latter would have no writable partition that it can drop executables to.
This would not affect legitimate Dalvik/ART apps, because DEX and OAT run in a virtual
machine, but would likely impact rooting (for example, by requiring a remount, the same as
it does with /system).

The /data partition is mounted with , which makes rooting the device a bit more of a
cumbersome operation - assuming that root access is somehow obtained, the  binary (which
makes for an efficient, persistent backdoor) must be placed in /system, which is read-only. In
practice, this is only a minor obstacle, since it's a simple enough operation to remount /system in
read-write mode. Nonetheless, this is an example of defense-in-depth, and could actually prove
effective when /system is cryptographically hashed, as with KitKat's dm-verity (q.v. Chapter 8).

Table 2-15 shows the contents of the /data partition. Note vendors and carriers may place
additional files or directories.

Table 2-15:Directories under the /data partition

Directory Notes

anr
Used by  to record stack traces of non-responsive Android Apps. Stack traces
are recorded into , as per the  property.

app User-installed applications. Downloaded .apk files can be found here.

app-asec Application asec containers (described later in this chapter).

app-lib JNI libraries of applications (both system and user-installed) can be found here.

app-private
Provided for application private storage; In practice largely unused, since asec provides
better security.

backup Used by the backup service

bugreports
Used exclusively by  for generated reports, which include a text file and
screenshot (png), both named yyyy-mm-dd-hh-mm-ss

dalvik-cache

The optimized  of system and user applications. Each app's dex is
preceded by the path to its apk, with "@" replacing the path separator (e.g.

).

data Data directories for installed applications, in reverse DNS format. Discussed next

dontpanic Formerly used to store Android panic console and threads. Unused.

drm Used by Android's Digital Rights Management

local A readable/writable temporary directory for uid shell (usable in ADB sessions)

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

*

file:///Users/morpheus/Documents/Android/Book/Security.html
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#asec


Table 2-15 (cont):Directories under the /data partition

Directory Notes

media Used by the  service for mounted media

mediadrm Used by the Media DRM service

misc "Miscellaneous" data and configuration directories for components. q.v. Table 2-dm.

nfc Stores NFC parameters

property
Contains persistent properties (i.e. saved across device reboots). Each property is
saved in its own file, with the property name serving as the file name

resource-cache Resources cached by the AssetManager (described in Volume II).

security commonly empty

ssh For devices which provide the Secure Shell service. (Usually empty)

system A multitude of system configuration files, shown in table 2-18

tombstones
Application crash reports generated by debuggerd. Due to limited filesystem space, full
core dumps are not feasible. The debuggerd provides basic autopsy services in absence
of a core dump. Some vendors allocate a separate partition to this directory.

user
JB and later: provides "multi-user" capabilties, by symlinking user numbers (0,1..) to
directories with installed applications and data for those users. In a single user system,
0 links to /data/data.

The /data directory permissions, as well as those of /data/data (discussed
next) are both set to , and therein lies a tenet of

Android's security model: The directory is executable (i.e. -able) to all applications,
but unreadable (so applications or untrusted processes can't enumerate "neighbor"
directories). This means that, as uid  (in a non-rooted  session) you will be
able to change directory into /data and most of its subdirectories, but not necessarily
be able to read their contents. The system subdirectories (e.g. /data/system and
/data/misc will be readable, but /data/data and /data itself will refuse the 
command. This is also augmented as of KitKat by SELinux labels. You will therefore
need root access to traverse subdirectories freely.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

lost+found
Automatically generated directory for fsck operations on /data. Empty (unless the�
filesystem crashed, in which case it may contain unlinked inodes)

file:///Users/morpheus/Documents/Android/Book/FileSystems.html#t2-dm
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#f-datasys
file:///Users/morpheus/Documents/Android/Book/Services.html#Debuggerd


/data/data

The somewhat redundantly-named /data/data is the directory where all applications - both
system and user-installed - store their information. Each application gets its own subdirectory, in
reverse DNS format, which is  ( ), under the uid/gid of the owning
application. The /data/data directory itself is , which makes it
traversable by all applications, but readable to none but the system owned ones. The burden of
securing specific application files, however, rests on each and every application, as the per-app
directories are freely executable, though are unreadable by anyone other than the owner.

The /data/data per-app subdirectory is the only location in the entire filesystem which is writable
by apps. Coupled with the fact that the stock applications for location, texting and calls can be found
on every Android device, this makes several locations in it key for performing forensics.
Subdirectories of particular interest are shown in table 2-16:

Table 2-16: But a few of the app directories of interest in /data/data

App subdirectory Used by Contains
com.android.providers.calendar Calendar Calendar: databases/calendar.db (in the events table).

com.android.providers.contacts Phone
Contacts

Virtually every tidbit of information which might be of
remote interest on the device, in databases/contacts2.db: a
SQLite3 master contact database, including tables like
contacts (All contacts stored on the device) and calls (Log of
last calls). files/thumbnail_photo_xxxxx.png are individual
thumbnails of contacts.

com.android.providers.telephony Messaging Multimedia(MMS)/text(SMS) message database:
database/mmssms.db

com.android.providers.settings Settings databases/settings.db: All Android framework runtime
settings, and more in  and  tables.

com.google.android.apps.maps Google Maps Destinations looked up: gmm_myplaces.db, gmm_storage.db
and log_events.db. cache/http contains map tiles.

com.google.android.gm GMail

databases/mailstore.email.db: a SQLite3 database containing
all the user's mail which has been downloaded to the device,
for each registered email address (in the messages table).
Viewed attachments are stored in cache/email.

com.android.chrome Chrome
browser

State of Chrome browser (which replaces the old Android
built-in com.android.browser). Files of interest include the
cache/ directory (browser cache), and the
app_chrome/Default/ directory, which contains many
important SQLite3 databases, such as History and Archived
History (browsing history in urls table), Login Data (saved
credentials, in logins table) and Cookies.

Applications may also save data on the SD-Card (if they have permissions), but most of the
data pertinent to the application state can often be found in its /data/data directory. This is useful if
you want to manually save and rollback application state (for example, to cheat in most games).
Applications can also register with the Android backup service for automated backups - locally or to
Google's cloud services - as discussed in the next chapter.

Table 2-16 is naturally far from comprehensive. Nonetheless, if you're interested in finding
specific application files, it's fairly straightforward to look for the app in /data/data by the reverse
DNS notation (which matches the APK name). From there, it's a simple matter of grabbing the files
(on a rooted device), then using  on the various databases and  to identify and view
others. This is shown in the following experiment:

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Device forensics through /data/data

On a rooted device, you can easily examine application data directories with SQLite3. The Android emulator
image contains a  binary in /system/xbin, as do most rooting packages (for reasons which should now
be fairly obvious).

Taking as an example Chrome, start the browser and navigate to any site of your choice. To look at the
history database you will need to kill the process, since it holds a lock on the database. From there, a simple SQL
query reveals all.

Output 2-8: Examining Chrome's history with 

Demonstrating the same on the contacts2.db in /data/data/com.android.providers.contacts/databases:

Output 2-9: Examining the call log

Another useful forensic trick - which merely requires the device to be unlocked, and not necessarily rooted -
is to connect the device via adb to a host, and issue an  request for the packages of interest. This
calls on the the , which - by virtue of running as system - can access /data/data with
no restriction, and not only read all the files of any app, but also conveniently transport them to the host. (The
backup process and the  are both described in detail in the next chapter and Volume
II, respectively).

When initiating a backup, the  will prompt the user for confirmation (hence the
need for an unlocked device). If the operation is approved, a backup archive is created on the host with an .ab
(Android Backup) extension. Backups can be easily extracted on the host once you figure out the file format, as
explained in the next chapter.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Boot.html#backup
file:///Users/morpheus/Documents/Android/Book/Boot.html#backup


/data/misc

The /data/misc directory contains miscellaneous data and configuration directories for Android's
subsystems. Contrary to its name, the contents include some of the most important files in the
system. More detail can be found in Table 2-17:

Table 2-17: Directories in /data/misc

Directory Contents
adb Trusted ADB host public-keys (as of JB)

bluetooth BlueZ (< 4.2 bluetooth subsystem) configuration files

bluedroid Bluetooth subsystem (>4.2) configuration files

dhcp Contains PID file of dhcp ctdent daemon, and any active lease

keychain Android built-in certificate pins and blacklists

keystore Per-user keystore data

sensors Sensor debug data

sms Contains the sms codes database

systemkeys ASEC container keys (AppsOnSD.sks)

vpn VPN state configuration files

wifi Wi-fi subsystem configuration files (e.g. wpa_suppOLcant.conf), and sockets

/data/system

Another important subdirectory of /data is /data/system, as it contains files critical to maintaining
the state of device. As can be expected, access is restricted to system:system, so if your device is
not rooted, you can't see any of the files shown in table 2-18:

Table 2-18:: The contents of /data/system

Directory Notes

appops.xml Used by the AppOps service, which controls application permissions.

batterystats.bin Used by the BatteryStats service, which keeps power statistics by application.

called_pre_boots.dat Used by the ActivityManager to hold pre boot broadcast receivers

device_policies.xml Configuration file used by the DevicePolicyManagerService.

dropbox/ Directory used by the DropBox service.

entropy.dat System entropy store, used by EntropyMixer for random number generation.

gesture.key Lockscreen pattern, as discussed in Chapter 8.

framework_atlas.config Used by the AssetAtlasService, which packs bitmaps into a single file.

ifw/ Intent FireWall rulebase (q.v. Chapter 8).

locksettings.db* Lock screen settings: Contains device lock policy (q.v. Chapter 8).

netpolicy.xml Configuration file used by the NetworkPolicyManagerService.

netstats/
Directory used to hold NetworkStatsService statistics - by device, uid, or xt.
Previous versions of Android simply dropped the files in /data/system.

packages.list PackageManager lists of all packages (APKs) installed in the system

packages.xml Used by the PackageManager to hold metadata on all installed packages.

password.key Lockscreen PIN/password hash, as discussed in Chapter 8.

procstats/ Directory used to store files for the ProcessStats service

registered_services/ Directory used by android.content.pm.RegisteredServicesCache

usagestats/ Used to store files for the UsageStats service. In particular, usage-history.xml

users/ Android's "Multi-User" support. Described in more detail in Chapter 8.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

vold M:Contains decryption keys for "adopted" external storage drive

file:///Users/morpheus/Documents/Android/Book/Security.html#certs
file:///Users/morpheus/Documents/Android/Book/Connectivity.html#wpas
file:///Users/morpheus/Documents/Android/Book/Services-II.html#appops
file:///Users/morpheus/Documents/Android/Book/Services-II.html#batterystats
file:///Users/morpheus/Documents/Android/Book/Services-II.html#ActivityManager
file:///Users/morpheus/Documents/Android/Book/Services-II.html#dpms
file:///Users/morpheus/Documents/Android/Book/Services-II.html#dropbox
file:///Users/morpheus/Documents/Android/Book/Services-II.html#EntropyMixer
file:///Users/morpheus/Documents/Android/Book/Security.html#LockScreen
file:///Users/morpheus/Documents/Android/Book/Services-II.html#AssetAtlas
file:///Users/morpheus/Documents/Android/Book/Security.html#intentfw
file:///Users/morpheus/Documents/Android/Book/Security.html#LockScreen
file:///Users/morpheus/Documents/Android/Book/Services-II.html#npms
file:///Users/morpheus/Documents/Android/Book/Services-II.html#NetworkStatsService
file:///Users/morpheus/Documents/Android/Book/Anatomy.html#PackageManager
file:///Users/morpheus/Documents/Android/Book/Anatomy.html#PackageManager
file:///Users/morpheus/Documents/Android/Book/Security.html#LockScreen
file:///Users/morpheus/Documents/Android/Book/Services-II.html#procstats
file:///Users/morpheus/Documents/Android/Book/Services-II.html#3rdparty
file:///Users/morpheus/Documents/Android/Book/Services-II.html#usagestats
file:///Users/morpheus/Documents/Android/Book/Security.html#MultiUser


/cache

The /cache partitions is defined by Android for use during system upgrades. System updates are
downloaded to this location, and the boot manager is aware of this partition, especially when booted
in recovery/upgrade mode. Otherwise, the partition is normally empty.

If you've recently downloaded an OTA update, you will likely see it in the partition until it is
installed. Additionally, the recovery binary and the system (specifically, the

 class) make use of this partition to exchange information when
booting into recovery (or update), as shown in table 2-19:

Table fs-cache: Paths in the /cache partition

recovery #define Path Usage

CACHE_LOG_DIR /cache/recovery Directory used exclusively by recovery binary

LAST_LOG_FILE /cache/recovery/last_log Log of previous recovery/update operation

LOG_FILE /cache/recovery/log Log of current recovery/update operation

COMMAND_FILE /cache/recovery/command Command line arguments to the recovery

INTENT_FILE /cache/recovery/intent Intent to fire after recovery is complete

LAST_INSTALL_FILE /cache/recovery/last_install Log of last installation

LAST_LOCALE_FILE /cache/recovery/last_locale Language settings, for next boot

The recovery and update processes are both detailed in Chapter 3.

/vendor

The /vendor directory is purposed to contain vendor-specific modifications to Android. Doing so
allows for an efficient process of updating or upgrading of the OS when the need arises. Selected
system components are hard-coded to check /vendor before or in addition to /system paths, as
shown in table 2-20:

Table 2-20: /vendor paths searched by system components

Component Path searched

Package Manager /vendor/app

Fonts /vendor/etc/fallback_fonts.xml

Shared Libraries /vendor/lib

DRM libraries /vendor/lib/drm
/vendor/lib/mediadrm

eGL libraries /vendor/lib/egl

Frameworks /vendor/overlay/framework

Firmware /vendor/firmware

Audio Effects /vendor/etc/audio_effects.conf

The contents of /vendor greatly varies between devices, because vendors add their own apps
and components as they see fit. Some vendors, e.g. Amazon, create their own subdirectory
structure (/vendor/amazon) to include support for their custom frameworks and features (e.g. the
Kindle's "smart volume" feature, which adjusts audio volume based on CSV files for each output
device, placed in /vendor/amazon/smartvolume). Other vendors ignore this directory altogether and
just add their modifications to /system. This is especially common with vendor apps, and in practice
/vendor/app is often unused (even in the case of Amazon's FireOS), making it difficult to reduce the
bloatware of vendor and carrier supplied apps. If Android L on the Nexus 9 is any indication,
however, future versions of Android will have /vendor as a separate partition, which would allow it to
be updated independently of the rest of the system.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Boot.html#recovery


The SD card

One of Android's strongest features is its built-in support for SD Cards, a feature which is sorely
lacking for many users of iOS*. Most phones come built-in with an SD-card (albeit not an easily
removable one) and tablets have a readily accessible expansion slot.

Most SD-Cards are formatted with the vfat or fat32 filesystems, but those filesysystems do not
support permissions. In order to enforce permissions, as well as support multi-user configurations
(starting with JellyBean), Android resorts to a somewhat contrived method of emulating the sdcards
via FUSE (File systems in USEr mode). FUSE allows the implementation of filesystems in a user
mode process (hence the semi-acronym), rather than in the kernel. A small kernel-level shim
provides generic support, in the form of basic file system registration and interfaces to VFS, but the
actual implementation is delegated to a user mode process, /system/bin/sdcard. The mount point for
the SD card has changed several times over the course of Android's evolution, and is currently
/storage/ext_sd. On devices with no SD-Card, the mountpoint is often an emulated one, pointing to a
directory in the /data partition (usually /data/media/0). This is shown in output fs-sd, along with the
default directory structure:

Output 2-10: The SD-Card directories.

The standard directories are also defined as constants of the 
class. Note that 3rd party applications can (and often do) create their own files and directories in the
SD-Card.

Android provides an emulated SD Card file system on devices which do not have an SDCard, or
in addition to the "real" SD Card file system. You can see the SD Card file systems using the 
command:

Output 2-11: Viewing SD Card file systems

A follow up to discussion, focusing on the technical aspects of the  daemon can be
found in Chapter 5. 

* - Actually, iOS does support SD-Cards inherently, but the only way to add an SD-Card is to use the "Camera Connection
Kit", which is, in fact, little more than a USB host adapter in disguise. Of course, that requires the eager Applite to fork over
another $29.95 (or more), and use up the only slot on the device, which just so happens to be needed for power and USB
connectivity..

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://developer.android.com/reference/android/os/Environment.html
file:///Users/morpheus/Documents/Android/Book/Services.html#sdcard


Protected Filesystems

With Android being the open system that it is, come challenges to application deployment. A
technically savvy-user could use  to copy  bundles between devices, and even an average
user could do so, when the application is installed to an SD card, which is by its very nature
removable. Unlike iOS, who was designed from the ground up with support for DRM (using its
FairPlay mechanism, and encrypting application code by default), Android slowly adopted
mechanisms to achieve the same ends over its evolution. Two such mechanisms - Opaque Binary
Blobs (OBB) and Android Secure Storage (ASec) are covered in this section. The former grew out of
a need to bypass restrictions in APK, and the latter - with security in mind.

OBB - Opaque Binary Blobs

Google Play restricts the size of an APK to about 50MB. For some applications, this could be a
serious restriction, especially if they require or process multimedia files. With GingerBread, Android
brought support for the Opaque Binary Blob (obb) format. This allows developers to provide
additional data files (up to 2GB) to the applications, in the form of opaque binary blobs or obb
files, which can archive multiple files into a single blob, and provide optional encryption.

Implementation-wise, the obb is exactly that - opaque - meaning its contents and formatting
are up to the application developer to decide. Oftentimes, though, it is a vfat filesystem image,
which is mounted by a call to the volume daemon. The vold then calls on the Linux kernel's device
mapper to perform a loop mount. The device mapper also supports twofish encryption, and the key
is passed to it during the obb mount request. Applications can then call on the

's  method to mount the obb by specifying the key. This
is shown in figure 2-1:

Figure 2-1: The OBB mounting process

As opaque as they may be, Obb files still need to have some type of metadata to allow their
parsing by the system. Support for Obbs is provided in the native /system/lib/libandroidfw.so, and
inspecting its ObbFile.cpp implementation reveals the metadata is in a trailer (rather than a header,
as one would normally expect). Obbs are thus parsed by seeking to the end of the file, and working
backwards, uncovering the footer fields as shown in figure 2-2:

Application Code Application calls the StorageManager's mountObb(rawPath, Key, listener);

android.os.StorageManager The StorageManager connects to the system_server's MountService over Binder

system_server

(MountService)

Prepares a MountObbAction(obbState, key, callingUid) and executes as

"obb mount filename key callingUid" over vold connector (/dev/socket/vold)

/system/bin/vold

calls VolumeManager::mountObb(img, key, ownerGid)

Loop::create(idHash, asecFileName, loopDevice, sizeof(loopDevice))

Devmapper::create(idHash, loopDevice, key, nr_sec, dmDevice, sizeof(dmDevice)

Kernel Device mapper

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Kernel#dm


Figure 2-2: The Obb Trailer

Signature Version Version of package Obb belongs to

Package Version Version (currently only one version)

flags No flags are presently defined

64-bit Salt

Package Name Size strlen(Package Name) - Minimum 1

...
Package Name (at least 1 byte)

...

Footer Size Always 32 + strlen(Package Name)

kSignature0x01 0x05 0x99 0x83

The Android source tree contains the obbtool, which is a shell script that can be used to create
obb files on Linux - First creating an empty vfat image, then using the device mapper on the host to
loop mount. Once mounted, files can be added to it, and the image is then committed when
umounted. The SDK additionally provides the jobb6 utility to create and manipulate obbs. The
framework also provides the ObbScanner class, which can be used to obtain basic metadata about
obb files (using JNI calls to the aforementioned libandroidfw.so). OBBs are discussed in the Android
Documentation under APK Expansion Files7. You can interact with  through the  command
to list, mount and unmount obbs, as discussed in Chapter 5.

ASec - Android Secure Storage

Android's "Secure Storage" feature, commonly referred to as asec, provides a mechanism for
applications to securely deploy onto the device, while maintaining a reasonable level of assurance
that the user will not copy them to another device - a process often referred to as "forward-locking".
By using asec containers, an application can be deployed anywhere. The feature was added in
FroYo, which was the first version of Android to support external storage, such as SDCards. Indeed,
the containers may reside on SDCard, but are unusable without the key. Naturally, the keys need to
be stored somewhere, and Android maintains them in a system keystore (in
/data/system/misc/systemkeys). Hence, the "reasonable" level of assurance - the root user can read
the encryption keys.

Asec containers are, in essence, encrypted filesystem images which begin with a fixed header,
the , defined in system/vold/Asec.h as shown in figure 2-3:

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://developer.android.com/tools/help/jobb.html
http://developer.android.com/reference/android/content/res/ObbScanner.html
http://developer.android.com/google/play/expansion-files.html
file:///Users/morpheus/Documents/Android/Book/Services.html#4-voldc
http://newandroidbook.com/src/Android/KK/system/vold/Asec.h


Figure 2-3: The ASec header (from system/vold/Asec.h)

0xC0 0xDE 0xF0 0x0D Magic value (file signature)

1 Version (currently only one version)

c_cipher Encryption Algorithm: 0 - None, 1 - TwoFish, 2 - AES

c_chain Chaining (unused - currently only: 0 - None)

c_opts Options: 0 - None, 1 - Ext4

c_mode Mode (unused - currently only: 0 - None)

Asec creation and management is handled by the volume manager, vold, which performs
operations as instructed by the . Both asec creation and mounting require a key,
and when the asec container is mounted, vold uses the kernel's device mapper and performs a loop
mount, passing the key to the kernel's dm-crypt facility through a  ioctl.

You can use  to see asec mounts, with vold's command line,  (described in Chapter 5),
supplying detail as well:

Output 2-12: Viewing ASEC file systems

An age old challenge arising from encryption is key management - in other words - where does
one store the encryption key to the ASec containers? If the key itself is encrypted, one runs into a
chicken and egg problem. Android therefore chooses to place the (128-bit BlowFish) key in a single
file called /data/misc/systemkeys/AppsOnSD.sks. The file contains the key in simple plaintext, but is
set to be readable only by root. Naturally, this means on a rooted device relying on ASec as a form
of intellectual property protection is quite useless.

 For the reader interested in more hands-on experiments with asec containers, the
Android Explorations blog post about JB's App Encryption8 makes a great read.

If the asec feature seems similar to the OBBs that were just discussed, it is no conincidence: 
both features rely on the device mapper and its file encryption (dm-crypt) to both create and access 
the data. An asec can be seen as a logical progression of obb - from containing application 
extension files to encompassing the entire app. The same mechanism can be expanded to the full 
filesystem level, which is in fact what Android uses for its full disk encryption feature, described in 
Chapter 8. This has been expanded further in Android M's "adoptable" storage, enabling encryption 
of external USB storage through dm-crypt. 

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Services.html#vold
file:///Users/morpheus/Documents/Android/Book/Kernel#dm
file:///Users/morpheus/Documents/Android/Book/Services.html#4-voldc
http://nelenkov.blogspot.com/2012/07/using-app-encryption-in-jelly-bean.html
file:///Users/morpheus/Documents/Android/Book/Security.html#dataenc


The Linux seudo-Filesystems

While not strictly Android filesystems, the Linux kernel provides three other filesystems of note,
which are used by Android as well. These are especially important for our discussion in Chapter 7,
which discusses (among other things) the Linux perspective of apps - that is, tracing and analyzing
Android apps as the processes they are at the Linux level. This section is not meant to provide a
comprehensive reference to these directories ; Rather, it illustrates the particular paths which are of
interest to future discussion.

Note the term pseudo-filesystems: None of these filesystems are "real" in the sense of being
backed by actual storage. Instead, the filesystems are maintained directly by in-kernel callbacks, so
that upon access to a file or directory, a corresponding kernel-level handler function is invoked. This
means that these filesystems take no actual space (in-kernel memory for inode and dentry
representation not withstanding). Further, each access to a file or directory on a pseudo-filesystem
triggers the kernel callback function, so the files and directories always reflect the most up-to-date
data. As a corrolary, file sizes are meaningless, which is why an  will show the files as
seemingly empty (or with an arbitrary size of 4k, a pagesize, in older kernels). Note, that because
the files are exported by kernel code (kernel proper or, in some cases, modules, the files greatly
vary with kernel versions, and content (especially in sysfs) is highly hardware dependent.

Most pseudo-files created are read-only, and aim to provide real-time diagnostics, providing
user-space with a mechanism to poll on variables and structures which would otherwise be
inaccessible, in kernel mode. Some files, however, are actually writable, which provides an even
more useful ability to directly affect kernel data, in real-time, from user space. Contrary to certain
registry-based systems, wherein changes require excruciating manipulation of hidden and oft
undocumented keys or values (not to mention a reboot), changes made to files in the pseudo
filesystems - where allowed - are enforced immediately, but by default do not persist across a
system reboot. That, however, is seldom a concern, because it's a trivial matter to re-enforce these
changes during system startup, which is in fact what significant portions of the Android init.rc scripts
(detailed in Chapter 4) are all about. 

cgroupfs

The Linux kernel provides an important resource control mechanism called cgroups. A cgroup
is a  for one or more threads, allowing operations and policy settings to apply
on the group as a whole. A fairly comprehensive documentation on cgroups can be found in the
Linux kernel documentation9. To facilitate the placement of threads into groups, cgroups expose
themselves via pseudo file systems. It then becomes a simple matter to add a thread to a group by
"writing" into those files.

Though highly versatile and usable in oh so many ways, Android uses cgroups in a fairly limited
manner, requiring it only for cpu accounting, and thread scheduling.

Output 2-13: cgroup-related mounts on a Nexus 5

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#proc
file:///Users/morpheus/Documents/Android/Book/Services.html#rcfiles
https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt


Bionic sets up accounting for every process it starts (therefore applying to every process on the
system) through /acct. /sys/fs/cgroup/memory is accessed by the  (via�

 and its setSwappiness JNI method). Last, but not least, is the /dev/cpuctl
directory: despite being in /dev, this is a cgroup directory set up by Android's scheduling policy.�
When /init starts, it sets up the directory and creates subdirectories (therefore, scheduling groups)�
for system tasks (/dev/cpuctl/tasks, foreground apps (/dev/cpuctl/apps/tasks, and background apps�
(//dev/cpuctl/apps/bg_non_interactive/tasks). Each group is assigned a number of cpu "shares", and�
given an upper bound on execution time. This prevents any wayward or misbehaving DSp from�
impacting execution as a whole. The /dev/cpuctl configuration, performed in /init.rc, is shown in the�
following listing:

Listing 2-2: Setting up the cpuctl cgroups

debugfs

The debug filesystem is strictly intended for kernel-level debugging information. Drivers and
subsystems alike are free to dump droves of debugging information into the filesystem, which (as
with the other pseudo-filesystems). If the filesystem is mounted, the myriad debugging information
can be read like any other file.

Note, however, the "if" - The debug filesystem need not necessarily be mounted, and the kernel
could possibly be compiled without debugfs support. If the kernel supports it, the filesystem can be
mounted using a simple command line (usually in /init.hardware.rc), like so: 

though any mountpoint can be chosen. Since it's so useful, it's not uncommon to find a symbolic link
from the root, as is the default in the emulator image, from /d to the mount point.

The contents of the debugfs are highly dependent on the kernel version and whichever debug
features have been implemented in it. The following table lists common entries found in Android
kernels:

Table 2-21: Entries in the /sys/kernel/debug directory

Entry Purpose
binder plentiful data on the eponymous Android IPC mechanism

tracing unbelievably useful, copious debugging and tracing information generated by the Linux
kernel's  mechanism

wakeup-sources Kernel level wakelocks, used by drivers or the Android system to prevent device sleep

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV



functionfs (/dev/usb-ffs/adb)

USB functionality in Android is controlled by a special "gadget" driver, which often requires
dynamic reconfiguring according to user-selection (e.g. connect device for USB debugging, as Mass-
Storage, etc) through init (as explained in Chapter 4).

The traditional driver (in kernels before L) needs to export its reconfiguration parameters
through sysfs. Doing so is one of the reasons it is considered bloated, and in need of revamping.

Enter: functionfs. A relatively new addition to the Linux kernel (sometime in 2010), this is a
generic file system provided by the Linux kernel to provide a way for drivers to pick up configuration
changes from user space. The filesystem can be thought of a complement to sysfs, in that whereas
the latter is designed for outputting kernel variables and driver information to user mode, the former
is designed for input. The root user can use  to create directories, which in turn will
create corresponding kernel objects, which can then be initialized from user-space by further
write(2) operations to the pseudo-files in the directories.

procfs (/proc)

The procfs filesystem derives its name from its initial purpose - to provide a directory-based
view of processes running in the system. The idea originated in Plan 9 operating system, and Linux
quickly adopted it and modified it to provide a plethora of information - on processes, threads, and
other system-wide diagnostics. In fact, some argue that /proc has become a virtual junkyard of
diagnostic files, because Linux originally provided pseudo-file interfaces for this directory only.

Regardless of whether or not /proc provides too much of a good thing, it is undeniable that it
makes for a highly important filesystem. Many Linux utilities (e.g. top, netstat, lsof and ifconfig), as
well as Android tools (e.g. procrank, librank) depend on it as the source of diagnostic
information.Linux keeps a fairly detailed and updated man page for . We discuss the usage
of procfs for debugging in Chapter 7.

pstore (/sys/fs/pstore)

The  mechanism is a Linux kernel feature (introduced in 3.5) which allows the kernel to
set aside some RAM as a persistent store. This is used for one purpose - capture kernel panic
data.

A panic indicates an internal kernel memory corruption, which may affect the filesystem logic.
As such, any write to the filesystem could worsen things, and lead to filesystem corruption, as well.
Normally, UN*X system dump panic data to the swap partition - which isn't meant to survive reboot
anyway. But Android has no swap, and therefore the only reliable solution is to set aside some
physical memory (i.e. a dedicated portion of the RAM), and have the kernel log its crash data (the
bare minimum, at least) to there. The kernel then automatically performs a warm reboot - that is, a
reboot without a power cycle, which means that the RAM does not undergo full re-initialization.
During reboot, the kernel checks the persistent store for any relics of its past incarnation - and , if
any are found, they are made available through /sys/fs/pstore.

In older versions of Android, this functionality was provided by an "Androidism" (i.e. specific
Android kernel hack) called the RAM console. Traces of this can still be found in /init.rc files,
capturing data from /proc/apanic_console and /proc/apanic_threads, and moving them to
/data/dontpanic (with a wink to the "Hitchhiker's Guide to the Galaxy"). With the advent of the pstore
functionality, this is deprecated in favor of /sys/fs/pstore.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Init.html#initusb
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#


selinuxfs (/sys/fs/selinux)

The SELinuxFS, like the debugfs, is traditionally mounted under /sys but is not part of the sysfs
filesystem per se. The filesystem has been devised for exclusive use by SELinux, and it stores
important files relating to the installed policy.

SELinux is discussed in more detail in Chapter 8, but at a bird's eye view, the most important
files in this filesystem are policy - which provides the loaded (compiled, binary form) security policy,
and the enable pseudo file, which toggles enforcement of the policy (and is in fact what the

/   tools use).

Output 2-15: Demonstrating enforcement of an SELinux policy

Experiment: Testing the persistent store on Android L

On an Android L (or any system with a kernel version of 3.10 or later) it is very likely that the pstore is
enabled by default. To see if it is, check for the existence of /sys/fs/pstore or any other mount point specifying
the  file system:

Output 2-14: Locating the pstore

If your kernel rebooted and/or crashed recently, the mount point will be populated with a single file:
console-ramoops, which holds the last  output. The file's permissions -  are set in the /init.rc,
and make it readable by the  (which is a member of the  group). You can then 

 to get the last output of the kernel ring buffer, right up to the reboot.

If you cold booted your system, however, the directory may be empty. In this case, you can either reboot
your system using , or (if you dare), force a kernel crash using the command:

which will make the file appear.

The /proc/sysrq-trigger pseudo-file is an incredibly useful (but dangerous) /proc entry. The file
is writable only, and ing a single key into it simulates the functionality of pressing the

little known  key along with ALT and the key specified - a magic key combination which
works only from the console. The  functionality is meant as an emergency channel when
the system is non-responsive, since  requests are processed by the keyboard interrupt
handler (which runs at the highest possible priority). Exercise extreme caution when handling this
file, as most of the options there are for emergency use only and may be destructive.

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

file:///Users/morpheus/Documents/Android/Book/Security.html


sysfs (/sys)

The sysfs may be alphabetically last, but in order of importance it is second only to procfs. The
sysfs was introduced in kernel 2.6 as a complement to procfs - In an effort to declutter /proc, and
move hardware and module related configuration files to a separate location, with more structure.

Under /sys you can find, therefore, a "cleaner" separation of pseudofiles, by category. The
subdirectories you'll see are shown in Table 2-22:

Table 2-22: The subdirectories (classes) in /sys

Subdirectory Contents

block
Block I/O Layer control files. One subdirectory per block device, containing
parameters such as the I/O scheduler.

bus Devices, by bus connection. One subdirectory per bus type (e.g. i2c/, mmc/, soc/)

class Devices, by class. One directory per class type (e.g. input/, sound/).

dev Devices, by device type: block/ or char/

devices Devices, in device-tree compatible form

firmware Used for firmware-update capable devices

fs
Used by filesystem drivers. Some subdirectories here are mountpoints (e.g. pstore/,
selinux/ are mount points for other pseudo-filesystems, as previously discussed.
Others provide exported parameters and statistics by filesystems (such as ext4/).

kernel
Various kernel parameters, by subsystem. debug/ serves as mount point for
debugfs

module
One subdirectory per module, containing module statistics and (where applicable)
module parameters (viewable and sometimes settable from user-space)

power
Power management statistics and settings. The Android WakeLocks are
implemented here (via the wake_lock and wake_unlock pseudo-files)

Hardware configurations greatly differ in-between devices - and therefore so do the actual
contents presented by the corresponding sysfs files. The Android frameworks are shielded from
device-specific idiosyncrasies thanks to the Hardware Abstraction Layer (/system/lib/libhardware.so
and its plugins), which wrap the calls to the specific files with more generic API calls (The HAL is
discussed in more detail in Volume II).

Other device entrLHV are somewhat more standardized. These include the CPU governor (frequency�
scaling) data, in /sys/devices/system/cpu/cpu#/cpufreq, and the vibrator (on devices which have one)�
in /sys/class/timed_output/vibrator. For a quick, fun experiment, you might want to try to echo a large�
value (say, 5000) to the enable sysfs entry in that directory.

Summary

This chapter provided a walkthrough of Android's partitions and filesystems. In particular, we
focused on the partitions commonly found in Android devices - noting all but a few are actually
unmountable. We then examined the two main filesystems - /system and /data, whose contents,
subdirectory by subdirectory, were detailed. Lastly, the chapter touched on the Linux pseudo-
filesystems, which contain a cornocupia of diagnostics and configuration files. Those files, with an
emphasis on their use in debugging, will be revisited throughout this book, especially in Chapter 7.

The next chapter builds on this one, as it explores Android's boot and recovery processes. The
non mountable partitions - and in particular aboot and boot will be examined in detail, as they play
the part in starting up the device. The mountable but rarely used /cache will be revealed as central
to OTA-updates.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/LinuxLens.html


References

1. XDA Developers on f2fs: http://forum.xda-developers.com/showthread.php?t=2697069

2. Samsung f2fs presentation: http://elinux.org/images/1/12/Elc2013_Hwang.pdf

3. Linux Weekly News on f2fs: http://lwn.net/Articles/518988/

4. XDA Developers "El Grande Partition Table Reference": http://forum.xda-
developers.com/showthread.php?t=1959445

5. Companion Article: HTC WeakSauce Exploit: http://NewAndroidBook.com/Articles/HTC.html

6. Android Developer on the jobb utility: http://developer.android.com/tools/help/jobb.html

7. Android Developer on APK Expansion
Files:http://developer.android.com/google/play/expansion-files.html

8. Android Explorations on JB App Encryption: http://nelenkov.blogspot.com/2012/07/using-
app-encryption-in-jelly-bean.html

9. Linux kernel documentation on CGroups:
https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt (or the kernel sources)

��

&KDSWHU�,,��3DUWLWLRQV�	�)LOH6\VWHPV

http://forum.xda-developers.com/showthread.php?t=2697069
http://elinux.org/images/1/12/Elc2013_Hwang.pdf
http://lwn.net/Articles/518988/
http://forum.xda-developers.com/showthread.php?t=1959445
http://newandroidbook.com/Articles/HTC.html
http://developer.android.com/tools/help/jobb.html
http://developer.android.com/google/play/expansion-files.html
http://nelenkov.blogspot.com/2012/07/using-app-encryption-in-jelly-bean.html
https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt


��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



III: Android Boot, Backup & Recovery

Just like with their desktop counterparts, most users take the boot process of their mobile
device for granted. They power on the device, wait for a few seconds, and the home (or lock)
screen appears to greet them. The only time this sequence changes is in cases where the device is
being updated ("flashed"), hasn't enough battery charge, or - in those rare cases where boot fails,
and users find their device "bricked".

While the boot process of mobile devices follows the general lines of desktops, it is invariably
more complicated, and involves more parts. Add to that the myriad device types and vendors in the
Android landscape, and you get a process that is quite lengthy, and quite idiosyncratic for each
device and vendor. This chapter aims to document this process, and focus on the common
denominators between devices.

We begin with an examination of Android software images - which are flashed to the device
partitions we discussed in the previous chapter. These can be manually downloaded, but are often
fetched by the device in an Over-The-Air (OTA) update. While vendors are free in creating and
formatting the images, most follow a general structure, consisting of the boot loader, the the boot
image (containing the kernel and the RAM disk), and the sparse system images - which we discuss
in turn. We follow these components as they each play their role in the boot and/or recovery
process.

After discussing the boot process, it makes sense to discuss its inverse - shutdown. While at the
Linux level shutdown and reboot are simple matters (handled by a kernel system call), Android's
handling is more intricate, accommodating for Androidisms such as presenting the power menu, and
booting into recovery mode.

The discussion of booting to recovery, begs more detail about just how recovery is performed,
as well as the process of applying updates - so the next section is where OTA update packages and
process are described.

Lastly, we consider custom firware images - "ROMs", as they are often (erroneously*) referred
to, and discuss how the key components can be upgraded or entirely replaced. We leave out the
natural sequitur to this discussion - device rooting techniques - for Chapter 8, which deals with
security aspects of Android.

This chapter makes use of , a utility for viewing and unpacking Android system
images. For your convenience, both source and a precompiled binary are freely available for
download in one package1.

* - Technically, ROM implies Read-Only-Memory, which cannot be updated or (in the case of EEPROM) can be erased and
rewritten under special circumstances. Android devices do have a true boot ROM component, but the rest of the boot
process is performed from flash partitions, which can be easily written to (assuming permissions hold).

��

file:///Users/morpheus/Documents/Android/Book/Boot.html#Images
file:///Users/morpheus/Documents/Android/Book/bootldr
file:///Users/morpheus/Documents/Android/Book/bootimg
file:///Users/morpheus/Documents/Android/Book/Boot.html#kernel
file:///Users/morpheus/Documents/Android/Book/Boot.html#ramdisk
file:///Users/morpheus/Documents/Android/Book/Boot.html#simg
file:///Users/morpheus/Documents/Android/Book/Boot.html#rebooting
file:///Users/morpheus/Documents/Android/Book/Boot.html#OTA
file:///Users/morpheus/Documents/Android/Book/Boot.html#otaprocess
file:///Users/morpheus/Documents/Android/Book/Boot.html#customizing
file:///Users/morpheus/Documents/Android/Book/Security.html#Rooting.html
http://newandroidbook.com/files/imgtool.tar


Android Images

Various Android devices each have their own specific images. These are the system images,
provided by the vendor, which are meant to be flashed as the "factory default" distribution of
Android onto the device. The images are comprised of several files, which are flashed into their
respective partitions:

The Boot Loader: which provides the application processor bootstrap code. This code is
normally responsible for finding and loading the boot image, but also handles firmware
updates, and booting into recovery mode. Most bootloaders also implement a small USB
stack, over which they can communicate with the host for purposes of controlling the boot or
update process (normally over fastboot). The boot loader usually gets flashed into the aboot
partition, though on some devices (e.g. HTC) this may be called "hboot".

The Boot Image: which normally consists of the kernel and a RAM disk, and is used to load
the system. Assuming normal boot, the RAM disk will serve as the root filesystem for
Android, and its /init.rc and related files will provide directives as to how to load the rest of
the system partitions. The boot image is flashed into the boot partition.

The Recovery image: similarly consisting of the kernel and a (different) RAM disk, and is
used to load the system into "Recovery mode", in cases where normal boot has failed, or in
case of an OTA update. This gets flashed into the recovery partition.

The System Partition: which is the full Android system, including the Google supplied
binaries and frameworks, as well as any provided by the vendor, and/or the carrier.

The Data Partition: containing the "factory default" data files, which support the binaries in
the system partition. This image also provides the "factory default" state to which the device
is restored when effaced.

Google makes the system images for the Nexus devices available at their factory image
repository2. You are encouraged to follow along with the hands-on experiments in this chapter with
those images, or your own device, if rooted. Refer to the method in Chapter 2 for safely extracting
the images from the raw partitions of a live device. To unpack a Google stock image, follow these
steps:

Download the image from Google's factory images repository. This will be a gzipped tar file,
with a name in the following convention:

piscine_devicename-build-factory-first_32_bits_of_SHA1_checksum.tgz

Unpack the file using tar: this will look something like the following Output:

Output 3-1: Unpacking a factory image for a Nexus 5

Next, we discuss each of these components (with the exception of the radio/baseband) in turn.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

https://developers.google.com/android/nexus/images
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#showGPT


The Boot Loader

Android vendors are free to implement their own boot loaders, though most (Samsung being a
notable exception) choose the "LK" (Little Kernel) Bootloader. The LK Bootloader is not part of the
Android source tree, but is available (at least in part) from CodeAurora3a and from googlesource3b.

LK as, as its name implies, a minimal implementation of boot functionality. The name is
somewhat misleading, however, as it is not a Linux kernel, but a bootable ARM binary image. LK
concerns itself with only the minimal functions one expects from a boot loader. These include:

Basic hardware support: provided by LK's dev/ (basic common drivers, such as
framebuffer, buttons, and USB target), platform/ (SoC/chipset drivers) and target/ (device
specific) subtrees. Without this, none of the other requirements can be sated.

Finding and booting the kernel: The raison d'etre of any boot loader, locating the
bootimg (discussed next), and parsing its components - kernel image, ramdisk and device
tree - then transferring control to the kernel with a given command line. This is carried out
by app/aboot.

Basic UI: for cases wherein the user interrupts the normal automatic boot sequence
(commonly via  or pressing button combinations immediately
after device power on). Aboot provides a simple text interface, which the user can navigate
using the physical buttons on the device - using volume up/down to navigate, and the power
button to select - but no touchscreen functionality.

Console support: though most retail devices have no readily available console*,
development boards provide console functionality through serial ports (RS232/UART). LK's
lib/console (called from app/shell) provides a command interpreter (running in a separate
thread) and support for extending the command list. lib/gfxconsole provides rudimentary
graphics functions, such as font support.

USB Target Support: which allows the bootloader to communicate with its host via a
simple protocol, called fastboot, and discussed later in this chapter. A skeleton
implementation can be found in app/aboot/fastboot.c, with vendors free to add their own
extension ("oem") commands.

Flash partition support: in order to enable the bootloader to erase or overwrite partitions,
as required during upgrade or recovery. LK also contains basic filesystem support, through
lib/fs.

Digital Signature Support: to provide support for loading digitally signed images with SSL
certificates, LK incorporates portions of the OpenSSL project in its lib/openssl subtree.

* - Surprisingly, it is possible to get a console connection to some devices, for example Google's Nexi, through one of the
last places one would suspect - the headphone port! There is ample documentation on how to build your own headphone-
jack-to-RS232, for the Nexus 44a and Nexus94b.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

https://www.codeaurora.org/cgit/quic/la/kernel/lk/tree/app/aboot
https://android.googlesource.com/kernel/lk/+/a9b07bbae16a0b1b6de07ec3a3e2005c99043757/
file:///Users/morpheus/Documents/Android/Book/Boot.html#fastboot
http://www.accuvant.com/blog/building-a-nexus-4-uart-debug-cable
http://osdevnotes.blogspot.com/2014/11/64-bit-arm-oskernelsystems-development.html


The Boot Loader Image

Boot Loaders can EH�updated and flashed, just like other System Images. Though the format is 
not�officially documented, the releasetools.py script in some of the device-specific directories of the
Android source tree provides the header format. This enables  to parse and extract boot
images, as shown in this output, examining Google's Nexus 5 boot loader:

Output 3-2: The Nexus 5 Boot Loader Image

As you can see in the output, the Boot Loader image is comprised of several sub-images, each
of which is meant to be flashed to a specific partition. The boot loader itself is in "aboot", which is
the Application Processor Boot loader. The image also contains the Resource Power Management
bootstrap (rpm), ARM TrustZone image (tz), and secondary boot loader (sbl1) (discussed later in
this chapter).

None of the file formats of the boot loader components are documented. These are all highly
architecture dependent, and the ones in the example above pertain to Qualcomm's SnapDragon
processor (the msm chipset). The focus of this discussion - aboot - is incorrectly recognized by

 as an Hitachi SH big-endian COFF object, when in fact, it is formatted with a proprietary
header, spanning 40 (or, in some cases more) bytes. The header format is shown in Table 3-1:

Table 3-1: The aboot proprietary header

Offset Field Contains
0x00 Magic 0x00000005 (constant)

0x04 Version Version # (2 or 3)

0x08 ? NULL field

0x0c Image Base Virtual memory address to load rest of image into

0x10 Image Size Size of aboot image

0x14 Code Size Size of aboot code size

0x18 Last Code Addr Image Base + Code Size

0x1C Signature Size Size of digital signature (usually 0x100 = 256 bytes)

0x20 Last Mapped Addr Last Code Addr + Signature Size

0x24 Certificate Chain Size of Certificate Chain, if any

Following the header is an ARM bootable image, which is mapped into memory at the address
specified by the header. At its very base are the ARM exception vectors. These are a series of
branch instructions, which define what addresses the processor will automatically jump to in certain
cases (e.g. interrupts, exceptions, and aborts). The very first of those instructions - the reset
handler - defines LK's entry point. The following experiment shows how you can remove the aboot
header:

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Boot.html#firmwareBoot


Experiment: Removing the header from the aboot image

If you have a Nexus 5 ROM update, using  on its bootloader.img (as shown in Output
3-2) will extract aboot. Otherwise, on a rooted device you can obtain a partition dump by the
method shown in Chapter 2, substituting /dev/mmbclk0 in that example with the partition of aboot
(likely /dev/block/mmcblk0p6). One way or another, you will end up with aboot as a file.

Output 3-3: Making sense of aboot using 

The ARM instructions can be recognized by the "eaXXXXXX" form: "ea" is the opcode for the
ARM B(ranch) instruction. Exception vectors in ARMv7 contain seven 32-bit slots, so the reset
handler is usually instruction is usually ea000006 (as above): 6 * 4 bytes away from next
instruction.

If you cut off the first 40 bytes of the file (using ), the resulting file can
be loaded into a disassembler fairly easily. Cut again after CodeSize bytes, to remove the signature
and the certificates, which should yield files that match the values of the header, namely:

Output 3-4: Getting the certificates from a bootloader image

You will need to rebase the image to 0x0f900000 (or whatever the field at offset 12 states).
Reverse engineering of the boot loader is outside the scope of this chapter, but can be found in a
companion article on the book's web site5.

Boot loader locking

The boot loader on Android devices is usually locked, meaning it will refuse to flash or boot
updates which are not digitially signed. The vendor provides its public key in ROM, and the key can
be used to establish a chain of trust throughout the boot process. This way, all boot components -
from the rpm through the sbl to the Android boot loader - can be verified. Reverse engineering of
those components often reveals they contain an X.509v3 certificate, as well as the OpenSSL support
needed to verify keys.

Boot loader locks are not to be confused with SIM Locks, which carriers often enforce to ensure�
that a phone purchased from them will only operate on their network. Rules in several countries�
already require carriers to unlock devices in certain cases, but no such rules force the sale of�devices 
with unlocked boot loaders.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

file:///Users/morpheus/Documents/Android/Book/FileSystems.html#showGPT
http://newandroidbook.com/Articles/aboot.html


Thus, depending on the vendor, a user may or may not be able to unlock the phone. Some
vendors refuse to do so, whereas in others (e.g. Google's Nexus 5 and the NVidia Shield) it's a
simple a matter as issuing a "fastboot oem unlock" command. This is shown in Output 3-5, below:

Output 3-5: Unlocking the NVidia Shield Bootloader

Other vendors (like HTC) take a middle ground, and have the device issue a challenge, in the
form of a cryptographic token which must be responded to with a specific response. Some vendors
sell both locked and unlocked phones (Samsung being the notable example). As of L, (at least in the
Nexus 9), Android's default setting app allows the user to select whether or not the device is
unlockable through Settings >> Developer Options. The user choice toggles a bit in a partition
also readable by the bootloader.

Unlocking the bootloader, whenever possible, mandates that the boot loader entirely efface the
/data partition. This is because unlocking the bootloader entirely compromises the device's security:
An adversary gaining possession of the device can flash an update which will bypass any user PIN or
pattern, or just copy the /data partition, and steal all the personal information found there.

If the boot loader cannot be unlocked, however, then the device - in theory - should be secure
with no rooting method. In practice, however, Android is not without its share of exploits. As a
matter of fact, at the time of writing a Linux kernel exploit which plagues versions below 3.13 has
given rise to a root exploit, first publicized by GeoHot, known as "TowelRoot", which affects all
Android devices on the market. This is but one of several exploits, commonly referred to as "one-
click", which are akin to JailBreaking on iOS. These exploits, as well as rooting in general, are
discussed in Chapter 21.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#oneclick


Boot Images

Android's boot images contain the core components of the operating system - the kernel and
the RAM disk. The boot images (created with , in the Android source tree), bundle both
with a minimal header, the kernel command line, a small hash, and an optional second stage boot
loader (which in practice is unused). The images are recognizable by their magic ( ),
similar to the bootloader magic ( ) discussed earlier.

 Vendors are not strictly required to use this boot image format in their devices, and so
results might vary with device. HTC, for example, prepends its own header, likely for use by
their custom boot loader, HBOOT. You can usually spot the boot image header thanks to its
magic value - , like so:

Output 3-6:The HTC boot image header

And then use dd to skip the custom header (in the example above, dd bs=0x100 skip=1)

The format of the boot image is well documented in bootimg.h, as shown in listing 3-1:

Listing 3-1: The boot_img_hdr

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



The Kernel

The Linux kernel, unlike most OS kernels, is mostly compressed: The kernel file format, known
as a , consists of self-extracting code, which unpacks the rest of the kernel image in
memory. As compression algorithms have greatly advanced, there are multiple options for
compression, which can be decided during the build process (make config), as shown in Table 3-2:

Table 3-2: Kernel file formats

Magic Compression Notes

\x1f\x8b\x08\x00\x00\x00\x00\x00 GZip Most common compression format

\x89LZOx00\x0d\x0a\x1a\x0a LZO Faster, but 10-15% less efficient than GZip.
Used by Samsung

The kernel always starts with the self-extracting code portion, which means one has to scan
well into the file in order to find the compression magic. Most ARM kernels traditionally use zImage,
though there is no strict requirement to do so. The  utility will automatically uncompress
both GZip and LZO kernel images (if requested) and provide you with a binary you can disassemble
or search strings in. When loading into a disassembler, you'll need to rebase the image at

 (assuming 32-bit).

The kernel is the most architecture specific component of Android: Whereas other components
only care about the processor type (i.e. ARM, Intel, or MIPS), the kernel is also concerned with the
board type and specific chipsets, because the processor is, in effect, a system-on-chip (SoC), which
also contains additional components, for which specific drivers will be required. Those drivers are
part of the source tree, and Google actually provides several kernel trees, for the chipsets shown in
Table 3-3:

Table 3-3: Chipsets Devices, and board names for Google devices

Project Name Chipset vendor Devices (board names)

goldfish (M Ranchu) N/A Android emulator

msm Qualcomm MSM Nexus One, Nexus 4, Nexus 5 (hammerhead)

omap TI OMAP Pandaboard, Galaxy Nexus, Glass (notle)

samsung Samsung Hummingbird Nexus S

tegra NVidia Tegra Motorola Xoom, Nexus 7 & 9, NVidia Shield

exynos Samsung Exynos Nexus 10 (manta)

Google's devices are commonly known by their piscine board project name, and their kernel
binaries are available via git at  subtrees. The
kernel sources (which naturally must remain open) can similarly be obtained via  using 

platform_project

as described further in Android Documentation6. Aside from Table 3-3, a good way of figuring out
which branch a device's kernel is derived from is by looking at its strings and symbols.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://source.android.com/source/building-kernels.html


The Device Tree (ARM)

Most ARM kernels also rely on the presence of a device tree file to provide the kernel with the
hardware device definitions. This file provides a hierarchical view of devices by connection, and
enables the kernel to boot the approriate drivers for them. The device tree is commonly appended
to the end of the kernel image, but may at times reside in a separate partition.

The device tree format is a binary blob, identified by the magic value . A complete
discussion of the device tree is beyond the scope of this book (it is an ARM feature, and not specific
to Android). The format is well documented in the ePAPR specification7, and a presentation by
Thomas Pettazoni8. You can use the  utility to extract the device tree from your kernel
image. This is shown in the following experiment

Experiment: Retrieving the device tree from a boot.img

The , in addition to unpacking a boot.img and extracting its kernel and ramdisk, will
also automatically extract the device tree component of the kernel image, if found. The extracted
file, however, is in a binary format (.dtb, identifiable by its magic header of ). To
decompile the device tree, you will need to use the  utility, which is part of the 

 package on Ubuntu, or  package on Fedora. Once installed, it's a simple
matter to decompile the file and obtain the textual .dts file:

Output 3-7: Extracting and decompiling a device tree from the Nexus 5 boot.img

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

https://www.power.org/wp-content/uploads/2012/06/Power_ePAPR_APPROVED_v1.1.pdf
http://elinux.org/images/a/a3/Elce2013-petazzoni-devicetree-for-dummies.pdf


The RAM disk

The second component of the boot or recovery image is the initial RAM disk, often referred to as
the initrd. The RAM disk provides an initial filesystem, used as the rootfs when booting up the OS.
It's pre-loaded by the bootloader into RAM alongside the kernel (hence the name), and enables
quick access, without any special drivers. This is not a Linux specific feature - other UN*X have also
been known to use it, most notably iOS (wherein it is contained in the .ipsw system image,
alongside the kernelcache).

Traditionally, the initramfs is often used to provide device-specific drivers, which the kernel
requires for operation. This enables the Linux distributer to provide a generic, relatively compact
kernel, and package the necessary drivers (which vary between hardware configurations) into a
separate file, created during the initial install process. To get around the chicken-and-egg case
wherein drivers are required for storage access, critical ones are packaged into the initramfs, which
the kernel can then access directly in RAM. It also contains the startup program (/init), which the
kernel loads as PID 1, enabling early startup operations which require user mode (for example,
loading modules).

Once the RAM Disk operation is done, Linux normally discards it, in favor of the on-disk
filesystem (a process often refers to as "pivoting root"). In Android, however, the initramfs is kept in
memory, and provides the root filesystem. This is useful since the files are consulted often, and the
memory footprint is fairly small. It also makes tampering with the rootfs harder, since the boot
image is signed.

Linux supports two file formats for the RAMdisk - initrd (ext4 filesystem image) and initramfs
(CPIO archive). The latter is commonly used, though it is commonly referred to as an initrd. The
CPIO archive makes for a simple format with very little RAM requirements. To further save space,
the archive is gzipped (The kernel already has zlib support, which it needs to decompress itself).

Every vendor is free to build the RAM disk as it sees fit, though most take the Android emulator
image as a baseline - which is why it's not surprising to see init.goldfish.rc in some. Most RAM disks
are therefore very similar. Further, for a given device, the boot and recovery RAM disks will be
largely the same, with the execption of subtle modifications in the /init.rc file, which controls system
startup. In a recovery RAM disk, the /init.rc omits the standard set of services, leaving adbd, and
/sbin/recovery.

As specified, the kernel is packaged along with the ramdisk into a separate partition. This has a
very important design rationale behind it: By packing the two together, a single digital signature
may be applied on both, securing two for the price of one against tampering. That the kernel is a
critical component of the system should be obvious, but the RAM disk, as well, is quite important: It
controls system start up by providing /init and its corresponding /init...rc files. /init starts up as root,
and is responsible for starting up all the other system components. Getting root access to a device is
as simple as modifying the /init.rc file - but cannot be done without violating the digital signature.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Unpacking the RAM disk

Using the  utility, you can obtain the RAM disk from either the boot or recovery
images. Unpacking it is a simple matter with the standard utilities - gunzip and cpio, as shown
here. If you don't possess a boot image, you can try this on the Android Emulator images.

Output 3-8: Unpacking a RAM disk from the recovery image using 

For a description of initramfs contents (i.e. the Root filesystem), see Table 2-6 in the previous
chapter. As a further experiment, you can compare the ramdisks of the boot and recovery images.

System and Data Partitions

The system and data partitions were discussed in the previous chapter. Vendors can provide
these images in any format they see fit, since they can use proprietary binaries to flash, as well.
Most vendors use fastboot, so their images are likely to follow the simg (sparse image) format used
by Google's own images. Utilities for handling this file format can be found in the AOSP under
system/core/libsparse.

Sparse images begin with a small (28-byte) header containing metadata about the image. The
header format is shown in Table 3-4:

Table 3-4: The sparse image header

Offset Length Field
0 4 Magic value ( )

4 4 Version (as Major + Minor). Currently .

8 2 Header Size. Always  (= 28)

10 2 Chunk Size

12 4 Block Size. Usually 0x1000 (4k) for Ext filesystems

16 4 Number of Blocks in filesystem

20 4 Number of Chunks in this file

24 4 Optional Checksum (usually zero)

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

file:///Users/morpheus/Documents/Android/Book/Filesystems.html#2-6
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#system


Experiment: Mounting the Android system image on a host

Extracting a sparse image is a simple matter using the  provided on the book's
companion website. You can also compile the AOSP's  from source. This is
demonstrated on the system.img - the userdata and cache images are largely empty.

Output 3-9: Unpacking an Android system image

Android emulator images (found in $SDK_ROOT/system-images) are simply raw filesystem
images, and so you can loop mount them directly. Later in this chapter we show how you can use
this experiment in reverse, to modify the system images in preparation for flashing to the device.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



The Boot Process

With all the components of the system images dissected, we can now turn our attention to the
actual boot process. Though device-dependent, the boot process can be generalized to the following
stages:

Figure 3-1: The generalized Android Boot Process

Firmware Boot

The device's firmware is akin to BIOS (or, nowadays, EFI) on PCs. Its main component is a boot
ROM, which is supplied by the hardware vendor. The boot ROM, being a component of read-only-
memory, is quite often a very small component, and contains only the initial boot sequence, which
initializes hardware components to the bare minimum required for usability. The boot ROM then
proceeds to load a secondary boot loader (sbl), which - being software - can afford to be of a bigger
size, and therefore perform more complicated initialization tasks (for example, displaying a startup
graphic image).

Unlike a PC, a mobile device's processor is not a single CPU, as would be the case with an Intel
or AMD processor, but a complete system-on-chip (SoC). In practice, this means that there are
several processors working in tandem, of which the application processor is only one. The
Qualcomm SnapDragon processors, for example, contain no less than four sub-processor: RPM
(Resource/Power Management), Krait (the application processor), Adreno (The graphics processor -
CPU) and Hexagon (the Digital Signal Processor - DSP). MSM chipsets, therefore, involve a
particularly lengthy boot process, wherein the boot ROM provides the primary boot loader (PBL), to
initialize the RPM processor. This, in turn, loads the secondary boot loader (sbl), which is itself
broken into three parts (sbl1→sbl2→sbl3). The parts load and authenticate one another in an
intricate choreography*, which also involves code from the rpm and tz (ARM TrustZone) partition.
The application processor then boots up the other components, and executes the application boot -
which is where Android's boot loader comes into play.

* - Said choreography is actually quite complex, and entirely undocumented outside Qualcomm confidential documents,
some of which have been leaked. For obvious reasons, this work cannot go into detail, but the information gleaned from
said documents, as well as a very detailed discussion, can be found at the XDA-Developers forum9a, with a plethora of
information in thread 241001419b

BootROM

SBL

rpm, sbl, modem..

(modem,
DSP, etc)

Android

BootLoader

aboot partition

Linux Kernel

boot partition (bootimg)

InitRamFS:

/init + rc files

Frameworks

GUI, etc..

/system partition

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

http://forum.xda-developers.com/showthread.php?t=1856327&page=1
http://forum.xda-developers.com/showpost.php?p=24100141&postcount=1968


The FastBoot Protocol

Most Android bootloaders support the "FastBoot" protocol, which Google makes available as
part of Android itself*. The FastBoot protocol is a simple, text-based protocol, which is meant to be
used over a USB channel between the device and the host. It's not exceptionally fast in terms of
performance (e.g. it is synchronous), so the name likely applies to it being very easy (and hence,
fast) to implement. Figure 3-2 shows the message passing between host and device:

Figure 3-2: The fastboot choreography

The current protocol version at the time of writing (0.4) is fairly well detailed in
system/core/fastboot/fastboot_protocol.txt. Table 3-5 lists the commands understood by the

 host-side binary, and their corresponding protocol messages:

Table 3-5: Default fastboot commands

Command Line Protocol command Description

flash <partition> [ <filename> ]

download:%08x,
flash:partition

write a file to a flash partition

flash:raw boot <kernel> [ <ramdisk> ] create bootimage and flash it

flashall flash boot + recovery + system

update reflash device from update.zip

erase <partition>
erase:partition

erase a flash partition

format <partition> format a flash partition

getvar <variable> getvar:variable display a bootloader variable

boot <kernel> [ <ramdisk> ] download:%08x,boot download and boot kernel

devices getvar:serialno list all connected devices

continue continue continue with autoboot

reboot reboot reboot device normally

reboot-bootloader reboot-bootloader reboot device into bootloader

oem [command [args]] command[:args] send an OEM extension
command

* - Vendors are not required to support FastBoot, and may support their own boot-loader protocols instead of, or in
addition to FastBoot. An example of that can be found in Samsung's ODIN, and Amazon's bootloader.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Using Fastboot

The Android SDK provides the  command, which is a simple but complete
implementation of the protocol. To see if your device's bootloader supports fastboot, you first
need to force it to halt at the bootloader stage. Rather than start up with the magic button
combination (which is tricky on some devices), you can use . Your
device will restart into the bootloader, and - if it supports fastboot, will be visible by "fastboot
devices", by its serial number - similar to adb:

Output 3-10: Output from 

At this point, the device should present the bootloader UI, and you should be able to
independently navigate the boot loader menus using the physical buttons (usually VOLUME
UP/DOWN, and POWER to select). You can also use any one of the commands in Table 3-5,
though because most are potentially dangerous (unless you know what you're doing), you can try
"getvar all", to list all the bootloader variables. These will be different on every device, and the
output from the HTC One M8 will show this:

Output 3-11: Output from an HTC-One M8 

The really interesting part of fastboot, however, is in the oem extension: try 
 to obtain a list of all commands (which will surely vary between devices). The commands are

extremely versatile and useful - HTC supports dmesg (to get bootloader log), get_temp (to read
temperature sensors), read/writeusername (personalize the phone), read/writecid (carrier ID) and
read/writeimei, which can be used by carriers to configure the phone for their networks. As noted
previously, some devices - notably the Nexus 5 and NVidia's Shield - support "oem unlock" - which
enables you to unlock the bootloader and free your phone, to load any custom firmware image.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



Kernel Boot

Android's kernel boot process isn't much different than that of Linux. The bad news, however, is
that the latter is somewhat of a moving target, with kernel version updates often adding or
removing components, as well as variance between platforms. This section therefore aims to provide
a high level overview of the kernel startup as it is implemented in the 3.x line of kernels. You might
want to follow along with a device-specific kernel source tree.

Recall, that the boot loader is responsible for locating the kernel zImage and RAM disk. 2QFH�
ERWK are resident in memory, control is transferred to the zImage's entry point. The kernel is�
compressed at this time, so the entry point - implemented in
arch/architecture/boot/compressed/head.S (head_32.S or head_64.S on x86) is responsible for calling

, which displays the familiar "Uncompressing Linux... done, booting the kernel"
message, and transfer control to the "real" entry point. This is, again, an architecture specific
function, implemented in assembly (  in arch/arm/kernel/head.S or  in
arch/x86/kernel/x86/kernel/head_[32|64].S, respectively). What follows is a low level setup of the
MMU and page tables (switching to virtual addressing), before control is transferred to the kernel's
main function, .

The  function is architecture independent, and is thus implemented in
init/main.c. It is fairly well writ, in the sense that it has almost no variables, and most of the startup
is performed by calling functions. To make a (very) long story short,  initializes all
the critical framework using the specialized functions, then calls , which - as the name
implies - initializes everything else. This function spawns the  thread, which is
responsible for initializing the various subsystems.

With so many subsystems to initialize, the kernel code would be terribly long and messy.
Instead, the initcall mechanism provides an elegant solution: it defines 8 initialization levels, which
the  thread calls on (via , in ) in order, as
shown in Table 3-6:

Table 3-6: The initcall levels

# Level Notes

0 early Used to spawn initial helper threads, such as RCU, SoftIRQs, and workqueues

1 core Used for "core" subsystems, such as binfmt and sockets

2 postcore Used by bdi (block device flush threads) and kobjects

3 arch Architecture dependent initialization

4 subsys General subsystems, such as bio, crypto and sound

5 fs Used by the VFS layer, for filesystem support

6 device Used by drivers, and general modules. The  macro maps to this level.

7 late Very last stage - Advanced memory management, oops handling and more

The idea is similar to the classic user-mode init's "runlevel" concept, which used run-levels to
group subsystem startup scripts. The  emulate this idea, by allowing subsystems to
register their initialization functions with a level  macro, which in turn will be invoked
when  processes the level. Once all init levels have been iterated through, the kernel
initialization is complete.

The messages output during the kernel boot can be seen using dmesg(1), but because the
kernel uses a ring buffer, it will most likely be partially overwritten by the time you get the root shell
necessary to run this command on a device. (The size of the kernel ring buffer can be configured
when the kernel is built).

Rather than follow the sequence step by step, the following listing maps the  output to
the startup functions which emit them. The bold lines are architecture independent, so you should
be able to see them (albeit with slightly different values) on x86 and ARM alike.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Listing 3-2: An annotated  output from the Android Emulator

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



Listing 3-2: An annotated  output from the Android Emulator (cont.)

When the kernel startup thread is done, it emerges into user mode as PID 1 - /init. We discuss
/init in detail in the next chapter, alongside the various Android-specific services it launches.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html


Shutdown & Reboot

Most users keep their devices on, but there are the occasional times when a user decides to
shutdown or reboot the device. In those cases, the decision usually starts with holding the power
button down for a few seconds, which pops up a confirmation dialog. If the user opts to actually
shut down or reboot the phone (as opposed to, say, Airplane Mode), the phone reboots.

Behind the scenes, however, the process is quite lengthy, and involves a rather complicated
choreography, as shown in Figure 3-3 (which should be read from bottom to top):

Figure 3-3: Pressing the shutdown button

The button press generates an interrupt, which is picked up by the Linux kernel. The interrupt is
translated by the kernel to an input event, which is then propagated to the Android runtime as an

. As with all other events, this is picked up by the Android's
 and  duo (both  threads), with the latter

passes the event to the  object. The default Policy object
(com.android.internal.policy.impl.PhoneWindowManager) intercepts the key if held for a sufficiently
long period (which is defined in the 's 
constant to be 500ms), and brings up the menu (through a call to

). 

* - The detailed discussion of Android's input architecture, from the low-level interrupt through the
, , Policy and Views can be found in Volume II.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

file:///Users/morpheus/Documents/Android/Book/frameworks/base/+/master/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java


If the user GRHV�RSW�WR�shut dowQ, two roads diverge: A tap will�proceed with a normal 
shutdown, but a long press will instead reboot to safe mode. Both tasks are
handled by a dedicated , whose  method optionally pops up
a confirmation dialog before beginning the shutdown sequence.

If the user confirms the shutdown,  sets two wakelocks, to keep
the screen on during the process (for a better user experience). The shutdown thread can then be
run. Its flow is shown in figure 3-4:

Figure 3-4: The flow of the Android shutdown sequence

The last step of the shutdown - at the Linux native level - is performed by /init. As the process
responsible for implementing system properties (q.v. Chapter 4), it picks up the setting of the

 property to either shutdown or reboot,reason. The reason can be either
 or . If the values seem familiar, it's because they are the very same ones

used by , which sets the very same property (as ) to the
value chosen by the user. This way, all paths lead to /init, which in turn calls on '

 function. This is nothing more than a wrapper to the kernel's  system
call, or , with the latter being a Linux specific invocation which allows the passing of the
additional reason.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Boot.html


Application Backup & Restore

Just as humans grapple with sickness, Operating Systems face the risk of data corruption, or
outright loss. Backup and Restore is therefore an important functionality which an operating system
needs to provide. Applications need an ability to save and recover their configuration and data, and
power users require a similar ability to backup the entire device to a well known, bootable
configuration or a system checkpoint which can be rolled back to in case of calamity.

Indeed, as of API level 8, Android provides Applications with the , a
framework service which provides both per-application backups, as well as full backups of all apps.
The internals of the framework service, including the Application Programming Interface it provides,
is covered (along with the rest of the framework services) in Volume II. The backup architecture is
quite elegant, delegating the responsibility of selecting which data is to be backed up to the
application: The application notifies the backup manager when data has changed, and the backup
manager adds the application to a queue.

Figure 3-5: A simplified view of the Android backup architecture

At some later time, when the  gets a request to actually perform a
backup, it creates a backup set, grouping together the one or more applications that were queued.
For each application, it invokes the  callback. The  passes the
application a file descriptor in the callbacks, which the application is expected to use in order to
write out (or read from) the backup data. The descriptor provided is connected to a transport, to
which the application remains entirely oblivious. Data is written and read to the transport while
leaving its implementation opaque - Data can be backed up either locally, or to "the Cloud" (i.e.
Google's servers, or the device vendor's), but the choice of where to back up to remains at the
system (or vendor) level. The common transports are shown in Table 3-7:

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



Table 3-7: Android Transports

Transport Backs up to
Google's servers. Application needs a special
API key to use this service

Enterprise backup, for managed devices

Local backup, to device

Command line tools

From the perspective of the power user, there's a far simpler interface to backup and restore, in
the form of two Dalvik upcall scripts, the  and  utilities. Both utilities require Java to facilitate
communication with the , which they perform over Binder (as discussed
in Chapter 7). The  utility is well documented10, and explains its usage in detail when invoked
with no arguments. A summary of its arguments is shown in Table 3-8:

Table 3-8: Commands and arguments understood by the  upcall script

Command Purpose
package Mark package to be backed up on next run

0|1 Enable/disable the backup mechanism

Report if backup mechanism is enabled or disabled

transports List available transports, * specifying default (q.v. Table 3-7)

sets List restore sets

transportName Set default transport

set [App] Restore from a specific set - all apps, or only App specified.

Perform pending backups now

transportName package Erase all backups of package from transportName

package Perform a full backup of specified package

By contrast, the  utility is entirely undocumented, and provides no user facing output,
preferring instead to use the Android logging system. expects only one argument -  or

, but can handle quite a few switches when backing up. The switches expected by  are
shown in Table 3-9, with the defaults in bold:

Table 3-9: Switches understood by 

Switch Purpose
Save or omit application .apk files

Save or omit application opaque binary blobs (.obb) files

Save or omit shared resources

Save or omit system applications in full backups

Save or omit widgets (default: -nowidgets)

Compress backup

Backup everything (requires user confirmation)

If the switches seem vaguely familiar, it's because they are the same as those passed to 
 (though the latter does not advertise  as an option). Backups through 

are just direct invocations of the  upcall script, which helps explain why it's not as user-friendly as
.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/SystemServer.html#servicepattern
http://developer.android.com/tools/help/bmgr.html


Figure 3-6: The default Backup UI (LG G3 running KitKat)

Local backups

Using , triggers a full backup of all applications. Doing so causes the 
utility to call the 's  method, which pops up a
customizable UI notification to the user.

The default notification UI activity is
hardcoded to

, and shown
in Figure 3-6. Using a UI requires the device
to be unlocked, adding a measure of security
for users, by mitigating the chance a device
could be taken for a minute or two, backed
up and returned to the unwitting user.
Another measure of security offers the user a
chance to cancel the backup, as well as enter
a password.

If the user approves the backup
operation, a toast notification informs that the
backup started, and the current package
progress is displayed.

When backing up to a connected host, 
connects the other end of the transport file
descriptor to a local file on the host, specified
by the  switch, or simply the backup.ab
default. The backup file uses a proprietary
format, which differs slightly if the backup is
encrypted or not. The format's only
documentation is embedded in the source of
the  class, but this
provides comprehensive detail, as shown in
Listing 3-3:

Listing 3-3: The format of an Android backup file

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

https://android.googlesource.com/platform/frameworks/base/+/master/services/backup/java/com/android/server/backup/BackupManagerService.java


Experiment: Examining Android Backups

The Android backup file header is easy to figure out using Listing 3-3, but its contents are
compressed by default. Using the semi-documented , which is supported by the 
upcall script but not readily advertised by , you can create an uncompressed backup:

Output 3-12: Creating and inspecting an uncompressed backup

The header is straightforward enough, but what of the actual backup contents? The first line
looks suspiciously like meta data. We therefore strip the header, and try our luck with :

Output 3-13: Stripping the header from an Android archive

And thus we see that Android backups, internally, are nothing more than good ol' UN*X 
archives. Using compression applies the Deflate algorithm after the .

If you do use encryption, the header size and complexity both increase. The following shows
the header of the same archive, when compressed and encrypted with "password":

Output 3-14: Examining an encrypted backup

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Monitoring backup operations

The  stores its configuration in two main locations:

The system secure settings: common to all Android framework services, and accessible
via the  class. The manager defines the following settings (with constants in the

 class identical to the string values, uppercased: 

Table 3-10: Settings controlling backup behavior

Setting Purpose
backup_enabled Is backup enabled? Equivalent to 

backup_transport Default transport. Settable by 

backup_provisioned Is backup provisioned? Useful for managed devices

backup_auto_restore Can application data be automatically restored?

The /data/backup directory: containing the list of transports (as directories), and backup
queues.

Normally, you won't need to go into the directory or settings yourself, as you can use  (or
) to toggle the settings, and  to get verbose information on the

queues. The annotated output is shown below:

Output 3-15: Using  to display the backup status

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/provider/Settings.java


Experiment: Delving deeper into backups

To get a better grip of backups on Android, have a look at the /data/backup directory, which is
where the  maintains its metadata. As root, you should see something
similar to the following:

Output 3-16: The /data/backup directories

Getting the default transport is a simple matter, either by calling on the  upcall script, or
querying the value directly from the system's secure settings:

Output 3-17: Finding the default transport

The backup queue is maintained in memory, but also written to the pending directory, as a
journal-xxxx.tmp temporary file, to provide recovery in case the backup service itself crashes. The
file format is simply a concatenation of package names to be backed up. Since the package names
are preceded by a length byte and NULL terminated, use  to display this file:

Output 3-18: Displaying the backup journal

Lastly, the fb-schedule file schedule is used to maintain a list of all installed packages which
are backup eligible (i.e. declared a  in their manifest, as we discuss in Volume II,
and is well documented in the Android Developer Website11). The file format is very similar to that
of the journal (albeit with a few more fields), but this is where  gets handy (which is
even more useful since you don't need root privileges to use it)

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

root@flounder:/data/backup # bmgr list transports
* com.google.android.backup/.BackupTransportService

    android/com.android.internal.backup.LocalTransport
root@flounder:/data/backup # settings get secure backup_transport
com.google.android.backup/.BackupTransportService

root@flounder:/data/backup # cat  -tv pending/journal-168056423.tmp
^@$com.android.providers.userdictionary^@'com.google.android.googlequicksearchbox^@"
com.google.android.marvin.talkback^@$com.google.android.inputmethod.latin^@^Ucom.
google.android.gm^@^Ocom.android.nfc^@^Scom.android.vending^@^Gandroid^@^Wcom.google.
android.talk^@^_com.android.sharedstoragebackup^@)com.google.android.apps.genie.
geniewidget^@^[com.google.android.calendar^@^^com.android.providers.settingsroot@

http://developer.android.com/guide/topics/data/backup.html#BackupManifest


System Recovery & Updates

System Recovery and updates are similar processes: In both, the system needs to be diverted
to an alternate boot sequence, which - rather than load the full OS UI - loads a minimal
configuration, wherein a special binary - /sbin/recovery - can be used to handle the process in
question.

Either process is normally started when the system is fully booted, and in UI mode, though the
device can also be ordered into recovery through  or via fastboot. When�
started from the UI, the  class provides the framework support�
needed for downloading and verifying an update, if one is required. The update must be digitally�
signed, and is validated against certificates taken from /system/etc/security/otacerts.zip keystore. If�
validation passes, the update is copied to the /cache partition. This is why on devices like the�
Amazon Kindle, with forced automatic updates which can break root, removing the otacerts.zip file
will prevent updates. An equally effective measure can be to  and  the
/cache partition.

The class also provides arguments to the recovery process, which it writes to the
/cache/recovery/command file. The class then reboots the system, but passes an argument to the
bootloader, to boot from the recovery partition, rather than the boot partition. Recall from the
earlier discussion that the recovery and boot partitions are usually identical, save for the ramdisk
image - which in the case of recovery, will load the /sbin/recovery, instead of the full Android
framework. The flow of commands from  to /sbin/recovery is shown in the
following figure:

Figure 3-7: Interaction of  with /sbin/recovery

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



The /sbin/recovery binary gets its arguments from its command line, if any. If those aren't
supplied, the misc partition is searched for the "Bootloader Control Block" (BCB). If the partition
cannot be found or its contents cannot be parsed, the binary turns to /cache/recovery/command. The
Android runtime does not interface with the BCB directly, but /sbin/recovery saves any arguments
supplied to it into the partition, to enable recovery to resume if somehow interrupted.

The /sbin/recovery binary is guaranteed to load - because it's part of the ramdisk, and not in any
way dependent on /system. This is an important observation, because the system may be in an
entirely unbootable state. At this point, then, the kernel has initialized, /init has loaded, but recovery
(and possibly adbd) is the only process executing. The /sbin/recovery will then read the command left
for it in the /cache/recovery/command file (as shown in the previous figure), and act according to its
content, shown in Table 3-10:

Table 3-10: Arguments understood by 

Argument Purpose
Wipe the /cache partition and reboot.

Wipe all the user data in the /data partition, i.e. a "Factory Reset". Throughout the
device lifetime, /system is normally mounted read-only, and should therefore face
little risk of corruption. Restoring the device to factory defaults therefore amounts to
formatting /data, which both serves to efface personal user data, as well as clear any
corrupted files which may be hindering the boot process. This option also implies 

.

Specifies the path to the an OTA update package, which needs to be applied as a
patch over the system. OTA packages are discussed next.

Specify locale used. This goes into /cache/recovery/last_locale.

Name of intent to place in /cache/recovery/intent.

Show textual messages

Exit without performing any actions. unused

During the process, it's important to keep the user informed and visually engaged. recovery
therefore makes use of minui, a library which (as its name implies) provides basic GUI functionality.
This library is discussed in more depth in Volume II.

Over-The-Air (OTA) Updates

Occasionally, the vendor or carrier (and sometimes Google itself) may provide an update to the
Android OS in the form of an Over-The-Air (OTA) update. To be delivered over the air, updates must
be kept as small as possible. It is for this reason that OTA updates are usually differential patches,
based on a particular build of Android, which is assumed to be the one being updated.

Android's OTA updates are packaged as a single zip file (technically, more like a JAR, as it
contains a META-INF/ subdirectory), digitally signed, which consists of:

Multiple patch files: in the bsdiff(1) format, which is essentially a series of file offsets and
lengths, along with the data to insert or delete from the offsets. The standard patch files
have the names of the files they are patching, with a ".p" extension appended to them.

A patch binary: (usually called update-binary) which can parse the patch files and apply
them, according to directions given by..

A patch script: (usually called updater-script) which executes the binary multiple times (one
per patch), and specifies the expected hash of the file to be patched - pre/post patch
operation.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Any additional files: which are either newly added to the system, or are so heavily
modified that a patch file would actually be larger than the full file.

A metadata file:: consisting of post-build, post-timestamp, pre-build and pre-device entries,
which provide the device properties before and after the update

An otacert file:: A PEM-formatted certificate. Can be compared to and optionally imported
into /system/etc/security/otacerts.zip.

Note, that vendors are free to add and/or modify any of the OTA components. A good example
can be seen in the updates of Amazon's Kindle, which contains not only updates to the files in
/system, but also additional firmware images, including the non mountable partitions.

Listing 3-4 shows the content of an OTA update, in this case the Google supplied KitKat update
for the Nexus 5:

Listing 3-4: The contents of an OTA update for the Nexus 5

The OTA update process

When started with , recovery binary calls , which
loads the package specified as argument, and looks for the update-binary inside it. The binary name
is hard-coded, d as the  of META-
INF/com/google/android/update-binary. If found, it starts it, and the update-binary executes the
updater-script, in a manner akin to shell scripts.

The standard update-binary's source can be found in the Android source tree (in the
bootable/recovery directory). The update-binary used by most OTA packages is derived from this
source, as vendors are encouraged to use the source as a point of departure. Rather than modifying
it, vendors can easily add additional libraries as "device extensions". This is done by adding any such
libraries to the  variable in the Android.mk file, and providing a

libname function in each.

Looking at the source of the updater binary, you can find a list of all functions in the
implementation of :

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

http://newandroidbook.com/src/Android/bootable/recovery/updater


Listing 3-5: The 's 

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Listing 3-6 shows an annotated example of an updater-script, from the Samsung OTA update
for 4.4.2. This demonstrates not just the commands from Listing 3-5, but also their usage with
arguments:

Listing 3-6: An annotated example of updater-script

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\



Customizing images

Armed with the information in this chapter, you should now have all the ingredients required to
concoct your own firmware image. Note, that - as a prerequisite to this step - the bootloader on
your device must be unlocked, because otherwise custom images will be rejected.

When customizing images, the usual caveats apply:

Images downloaded from untrusted sources can contain malware - especially spyware.

Using custom images may (or may not) void carrier's (or vendor's) warranty. That said, if the
bootloader is not tampered with, the process is generally reversible. Some bootloaders don't keep
track of tampering, so at times it's possible to just re-lock the bootloader, leaving no trace of any
modification.

Improperly installing a custom image may render the device unbootable ("brick"). The
probability of this increases in direction relation to the parts of the image being modified:

If only /data is modified, the OS can still boot from /system. At worst, it is possible to undo
changes by resetting to factory defaults (which effaces /data).

If both /data and /system are modified, the kernel and ramdisk can still boot normally (from
the boot partition), and so the system can always enter rescue mode.

If the boot partition (kernel + initramfs) are modified, the kernel and ramdisk may fail to
load, but the boot loader can still load, and hopefully offer fastboot (or another custom
protocol) which still enable overwriting boot (or any other partition), thus recovering
bootability.

If the bootloader itself is modified, you run the risk of corrupting it so that the device is
unbootable, and possibly bricked for good

Given the above, it makes sense to proceed with appropriate caution. Most bootloaders allow
you to boot alternate images (via fastboot) without overwriting any existing ones, which provides a
safe environment for testing. We next describe methods for customizing an image

Adding files to an existing filesystem

If your device is already rooted, adding files to an existing filesystem is quite trivial - you need 
to first make sure the filesystem is writable, and if it isn't, remount it as such, and then simply 
proceed to copy the files onto it. Since  normally doesn't run as root (though that, too can be 
modified), it's usually a two step operation of dropping the files (via adb push) at a writable 
directory (/data/local/tmp makes a good choice), and then ing them to their final destination (
usually doesn't work with toolbox since it involves linking).

This method involves more work than others presented here, but is generally the safest - so
long as you just add files and don't overwrite any existing ones, the chances of impacting the
system are fairly small. A minor exception to the rule is when adding property files or other files
whose presence changes the system behavior.

Modifying the initramfs

To modify files outside /data or /system filesystem, you will need to tweak the initramfs. Recall
from our earlier discussion that the initramfs forms the root file system, and remains loaded in
addition to /system and /data. The initramfs also contains the /init.rc file, which contains the startup
commands for /init. This makes the initramfs a suitable vector for inserting commands for rooting
the device, as well. This is demonstrated in the following experiment:

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Repacking an initramfs and writing it as a bootimg to the device

A previous experiment in this chapter demonstrated how to unpack the initramfs. Repacking
the initramfs into a gzip image is as simple as executing the inverse operations, namely, run cpio
with  (output) rather than  (input), and then run  to compress:

Output 3-19: Creating a compressed initramfs

Note, however, the the initramfs is not standalone, but always bundled alongside the kernel.
You therefore have to use the inverse of  - the AOSP's  to package the
initramfs along with the kernel, so both can then be flashed to the boot partition. Assuming you
have the kernel from the previous example handy (you wouldn't normally need to modify it), this
would look something like:

Output 3-20: Creating a boot image from a kernel and a compressed initramfs

And then write it to the device  (if your bootloader is unlocked), or by
using a simple (but careful!)  (if your device is otherwise rooted). The following uses the

 symlinks to figure out where the boot partition is. Note results may vary (and be
extremely careful not to confuse boot with aboot or hboot!).

Output 3-21: Booting from an image

As a measure for added safety, you can repeat the previous experiment to unpack the boot
image and verify it before writing it to the device. It's always a good idea to save the unmodified
boot image you started with, since it can easily be written back to the device (via fastboot) should
something go awry.

Overwriting an entire partition

Sometimes it's easier to just overwrite the entire partition, rather than just add files to it. This is
usually the case when the customization involves many files (such as reducing vendor bloatware), or
when it involves a partition that is not necessarily mountable. In either case, the first step involves
copying the partition directly from the raw block device onto an image, using the  utility, or a
direct  of the raw block device to the host. This method is essentially the same as the
process shown in Chapter 2. You can also use the Android stock images as a point of departure, as
shown in the earlier experiment.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

morpheus@Forge (~/Android/Book/tmp) % find . | xargs cpio -ovd | gzip > output.gz

morpheus@Forge (~/Android/Book/tmp)% mkbootimg --kernel kernel \
--ramdisk output.gz --output bootimg.img

morpheus@Forge (~/Android/Book/tmp)% adb push bootimg.img /data/local/tmp
morpheus@Forge (~/Android/Book/tmp)% adb shell
shell@Android /$ grep boot /proc/partitions
..
..
shell@Android /$ su
root@Android  /# dd if=/data/local/tmp/bootimg.img \

of=/dev/block/platform/msm-sdcc.1/by-name/boot

file:///Users/morpheus/Documents/Android/Book/Boot.html#unpackinginitramfs
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#showGPT
file:///Users/morpheus/Documents/Android/Book/b-mountimg


Experiment: Packing an Android System partition image

Recreating the partition image is generally an inverse of the process, and will require you to
use  (on the host) to create a new filesystem, before adding the files you want to it.
Unmounting the filesystem will commit changes to the image, and you can then copy it to the
device, switching the  arguments (very carefully!). Alternatively, you can use fastboot to
flash the image to its target partition. The  method may be preferable as a workaround for
cases where the bootloader refuses to flash unsigned partition images.

Compiling  instead of  in the earlier experiment will provide you with a
binary that can take a raw filesystem image and make it into a sparse one. This is useful if you
want to customize your Android device's image in a way that will enable you to flash it. You can
take the Android partition images as a base, add more files (a SetUID "su" comes to mind), and
then create a raw filesystem image from the mounted filesystem. From there, using  is
trivial, and you can then flash the resulting file to your device using  (discussed later in
this chapter).

Resources for image modding

The discussion of customizing images in this book should provide a solid foundation for you if
you choose to foray into this exciting, yet somewhat dangerous realm. Fortunately, there are quite a
few resources which can be of great value, providing mods developed and tested by other users and
sparing you the unfortunate experience of a bricked device.

XDA-Developers

Hands down the most important resource for Android power users, the XDA Developers12a

website is a vast repository for all things Android. In particular, its extensive forums12b which contain
threads and vivid discussions for just about any device on the market. Rooting and recovery tools
often get advertised first via the forums, and with a community of nearly 6 million users (amongst
them well known names in the modding world) it's always possible to get help in all but the most
newbie of questions.

Cyanogen, AOKP, etc

With Android's open source nature, it was only a matter of time before groups outside of
Google picked up the gauntlet of "modding" or customizing the operating system. Indeed, several
(open source) projects were up to the task, such as the Android Open Kang Project and
CyanogenMod. The latter has become a one-stop-shop for virtually every device on the market, with
customized versions of firmware rebuilt for each device from the vendor-provided kernel and system
image. Cyanogen developers also tweak the operating system in many ways, not the least of which
is rooting (which is an easy by-product of a custom image). More often than not, images
incorporating fixes and patches from newer versions of Android appear on Cyanogenmod well before
the official vendors release an update.

What makes Cyanogen possible is the fact that vendors must supply the source for the kernel
they use in Android. That, in addition to the AOSP remaining open, enables the collaborative effort
by many developers to vastly improve vendor releases, and liberate others from being subject to the
vendor's (often sluggish) update cycles. Thus, device specific tweaks to Android either get published
as part of the vendor's kernel sources, or - in binary form - as modules. In the latter case, however,
recompiling the kernel maintains compatibility with vendor modules. Vendor specific APKs can be
moved (or removed) from the base image easily, and others added.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://www.xda-developers.com/
http://forum.xda-developers.com/


Figure 3-8: The TWRP 2.8 (latest at the time of writing) UI

In most cases, rather than build-your-own image,Cyanogen can provide you with ready made
images, which mitigate the potential for an error during image creation - which can brick your
device. CyanogenMod have gone as far as to implement their own boot loader, and the entire
process of customizing and installing an image has been reduced to only a few clicks. The avid
reader is strongly encouraged to check out the CyanogenMod website13a for more. In particular,
Cyanogen maintains an extensive Wiki, and their Development Learning Center13b is a particularly
good reference.

Team-Win Recovery Project

The Team-Win Recovery Project14 is a custom recovery image created by a group of "Android�
Enthusiasts in it for the fun of the Win". Like all recovery images, it consists of a bootimg formatted�
partition, containing a kernel and RAM disk. The kernel is usually the same one found in the stock�
image, but the RAMdisk contains a full featured recovery binary, which includes a featureful GUI�
with backup/restore functionality, support for Ext file systems, ExFAT, and F2Fs, and ChainFire's�
SuperSU. The inclusion of the latter makes it a popular choice as a rooting tool for devices with�
unlocked bootloaders. )RU�DGYDQFHG�XVHUV��7:53
V�LPDJH�SURYLGHV�D�TXLFN�ZD\�WR�JHW�WKH�EXV\ER[�
 ELQDU\��FRPSLOHG�DJDLQVW�Bionic, and thus able to show AndroidLVPV��such as AIDs in  output.

TWRP's GUI layout is provided in the res/ui.xml
(which can be customized with resources
found at the Team's GitHub repository15). The
res/ directory also contains fonts and PNG
images used by the layout. The binary is a
larger than usual /sbin/recovery, which uses a
modified version of the AOSP's MinUI
( ) library. The modifications
enables the simple GUI and touch support (as
opposed to standard recovery binaries, which
require the physical keys of the device -
volume and power buttons). None of the
Android runtime features or services are
needed (though a barebones /init does load,
as is required by the boot process), which
keeps the image compact. MinUI is covered in
more detail in Volume II.

��

&KDSWHU�,,,��%RRW��%DFNXS�DQG�5HFRYHU\

&\DQRJHQ�LV�EHFRPLQJ�VRPHZKDW�RI�DQ�DOWHUQDWLYH�WR�VWRFN�$QGURLG��DV�VRPH�YHQGRUV�
�QRWDEO\�2QH�3OXV��XVH�LW�DV�WKH�GHIDXOW�YHUVLRQ�RI�$QGURLG��UDWKHU�WKDQ�*RRJOH
V�RZQ��1RZ�D�IXOO�
IOHGJHG�VWDUWXS��&\DQRJHQ�FRPPDQGHG�RYHU������LQ�LQYHVWPHQWV�IURP�0LFURVRIW��)R[&RQQ�DQG�
RWKHUV�

http://www.cyanogenmod.org/
http://wiki.cyanogenmod.org/w/Development
http://teamw.in/project/twrp2
https://github.com/TeamWin/Team-Win-Recovery-Project/tree/jb-wip/gui/devices


Summary

This chapter explored aspects of the Android boot sequence and lifecycle: From the formats of
the various images involved, through their step-by-step operation. Shutting down and restarting was
explained, in particular "booting to recovery". Recovery mode concepts and the role of /sbin/recovery
followed. Finally, the process of customizing or "modding" images was explained in detail.

One glaring, yet intentional omission was that of user mode boot - i.e. what happens following
kernel initialization, when PID 1 (/init) starts up, and launches the various Android native services
(and, eventually, the framework services). The roles of /init and the various native services are
explored in great detail in Chapter 5, and the framework services - in Volume II.

References

1. Companion Website, ImgTool source + binary: http://NewAndroidBook.com/files/imgtool.tar

2. Google Nexus Factory Image Repository:
https://developers.google.com/android/nexus/images

3. a. CodeAurora, LK: https://www.codeaurora.org/cgit/quic/la/kernel/lk/tree/app/aboot
b. Google Source, LK:
https://android.googlesource.com/kernel/lk/+/a9b07bbae16a0b1b6de07ec3a3e2005c99043757/

4. a. Accuvant, Building a Nexus 4 UART Debug cable: http://www.accuvant.com/blog/building-
a-nexus-4-uart-debug-cable 
b. OSDevNotes Blog, 64-Bit ARM Kernel Development demo:
http://osdevnotes.blogspot.com/2014/11/64-bit-arm-oskernelsystems-development.html

5. Companion article, Disassembling ABoot http://NewAndroidBook.com/Articles/aboot.html

6. Android Documentation, Building Kernels: http://source.android.com/source/building-
kernels.html

7. ePAPR DTB specification: https://www.power.org/wp-
content/uploads/2012/06/Power_ePAPR_APPROVED_v1.1.pdf

8. Thomas Pettazoni, "Device Tree for Dummies": http://elinux.org/images/a/a3/Elce2013-
petazzoni-devicetree-for-dummies.pdf

9. a. XDA-Developers, Discussion of Qualcomm leaked documents: http://forum.xda-
developers.com/showthread.php?t=1856327&page=1
b. Thread 24100141

10. Android Developer,  utility: http://developer.android.com/tools/help/bmgr.html

11. Android Developer, Declaring Backup Agent in Manifest:
http://developer.android.com/guide/topics/data/backup.html#BackupManifest

12. a. XDA Developers: http://www.xda-developers.com
b. XDA Developers - Forums: http://forum.xda-developers.com

13. a. CyanogenMod: http://www.cyanogenmod.org/
b. CyanogenMod Wiki: http://wiki.cyanogenmod.org/w/Development

14. Team-Win Recovery Project: http://teamw.in/project/twrp2

15. Team-Win GitHub Repository: https://github.com/TeamWin/Team-Win-Recovery-
Project/tree/jb-wip/gui/devices">

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html
http://newandroidbook.com/files/imgtool.tar
https://developers.google.com/android/nexus/images
https://www.codeaurora.org/cgit/quic/la/kernel/lk/tree/app/aboot
https://android.googlesource.com/kernel/lk/+/a9b07bbae16a0b1b6de07ec3a3e2005c99043757/
http://www.accuvant.com/blog/building-a-nexus-4-uart-debug-cable
http://osdevnotes.blogspot.com/2014/11/64-bit-arm-oskernelsystems-development.html
http://newandroidbook.com/Articles/aboot.html
http://source.android.com/source/building-kernels.html
http://elinux.org/images/a/a3/Elce2013-petazzoni-devicetree-for-dummies.pdf
http://forum.xda-developers.com/showthread.php?t=1856327&page=1
http://forum.xda-developers.com/showpost.php?p=24100141&postcount=1968
http://developer.android.com/tools/help/bmgr.html
http://developer.android.com/guide/topics/data/backup.html#BackupManifest
http://www.xda-developers.com/
http://forum.xda-developers.com/
http://www.cyanogenmod.org/
http://wiki.cyanogenmod.org/w/Development
http://teamw.in/project/twrp2
https://github.com/TeamWin/Team-Win-Recovery-Project/tree/jb-wip/gui/devices


IV: init

All UN*X systems have a special process, a process which is the first to spring into existence in
user-mode when the kernel has finished booting, and is charged with starting up the system and
serving as the progenitor of all other processes. Traditionally, this process is called init, and Android
follows that convention as well.

The Android init, however, is vastly different than that of UN*X or Linux, with the most
important differences being in its support of System Properties and using a particular set of rc files.
Following the explanation of those two features, we piece together the flow of init: its Initialization
and Run-Loop.

As it so happens,  also fills additional roles - assuming the guise of ueventd and
watchdogd, two important core services which are also implemented by init, loaded through a
symbolic link.

��

file:///Users/morpheus/Documents/Android/Book/Init.html#systemproperties
file:///Users/morpheus/Documents/Android/Book/Init.html#rcfiles
file:///Users/morpheus/Documents/Android/Book/Init.html#alltogether
file:///Users/morpheus/Documents/Android/Book/Init.html#guises
file:///Users/morpheus/Documents/Android/Book/Init.html#ueventd
file:///Users/morpheus/Documents/Android/Book/Init.html#watchdogd


The roles and responsbilities of init

Like most UN*X kernels, the Linux kernel looks for a hard-coded binary to launch as the first
user mode process. On desktop Linux systems, this has traditionally been /sbin/init, which read the
/etc/inittab file for a description of supported "run-levels", or runtime configurations (single user,
multi-user, network file systems, etc), start-up processes, and ctrl-alt-del behavior. Android also
uses an "init" binary, but most similarities end with the name. The following table shows the
differences:

Table 4-1: Android's /init versus the traditional UN*X /sbin/init

Linux /sbin/init Android /init

Config file /etc/inittab
/init.rc and any ed file (commonly
init.hardware.rc and init.usb.rc (sometimes
init.hardware.usb.rc

Multiple
configurations

Supported through the notion of "run-
levels" (0: shutdown, 1, single user, 2-3
multi-user, etc). Each "run level" loads
scripts from /etc/rcrunlevel.d

No run-levels, but offers configuration options
through triggers and system properties

Watchdog
functionality

Yes: Daemons defined with the
 keyword are restarted on exit,

unless they repeatedly crash, in which
case they are suspended for a few
minutes.

Yes: Services are kept alive by default, unless
defined as . Services may also further
be defined as , which will force the
system to reboot if they cannot be restarted.

Adopting
orphan
processes

Yes:  will call  to
reap the return code, and avoid
zombies.

Yes:  registers a handler for 
which the kernel will automatically send on child
process exit. Most processes are silently

ed for and their exit code discarded.

System
Properties

No: Linux  does not support
the notion of system properties

 provides read access to properties
( ) to all processes on the system via
shared memory, and a 
which allows write access ( ).

Socket
assignment

No: Linux's init cannot get sockets for
its child processes. This functionality is
available for inetd.

Yes:  can bind a UNIX domain (or, as of
L, seqpacket) socket for a child, which can then
get it through 

Triggered
operation

No: Linux allows only very specific
triggers, such as ctrl-alt-del and UPS
power events, but does not allow
arbitrary triggers

Yes:  can execute commands on any
system property change, allowing it to run pre-
defined commands on triggers that can be set
by any (or some) users

Handling
uevents

No: Linux relies on the 
daemon (usually )

Sort of:  also spawns itself as ,
with separate config files

As a binary, /init is statically linked. This means that all of its dependencies are merged into the
binary during compilation, so as to mitigate the risk that a corrupt or missing library abort system
startup. When it is first launched, the only filesystem mounted is the root filesystem (i.e / and /sbin),
which is packaged in the Android boot partition along with the kernel.

In a sense, the Android take on init is closer to another's - iOS's launchd. Triggers and sockets in
particular are features offered by the latter, though Android shows novelty with the introduction of
system properties.

��

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



System Properties

The Android System Properties provide a globally accessible repository of configuration settings.
They are somehwat similar in form and function to  MIBs, but are implemented in user
mode by . The  code in  loads properties from several files, in the
order shown in table 4-2:

Table 4-2: Property Files in the Android file system

File Contains

/default.prop Initial settings. Note this file is part of the initramfs, and not present on
the device's flash partitions.

/system/build.prop Settings generated by the Android build process

/system/default.prop Settings usually added by vendor

/data/local.prop
Loaded if  was compiled with , and the

 property is set to 1. This enables developers to override
previous settings by dropping a file into /data.

/data/properW\/SHUVLVW�* Persistent properties. Prefixed by , these are saved across reboot
individually in files in this directory.  can also re-load them at any
time using the  directive in the /init.rc.

An additional property file,  (/factory/factory.prop) is #defined but no
longer supported. Note the order of loading does matter, since setting the same property a second
time will overwrite the previous value (unless the property is marked read-only).

Because  is the ancestor of all processes in the system, it is only natural that it implement
the property store. Early in its initialization, the  code calls  to set up
system properties. This function (eventually) calls , which opens the

 ( d as /dev/__properties__), and  into memory with read/write
permissions, before closing it. Additionally, init re-opens the file, this time for , and
then unlinks it.

Figure 4-1: Handling the property workspace mapping

��

&KDSWHU�,9��,QLW



The read-only file descriptor of the property file is set to be inheritable by children. This allows
any process in the system easy access to system properties, albeit read-only, by ing the
descriptor early on. This clever approach effectively allows all users of the properties area to share
the same physical memory backing the property area ( d as , 128k by default).
The only write access to this area, however, remains in the hands (and memory) of .

You can see the shared memory area in all user mode processes on the system easily by
looking at the maps /proc entry:

Output 4-1: Viewing the mapping of the system property area, through the /proc filesystem

Most developers remain agnostic to the internal structure of the shared property area. The area
is prefixed by a short header, which contains a serial number (reflecting internal versioning), a
magic value (  or 'PROP'), and a version (0xfc6ed0ab for newer versions of Android, or

 for compatibility). Then, following another 112 bytes (padding the header to 128
bytes), are the properties themselves. Properties are stores in a data structure which hybridizes a
trie (prefix tree) and a binary tree. This is rather nicely documented (if you appreciate ASCII art) in
Bionic's system_properties.c:

Listing 4-1: Internal structure of system properties, from system_properties.c:

The 

In order to service write requests,  opens up a dedicated UNIX domain socket -
/dev/socket/property_service, which is world-writable (0666), so that any client may connect. It is
then up to  to enforce permissions on the properties, which are hard-coded in an ever
increasing list called . The permissions are based on simple UID and GID checks,
(which  obtains from the socket caller credentials), as shown in table 4-3. UID 0 is allowed full
access to the properties. When SELinux is enabled (as of KitKat and L) property namespaces are
further protected by security contexts, as defined in /property_contexts, and shown in the following
listing. (SELinux on Android is explained in Chapter 8).

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

# In init: (note area is writable)
root@generic:/ # grep __properties /proc/1/maps

       /dev/__properties__b6f2f000-b6f4f000 rw-s 00000000 00:0b 1369
# In any user mode process (in this case, the shell)
root@generic:/ # grep __properties /proc/$$/maps

       /dev/__properties__b6e5a000-b6e7a000 r--s 00000000 00:0b 1369

file:///Users/morpheus/Documents/Android/Book/Security.html#PropertyContexts


Table 4-3: Property namespaces and their permissions

Namespace Owning
UID Contains

Network properties, used by rild

GSM related settings

Persistent radio settings

DNS resolver settings (in loco /etc/resolv.conf)

USB mode (adb, mtp, mass storage, rndis, etc)

AID_SYSTEM

All network settings (including those owned by
AID_RADIO)

All device settings

Unused

hardware related settings

system related settings

service start/stop keys

security related settings

Wireless LAN (WiFi) settings

Security Enhanced Linux settings

AID_SYSTEM
AID_DHCP DHCP settings

AID_SYSTEM
AID_SHELL Debug settings

AID_SHELL Logging settings

AID_SHELL Used by ADB if running as root

AID_SHELL Used by ADB if running over TCP/IP

AID_SHELL Power Management Control

AID_BLUETOOTH
Bluetooth settings

Bluetooth settings for BlueDroid stack

Special namespace prefixes

 recognizes several special prefixes, which govern how it handles the properties:

The  pseudo-prefix: designates the property as meant to survive reboot.
Persistent properties are backed up by files in /data/property/, which must be owned by
root:root, with no links.

The  pseudo-prefix: is used for "read-only" properties. These, like C constants, may be
set once and once-only, irrespective of owner UID. Normally these are set as early as
possible, i.e. in the vendor supplied build files.

The  prefix: is used to provide a convenient way to control init's services, by setting the
 or  properties (respectively) to the service name. �7KH�VWDUW�DQG�VWRS�

WRROV�RI�WRROER[�DUH�QRWKLQJ�PRUH�WKDQ�XVLQJ�FWO�IRU�]\JRWH��VXUIDFHIOLQJHU�DQG�QHWG������A 
separate ACL is�maintained in the  array, to restrict services by UID/GID. As of 
KitKat, this�list defined  ( ) and  ( ). In L 
SELinux�takes over ACL enforcement.

���

&KDSWHU�,9��,QLW



Accessing properties

The  command provides command line property access through / ,
and a property listener in the  command. The native API for properties are defined in
system/core/include/cutils/properties.h:

key value

default_value  - To retrieve a property, optionally specifying a default value if it does
not exist. This simply accesses the shared memory area.

key value  - To set the value of a
property. This serializes the key and value, and sends them over the property service socket.

propfn key value

cookie cookie  - To enumerate properties using a callback function
which will be invoked per property, with a pre-specified cookie

The  file includes a few other undocumented (though
accessible) functions, the most useful of which is 

serial , which blocks until any property is set. This is used by the  command.

Framework level access to system properties is carried out through
, which accesses the properties via JNI calls to the API calls.

Experiment: Using watchprops

The  tool can be used to monitor system property changes in real time. Starting
this tool as close as possible to device boot (by using 

 on the host) will still miss the build properties (since those are sourced before 
is started), but nonethless reveal the setting of important properties during boot, as shown in the
following annotated listing:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



The .rc Files

's main operation involves loading its configuration file, and acting upon its directives.
Traditionally, two files were used: The main /init.rc, and a device-specific /init.hardware.rc, where
hardware is obtained from the  kernel argument, or /proc/cpuinfo. The 
default emulator hardware, for example, is "goldfish" (and in M, ranchu ), and it is not uncommon 
to see /init.goldfish.rc on actual devices as well, probably due to most implementors copying the 
default filesystem without really paying attention to detail. The original idea might have been to have 
all Android devices use the same /init.rc, leaving the device-specific file for vendor customizations. In 
practice one finds quite often that implementors simply add more directives into /init.rc.

As of JB, the only hard-coded rc file is /init.rc, and the  directive is used to include
additional rc files explicitly. JB's default /init.rc also includes /init.hardware.rc, (imported as
/init.${ro.hardware}.rc, substituting the value of the property), and /init.usb.rc (or
/init.${ro.hardware}.rc), which contains the USB related directives for  - as discussed later in
this chapter. An additional  is also present in the default build, to enable the

 kernel facility to be used for debugging (Discussed in Volume III).

Triggers, actions, and services

The rc files are composed of trigger and service blocks. Trigger blocks contain commands, to
be executed when a trigger is satisfied. Service blocks define daemons, which  can start by
command and be responsible for, with optional modifiers (options) per such service. Service blocks
start with the service keyword, followed by a name and the command line. Triggers are defined by
the on keyword, followed by an argument, which is either a well-known name of a boot stage, or
the property keyword, followed by a property=value expression (in case the trigger is tied to a
property value change). When executing a given action or command,  sets the 
or  properties, respectively. Well known boot stages are shown in table 4-4, but
note, that not all boot stages need be used, and vendors often deviate (e.g. mount filesystems in
the init stage)

Table 4-4: The  boot stages

Init stage Contents
early-init Very first stage of initialization. Used for SELinux and OOM settings

init Creates file systems, mount points, and writes kernel variables

early-fs Run just before filesystems are ready to be mounted

fs Specifies which partitions to load

post-fs Commands to run after filesystems (other than /data) are mounted

post-fs-data /data decrypted (if necessary) and mounted

early-boot Run after property service has been initialized, but before booting rest

boot Normal boot commands

charger Commands used when device is in charger mode

init.rc syntax and command set

The init.rc and its imported files are very well annotated - but also quite long. Instead of
cutting/pasting them and wasting bytes and pages, we next focus on their syntax and other
features, which are relatively undocumented or little known. You may want to look at /init.rc
alongside reading this section.

The  recognizes two types of keywords when parsing the rc files: COMMANDs,
naming actions to execute on a trigger/boot-stage (valid only in a trigger block) and OPTIONs,
modifiers pertaining to a service declaration (valid only in a service block). Table 4-5 shows the
commands supported by ,from keywords.h. Colors correspond to different versions:

���

&KDSWHU�,9��,QLW

file:///Users/morpheus/Documents/Android/Book/Init.html#initusb


Table 4-5: Init commands

Command syntax Notes

directory as cd command (calls )

octal_perms file Change octal_perms masks of file

user group file Same as user group file

directory as Linux chroot command (calls )

service_class  Stop/Start all services associated with service_class

class Start or stop

src_file dst_file Same as  command

domainname Writes domainname to /proc/sys/kernel/domainname

command No longer supported

service L  Enable an otherwise disabled service

variable value Export environment variable. Will be inherited by all children

hostname Writes hostnname to /proc/sys/kernel/hostname

interface Bring up an interface (same as ifconfig interface up)

module.ko Load a kernel module

filename.rc Include an additional rc file

L  (Re)-Load all properties from build, default and factory files

 (Re)-Load all persistent properties from /data/propert\

level Set kernel loglevel (printk)

directory Create a directory (calls )

fstype fs point Mount a file system of fs_htype from fs on mount point

Mount file systems in vold's /fstab.hardware. This causes init to fork and 
perform mounts using . init detects any encrypted file systems.

shutdown/reboot KK  shutdown/reboot wrapper
service_name Start/restart service specified in service block matching service_name

path Restore SELinux context for path (recursive added in L)

filename  Remove a file or directory (calls / , respectively)

SEcontext  Set (change) SELinux context. Init uses 

[0|1]  Toggle SELinux enforcement on/off

table index value Set key table

key value Set a system property

value Set an SELinux boolean property. value can be 0/false/off or 1/true/on

category min max use  system call to enforce process (q.v. )

service_name Stop service specified in service block matching service_name

.. KK  Activate all swap partitions in fstab

target src Creates a symbolic link (as  - calls )

tzoffset Set system clock timezone (using 

trigger_name Activate a trigger (causing init to re-run corresponding commands)

file timeout Wait up to timeout seconds for file to be created.

file value Writes value to file. Same as value

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

M  pdates DM- erity (partition encryption state) for mount point

 M  Loads DM-verity state

M  Start bootchartin  (if confi ured). M makes bootchartin  optional



If you look through your /init.rc files, you will likely see these commands used during the
various boot stages to perform what one might expect during system startup: Setting up the
directory structure, enforcing filesystem permissions, and setting up various kernel parameters via
/proc or /sys. Once the boot stages are all defined, the rest of the file will deal with service
definitions. As stated, service blocks are modified by options. These provide the parameters by
means of which  determines how the services are to be run, and monitored. Table 4-6 lists the
available options.

Table 4-6: Init options

Option
Syntax Notes

Supports Linux  (or at least, will, at some point in the future)

Defines the service to be part of a service group. Classes can then be manipulated
together by the  commands.

Defines the service as a console service.  linked to /dev/console.

Defines the service as a critical one. Critical services are automatically restarted. If they
crash more than  (4) times in  (240)
seconds, the system will auto-reboot into recovery mode

Indicates service will not be started. Service can still be started manually

Specifies the gid to start the service as.  will call  for this.

Specifies the I/O priority for the service.  will call 

Specifies a key chord that can trigger this service. (discussed below)

Tells init to start the service, but not worry about it (that is, ignore its ).

Lists which commands to invoke if/when the service needs to be restarted. This is
commonly used to restart dependent services

Specifies the SELinux label to apply to this service

Set an environment variable prior to ing and ing the service. Unlike ,
this environment variable will only be seen by the service

Tells  to open this UNIX Domain socket and let the process inherit the open socket
descriptor. This enables services to work with , and not worry about which
sockets to open or the permissions they may require

Specifies the uid to start the service as.  will call  for this.

Starting services

Although the syntax is different, when starting services  assumes the traditional function
of PID 1 (the traditional , or , to start up services: It s, sets up the service's
permissions (by calling ), sets up any input (UNIX domain) sockets and
any environment variables, I/O priority (for services with ), and SELinux context. For
services defined with ,  connects /dev/console to stdin/stdout/stderr, and for all others
it "zaps" stdio. Though presently unsupported,  will also set the capability set for services
defined with  (as discussed in Chapter 8). Only once all of these operations have been
performed, will  call  to launch the service binary.

After the service is started,  maintains a parental link to it - should the service terminate or
crash,  will receive a  signal, notifying it of the event - and allowing the service to be
restarted. The  option allows  to form dependencies between services, and run
additional commands or restart dependent services when a particular service needs restarting. The

 option defines the service as a "must-have", and if  encounters a restart loop for a
service deemed critical (that is, it restarts the service, only to have it crash again), it will reboot the
entire system into recovery mode. For every service,  also maintains a corresponding

service property to reflect the service status (running/stopped/restarting).

���

&KDSWHU�,9��,QLW

file:///Users/morpheus/Documents/Android/Book/Security.html#capabilities


Keychords

An interesting, (though little known) function of  is starting services in response to
keychords. The chords are defined as combinations of keys (on devices with a physical keyboard) or
buttons pressed by the user at any time (akin to key combinations one would press on a piano). The
keys are specified by their IDs, which are taken from Linux's  input mechanism.

Note the keychords follow codes specified in Android's key layout files (usually found in
/system/usr/keylayout) and not the same codes as specified and used by the frameworks (i.e. the
codes at frameworks/native/include/android/keycodes.h). The only default service tied to a keychord is

, defined on some devices (like the Nexus 5) to be associated with the volume and
power buttons. You can find its definition in the Nexus' /init.hammerhead.rc:

Listing 4-2: The BugReport service, demonstrating the use of keychords, from /init.hammerhead.rc

The dumpstate command is an AOSP provided binary which iterates over all subsystems and
services and dumps all diagnostics and statistics available for them. Note the service is disabled,
meaning it has to be started manually, and its startup is tied to keycodes 114, 115 and 116. These,
as you can verify by /system/usr/keylayout/Generic.kl are mapped to ,  and

, respectively.

For keychords to be supported, /dev/keychord must exist. This is a device node exported by the
keychord kernel driver, if the kernel was compiled with , or the driver was
installed as a module. The driver can be considered an "Androidism" of sorts, and is discussed in
more detail in Volume III.

On a rooted device (i.e one with a modified root filesystem) you can add all sorts of
functionality using keychords. In the default configuration you're somewhat limited
(since only physical keys can be specified), but you can still override the
combinations to implement any functionality of your choice. In devices with physical

keyboard or additional buttons, using keychords opens up even more possibilities

Mounting File Systems

Though Android has a dedicated volume manager daemon ( ), init still has to perform some
mount operations by itself: Recall, that when init is started only the root filesystem is mounted - no
/system or /data and therefore it falls on it to at the very least mount /system, so that the various
daemons - including  can start. Naturally, this is a critical operation: If neither filesystem can
be mounted, /init will drop the device into recovery mode.

init recognizes the  directive in the /init.rc (usually placed in the  trigger) as a
request to perform a mount of all the default file systems. These are specified in the /fstab.hardware
file, which is one of the files built by the AOSP. The code to handle the mount is in , which is
used by both /init and . When /init performs the mount, it first forks, so as to mitigate the
chance of a critical error impacting its own startup.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



The child process performs the mount operations, potentially running  on the filesystems,
if required.  hardcodes the paths to the various checkers (presently,

 and, as of L, ), and those, too, are fork()ed.
The  code bumps up its logging level, so you can see its messages in the kernel ring buffer
(using ). If you do so early on enough (provided the buffer hasn't cycled to overwrite older
messages), you will find  flagged messages interspersed with those of , 
(both kernel modules providing respective filesystem support), and  (which is enforced on
the filesystems if extended attributes are detected.

It iV thus, that the child process handles the mounts, and returns a code to the parent (as all�
children do). It is according to this return value that /init sets the value of the 
property, which will be later picked up by  to handle decryption of the filesystem, if necessary.�
If no filesystems are encrypted, /init fires the  trigger.

Putting it all together: The flow of 

As is the pattern with most daemons, /init's code follows a classic server setup: initialization,
followed by a run-loop, which (hopefully) never exits.

Initialization

/init's initialization consists of the following steps:

Check if the binary was invoked as  or (as of KitKat) . If so, the rest of
the flow is diverted to the corresponding main loop for either of those daemons, discussed
later in this chapter.

Create directory entries for /dev, proc, and sys, and mount them.

Touch (open and then close) /dev/.booting. This file is cleared once startup is complete (by
 (q.v. Figure 4-2).

 to "daemonize" (link / /  to /dev/null).

 creates /dev/__kmsg__ (Major 1, Minor 11), and immediately deletes it.

 creates the shared property area in memory, as discussed earlier in this
chapter in "System Properties"

 gets the hardware name by reading /proc/cpuinfo and extracting
the "Hardware:" line. Rather crude, but it works (at least, on ARM architectures)

 reads /proc/cmdline and imports as properties any arguments
beginning with  as .

SELinux is initialized, on JellyBean and later. In JB it is still conditionally #ifdef'ed
HAVE_SELINUX. In KK SELinux is assumed to be available by default. The SELinux security
contexts are restored for /dev and /sys.

A special check is made to see if the device is in "charger mode" (as indicated by an
 kernel argument). This will divert the flow of init by skipping most of the

initialization stages, and loading only the  class of services (which presently contains
only the  daemon). If the device is not in charger mode,  proceeds to load
/default.prop, and the boot up proceeds normally.

 is called to parse /init.rc.

 enqueues the actions supplied in the init.rc sections (using
) and the built-in actions ( ) on

an . The resulting queue is shown in Figure 4-2.

���

&KDSWHU�,9��,QLW

file:///Users/morpheus/Documents/Android/Book/Init.html#propertyinit


Figure 4-2: The init boot stages (in white) and built-in commands (in yellow)

early-init Writes oom_adj, sets SELinux context, starts ueventd

wait_for_coldboot_done Blocks until ueventd creates /dev/.coldboot_done

mix_hwrng_into_linux_rng
Copies entropy from /dev/hw_random (if present)
to /dev/urandom. If not, skip

keychord_init Opens /dev/keychord for service keycodes

console_init
Loads logo (/initlogo.rle) on graphics console (fb0)
or displays "A N D R O I D" on 40x30 text console (tty0)

init

ro.bootmode != chargerro.bootmode == charger

early-fs

fs

post-fs

post-fs-data

mix_hwrng_into_linux_rng Remixes entropy, in case random devices weren't available

property_service_init
Loads properties from files

Initializes /dev/socket/property_service

signal_init Create signal socketpair, registers SIGCHLD handler

check_startup Verify sockets exist, unlink /dev/.booting

ro.bootmode != chargerro.bootmode == charger

early-boot

charger

boot

queue_property_triggers Add all property triggers at end of action_queue

bootchart_init (#if BOOTCHART) collect boot statistics (o t o a   M)

Eventually, the main loop iterates through at all the init.rc commands, and  spends most of
its days asleep, polling the file descriptors, optionally logging to bootchart, and waking up only when
necessary. You can see init's file descriptors by looking at the /proc file system:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Output 4-2: Init's file descriptors, as seen through /proc/1/fd:

The run loop

The main run-loop is also quite simple, consisting only of three steps:

 - dequeues the action at the head of the queue, if any, and
performs it.

 - which iterates over all registered services and restarts them, if
necessary

Set up and poll (monitor) three socket descriptors:
The  (/dev/socket/property_service), through which client
processes who wish to set a property pass the property key and value. The

 code obtains the peer's credentials (using
), and performs the permission checks on the

property. If it can be set, any triggers or related services (for 
properties) are executed as well. If SELinux is enabled, /init calls on it to enforce the
/property_contexts.

The  (/dev/keychord, if it exists), which handles any service key-
combinations, as discussed previously

The  , one end of a , created to handle 
from dead offspring. When the signal is received, the  writes data
to the other end of the  ( ), making data available on the
receiving end, and causing  to call . This reaps
the process' return value (so as to lay it to rest, and avoid a zombie), cleans up any
sockets, and potentially restarts the process, if it is a tracked service.

It's important to emphasize that, aside from listening on the file descriptors, /init accepts no
other input from any source. In other words, there is no way to affect /init's operation. This is by
design, since /init remains an unrestricted, root-owned process. The only way to modify /init's
operation requires editing of the /init.rc files, which - being part of the root file system - are on a
separate partition (along with the kernel), and digitally signed, so as to reject modifications in all but
bootloader-unlocked devices.

���

&KDSWHU�,9��,QLW

root@generic:/proc/1 # ls -l fd
lrwx------  .... 0 -> /dev/__null__ (deleted) #
lrwx------  .... 1 -> /dev/__null__ (deleted) #  stdin, stdout and stderr closed
lrwx------  .... 2 -> /dev/__null__ (deleted) #

l-wx------  .... 3 -> /dev/__kmsg__ (deleted) # Major: 1, Minor: 11

lr-x------  .... 4 -> /dev/__properties__     

lrwx------  .... 5 -> socket:[1643]

# read-only property store, for children

# property_set_fd (/dev/socket/property_service)

lrwx------  .... 6 -> socket:[1645]
lrwx------  .... 7 -> socket:[1646]

# signal_fd       (socketpair[0])
# signal_recv_fd  (socketpair[1])

lrwx------  .... 9 -> socket:[1784]

file:///Users/morpheus/Documents/Android/Book/Init.html#keychords


Init and USB

An Android device occasionally needs to change its behavior as a USB attachment based on
user preference - act as a mass storage device, emulate a digital camera, start up or shutdown ADB,
and more. Rather than use a dedicated daemon to toggle behavior, the responsibility falls on init,
which communicates with the USB components in the kernel.

USB behavior is dictated the  system property. The frameworks (specifically,
UsbDeviceManager and its related classes) set the value of this property according to the user
choice, and init - being the keeper of all system properties - picks up any changes and applies them
using a trigger. For convenience, the property triggers are maintained separately in
init.hardware.usb.rc. This can be seen in the following listing, demonstrating the contents of this file
on a Nexus 5:

Listing 4-3: USB settings from , from a Nexus 5

As shown in the figure, 's response to property changes involves writing parameters to
/sys/class/android_usb/android0. The receiving end of these pseudo files is the USB gadget driver.
This, as the name implies, is a multipurpose driver which can emulate any aspect of USB
functionality, as dictated from user mode. The functions this driver can handle correspond to the
USB modes shown in Table 4-usb:

Table 4-usb: USB Modes recognized by the USB gadget driver

accessory Connecting accessories to the device - implements AoA protocol

acm Abstract Control Model (USB Modems)

adb
Android Debugger Bridge (adbd) functionality. Creates /dev/android_adb device node, over
which a host can communicate with the device's adbd.

audio_source USB Audio source (when connected to external speakers). Provides PCM playback

mass_storage Mass storage device (portable disk)

mtp
Media Transfer Protocol. Identifies as camera, and creates kernel thread to handle MTP
requests. Creates /dev/mtp_usb

rndis USB Remote NDIS, used when USB tethering the device

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/ANDROID_SRC_ROOT/frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager


To effectuate the changes, the driver needs to be disabled and reenabled. This is why toggling
"USB Debugging" or tethering temporarily disconnects the device from its host (as you can see by
observing the host's kernel messages or, if you have a virtual machine, getting a pop-up).

Experiment: Modifying device USB identification

The following experiment shows how you can control the device's USB personality. This is
demonstrated on a Galaxy S3, but the steps work on all devices.

Output 4-3: The USB personality files on a Galaxy S3

Changing the iProduct will change the string with which the device identifies itself to the host
(for example, Kindle HDX's string is "Lab126 Android", whereas some Chinese GooPhones identify
as "Apple iPhone"..). Changing the iSerial will change the string reported by 
(useful for ), and the iManufacturer or iProduct can similarly be changed. You can test
this for yourself by writing a string of your choice, then disconnecting and reconnecting the USB
cable to the host. Note, these changes do not persist across a reboot, but you can easily write
them to the /init.hardware.usb.rc (or applicable file on your device) if you like your new device
identity.

���

&KDSWHU�,9��,QLW

shell@s3:/sys/class/android_usb/android0# ls
bDeviceClass
bDeviceProtocol
bDeviceSubClass
bcdDevice
enable            # Toggles enable/disable

f_accessory@      # 
f_acm@ #  
f_adb@ #  
f_ccid@ #  
f_diag@ #  
f_mass_storage@   #  Exported gadget 

#   driver functionsf_mtp@
f_ncm@
f_ptp@
f_rmnet@
f_rmnet_sdio@
f_rmnet_smd@

#  
#  
#  

     #  
      #  

f_rmnet_smd_sdio@ #  
f_rndis@          # 

functions         # controls functionality
host_state

     # Holds vendor string (e.g SAMSUNG)iManufacturer
iProduct
iSerial
idProduct
idVendor

# Holds product ID reported: e.g. SAMSUNG_Android_SGH-I747
# Holds serial # reported by adb
# vendor's product id
# well known vendor id (e.g. Intel: 8086)

power
remote_wakeup
state
subsystem
terminal_version
uevent
shell@s3:/sys/class/android_usb/android0 $ cat functions
mtp,acm,adb
shell@s3:/sys/class/android_usb/android0 $ cat iProduct
SAMSUNG_Android_SGH-I747



The Other Roles of init

As discussed in the last section,  can also be fill additional roles - that of  and (as
of KitKat) . Even though these are filled by the same binary, the code path taken is an
entirely different one, and is chosen before any other initalization step.

ueventd

As ,  assumes the responsibility of managing hardware devices: Responding to
kernel notifications and device representations in the /sys filesystem, and making them available to
processes via symbolic links it creates in /dev. It uses different initialization files - that is, it consults
/ueventd.rc and /ueventd.hardware.rc, where hardware is obtained from /proc/cpuinfo, or the

 kernel argument. Unlike , however, the configuration file(s) only
contain entries related to device nodes and their permissions.  iterates over the lines of the
file and calls  for every device entry.

Figure 4-3: The flow of 

The next step is to call , which initializes a  socket. If a cold
boot is detected (i.e. if the /dev/.coldboot_done cannot be found),  iterates through the
/sys/class, /sys/block and /sys/devices subtrees, writing "add" to uevent psuedo-files in each. This
triggers uevent device addition notifications, which  otherwise might have missed prior to
its startup.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Once the socket ( ) is initialized, the role of  becomes very simple:
continuously poll it, read events as they become available, and handle them. Events may be of two
general types:

Device events: These events are generated by kernel subsystems when devices are added
or removed. In this sense,  functions like the traditional Linux : It creates or
removes  nodes corresponding to the devices.

Firmware events:  listens on firmware "add" events and attempts to load
firmware updates from /etc/firmware, /vendor/firmware and /firmware/image.

If compiled with ,  will log events as  messages.

watchdogd

Just like ,  is another facet of . In this identity, it is responsible for
interfacing with the hardware watchdog timer (/dev/watchdog, if present), by setting a timeout
value, and sending a keepalive signal (a null byte) at regular intervals. If the timeout value passes
and  fails to wake up in time, the hardware timer interrupt can be used by the kernel to
reset. While a somewhat drastic measure, the only reason  wouldn't wake up in time
would be a system hang. It's likely the system wouldn't recover from such a hang, and and
therefore it is simpler to restart the device.

As , the daemon accepts two command line arguments - the interval, and a margin
- both in seconds, with initial values of 10. The overall device timeout value is the sum of both (i.e.
20, by default), allowing for some leeway before the drastic measure of a reboot is taken.

Summary

This chapter explored all aspects of /init, the most critical of system processes without which
there would be no user-mode. We started by comparing it to its Linux and UN*X counterparts, then
moved on to explore its single most important idiosyncratic feature - System Properties. We next
discussed the syntax of its rc files, and constructed the full flow.

The next chapter explores the services themselves. Focusing on the default system daemons,
and then going on to , which provides support for all of Android's frameworks. The
actual framework services - which number in the many dozens - require much detail from a
programmatic perspective, which is why they have been left for Volume II.

Files discussed in this Chapter
Section File/Directory Contains

init
system/core/init The code of /init

/system/core/init/readme.txt Documentation on commands and triggers

ueventd system/core/init/ueventd.[ch] The code of /init's  persona

watchdogd system/core/init/watchdogd.[ch] The code of /init's  persona

���

&KDSWHU�,9��,QLW

file:///Users/morpheus/Documents/Android/Book/Init.html#systemproperties
file:///Users/morpheus/Documents/Android/Book/Init.html#rcfiles
file:///Users/morpheus/Documents/Android/Book/Init.html#alltogether


���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



V: Android Daemons

Android has quite a few daemons running in the background for providing its miscellaneous
housekeeping and operational functions. The services are mostly strewn in /init.rc without much
ordering, save the service class. The "core" services start first, followed by the "main" ones. The rc
also defines a "late_start" class, for services which depend on the /data partition, though no default
services belong to it. In this section, we adopt the service class division, but - since most services
are in "main" - further subcategorize by function.

Following our discussion of init in the previous chapter, we continue to cover the Core Services -
adbd, the servicemanager and KitKat's healthd, as well as new core services added in L: lmkd and
logd.

All other services are generally classified into the "main" category, so a subcategorization by
Network Services (netd, mdnsd, mtpd and rild), and Graphics and Media Services (surfaceflinger,
bootanimation, mediaserver and drmserver) follows. The remaining services are hard to group, so
they are placed into the "Other Services" category, which includes installd, keystore, debuggerd,
sdcard and - last, but far from least - Zygote.

���

file:///Users/morpheus/Documents/Android/Book/Init.html
file:///Users/morpheus/Documents/Android/Book/Services.html#CoreServices
file:///Users/morpheus/Documents/Android/Book/Services.html#adbd
file:///Users/morpheus/Documents/Android/Book/Services.html#servicemanager
file:///Users/morpheus/Documents/Android/Book/Services.html#healthd
file:///Users/morpheus/Documents/Android/Book/Services.html#lmkd
file:///Users/morpheus/Documents/Android/Book/Services.html#logd
file:///Users/morpheus/Documents/Android/Book/Services.html#NetworkServices
file:///Users/morpheus/Documents/Android/Book/Services.html#netd
file:///Users/morpheus/Documents/Android/Book/Services.html#mdnsd
file:///Users/morpheus/Documents/Android/Book/Services.html#mtpd
file:///Users/morpheus/Documents/Android/Book/Services.html#rild
file:///Users/morpheus/Documents/Android/Book/Services.html#GraphicsServices
file:///Users/morpheus/Documents/Android/Book/Services.html#surfaceflinger
file:///Users/morpheus/Documents/Android/Book/Services.html#bootanimation
file:///Users/morpheus/Documents/Android/Book/Services.html#mediaserver
file:///Users/morpheus/Documents/Android/Book/Services.html#drmserver
file:///Users/morpheus/Documents/Android/Book/Services.html#OtherServices
file:///Users/morpheus/Documents/Android/Book/Services.html#installd
file:///Users/morpheus/Documents/Android/Book/Services.html#keystore
file:///Users/morpheus/Documents/Android/Book/Services.html#debuggerd
file:///Users/morpheus/Documents/Android/Book/Services.html#sdcard
file:///Users/morpheus/Documents/Android/Book/Services.html#zygote


Core Services

The services in the "core" class are the first to be started during user-mode boot. These
services do not access the /data partition, and therefore can run irrespective of whether or not it is
mounted.

adbd

If you're reading this book, likely ADB needs no introduction: It is through this medium, known 
as the Android Debugger Bridge*, that the host and the device communicate. The bridge can be 
used either directly (using the  command) or indirectly (using ). The  command itself is 
well documented, and running it without any arguments will display a (rather lengthy) usage 
message. Of more interest to our discussion is how ADB actually works.

In its basic configuration, the , which is the device daemon providing the server
functionality of ADB, is defined in the /init.rc, albeit disabled, and started on demand in /init.usb.rc,
when the  property contains "adb" - which is what the well-known "USB
Debugging" GUI option activates:

Listing 5-1: adb definitions in the rc files (KitKat)

Note that the  is run by default as uid root. It does, however, drop privileges to run as uid
shell:shell, along with several other groups, as shown in this snippet from adb.c:

Listing 5-2: The adb main startup function, showing privilege settings

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

* - Interestingly, Samsung's Tizen uses the "smart debugger bridge" or sdb, which in almost all ways (including command 
line syntax!) is a complete clone of ADB.



Listing 5-2 (cont.): The adb main startup function, showing privilege settings

It's possible to make  to retain its privileges (from the host, running , which
sets the  to 1). A limitation in the adb source permits this only if the

 property is set to 1 (and otherwise prints the familiar error "adbd cannot run as
root in production builds"). The  can contain a hexadecimal value
specifying the logging mask (try setting it to 0xff for maximum verbosity). If the property exists and
is valid, adb will log to /data/adb/adb-%Y-%m-%d-%H-%M-%S.

The  normally uses the /dev/socket/adb UNIX Domain socket, as set up by , but also
uses /dev/android_adb (or, as of L, the functionfs endpoints in /dev/usb-ffs/adb/ep##) when
connecting to the host over USB (i.e. not in the emulator). The latter is a device node which is
created by the USB Gadget Driver. The  can also be made to listen on the TCP port specified
by the  property, or in its absence the 
property. In any of these cases, the architecture can be generialized as shown in Figure 5-1: 

Figure 5-1: The adb Architecture

���

&KDSWHU�9��'DHPRQV



Tracing the ADB Protocol

The ADB protocol is described in the protocol.txt file in its implementation, and therefore does
not merit much further discussion here. ADB has a simple, yet efficient tracing mechanism in the
form of the  environment variable. This variable, when exported to an  session,
causes the client side binary to verbosely print the protocol commands. The source for  lists
several options for this variable (all, adb, sockets, packets, rwx, usb, sync, sysdeps, transport, jdwp)
though in practice "transport" is the most useful one for viewing ADB messages - though without
indicating the message direction:

Output 5-1: Tracing adb protocol commands using 

ADB Security

Because ADB is a portal into such powerful debugging and tracing capabilities, it naturally poses
a significant security risk. Running as uid  is still rather far from  access, but nonetheless�
provides powerful abilities by virtue of the various group memberships (  and , to�
name but a few). Using ADB it's trivial to access the user's personal data, including the lock screen�
sequence, as well as upload any application or binary to the device. For this reason� later versions
of JellyBean take a step to secure ADB by introducing public key authentication, through the 
message, if the  is enabled (as can be seen in listing 5-2).

The  message is sent in response to an , demanding authentication before any more
commands can be exchanged. The argument of  is always a , which is an array of 20
random bytes collected from the device's entropy source (/dev/urandom). The host is expected to
answer by signing the token with its private key (which will be generated and stored in
$HOME/.android/adbkey), using an  reply specifying a  argument, and the random
bytes encrypted (read: signed) by its private key. If the corresponding public key is known to the
device, verification can ensue, and - if successful - the session may move to the online state.

As with all things related to public keys, there is the chicken and egg problem of making the
public key known a priori, so it can be used for verification. The default is to allow the host to
respond with a  argument. Since the key cannot be trusted, ADB shoves the key
through its  to  (specifically, ,
which is started by ), which in turn pops up a
dialog ( ), asking the user to confirm
the thumbprint (MD5 hash) of the key. If the user agrees, the key is added to the adb key store, in
/data/misc/adb/adb_keys. Note that vendors can easily recompile adbd to remove this functionality
(in ) and allow only hard-coded, vendor
supplied keys.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

# Message of length 12:
morpheus@Forge (~)$ ADB_TRACE=transport adb shell
30303063 000c
686f73743a76657273696f6e host:version

# Reply4f4b4159 OKAY
30303034 0004
30303166 001f
30303132 0012 # Message of length 18:

# Reply
# Message of length 6:

686f73743a7472616e73706f72742d61 host:transport-a
4f4b4159 OKAY
30303036 0006
7368656c6c3a shell:
4f4b4159 OKAY # Reply

file:///Users/morpheus/Documents/Android/Book/Services.html#l5-2


You can see the USB Debugging State, along with the adb_keys, in the output of 
. Note the similarities to SSH known_hosts files, which likely served as inspiration:

Output 5-2: Dumping USB debugging state with 

servicemanager

The  is a key component of Android's IPC mechanism. Though a small
binary, it is an important one, without which inter process communication would be severely
impaired. This is reflected in its defition in the /init.rc, as shown in Listing 5-3:

Listing 5-3: The servicemanager definition in /init.rc

What makes  so critical, and makes so many other services dependent upon
it, is its function as a service mapper. Virtually every IPC mechanism requires a mapper to enable
clients to find and connect to the services - UN*X has its portmapper (for sunrpc), Windows has its
DCE endpoint mapper - and the  fulfills this function in Android. Given this, the
definition in /init.rc should make sense - it's not that the services actually require the

, so much as that in the case of its untimely demise, clients would be unable to
find them. When the  is restarted, it does so with a tabula rasa - which requires
services to re-register in order to be found. Since there is no method for services to detect the
manager is dead, the only way is to get them to re-register is to force restart them as well.

The  certainly merits more attention, as do all the framework services, which
it supports. The next chapter discusses it in detail, alongside  (the process serves
as the service host) and its individual services.

���

&KDSWHU�9��'DHPRQV

shell@hammerhead:/ $ dumpsys usb
...
  USB Debugging State:
    Connected to adbd: true
    Last key received: null
    User keys:
QAAAAAGih7j/oQP+S8AmUvBrpjxGY/5yppWThz4mpP6U9wt/fzGyip4sNt/2cp+40rRb8whQLALvPS2fAwLm1LjSTmJ/
... Public Key (as Base64)
+a+2cNPxxtmOh6GzOcnmwPaVsQcMLkyx1yCCS2o4hnjKYmjqBQEAAQA= morpheus@Forge

    System keys:
IOException: java.io.FileNotFoundException: /adb_keys: open failed: ENOENT 
 (No such file or directory)
 ...

file:///Users/morpheus/Documents/Android/Book/SystemServer.html#servicemanager


healthd

The "health daemon" is meant to service general "device health" tasks periodically,
though at present the only tasks are battery related (this will likely change in future releases). The
daemon registers itself as the  service (  or

 in L). As the Registrar, healthd provides the framework services (e.g.
) with up-to-date battery statistics, which it obtains from sysfs.

Like most daemons,  sets up an initial configration, and then enters a run loop. The
detailed flow is shown in Figure 5-2:

Figure 5-2: The flow of healthd

Process commandline -n: (no publish with servicemanager), -c (charger, L)

healthd_board_init Loads configuration (sysfs file names for battery stats)

wakealarm_init Sets timer for periodic chores

uevent_init Opens a NetLink multicast socket for uevents

binder_init Set up binder fd

Create/Init BatteryMonitor Construct and then initialize a BatteryMonitor object

epoll_wait Set up three descriptors in epoll, and wait for events,
or timeout after periodic chores interval

handle eventsperiodic_chores

Healthd main loop blocks on the Linux  API to multiplex read operations on three
descriptors, and registers actions for each, as shown in the following table:

Table 5-1: The file descriptors held by  and their purpose

Descriptor Type Purpose

wakealarm_fd TimerFD Timer set to fire every  seconds. Upon
wakeup,  runs .

event_fd NetLink
Reads kernel notification events.  only concerns itself with those
of the power subsystem ( ). These events include
battery and charger notifications, and  runs .

binder_fd /dev/binder Listener updates by framework clients (when acting as )

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



The first descriptor polled is the , which  uses for its periodic chores.�
Two interval types are used: fast (1 minute, when on AC power), and slow (10 minutes, on
battery)*. The only chore presently defined is , which updates battery
statistics in healthd's role as the . This is also called when events
from the  subsystem are received over NetLink from :  makes no attempt
to parse the events, and merely refereshes the battery statistics. The latter mode is required in
order for  to respond to events such as charger [dis]connection, or other power
management alerts. Finally, the  is used to interact with the framework listeners
(primarily, the ), as described in the next chapter.

 Experiment: Observing 

Using the powerful  utility you can watch  behind the scenes: By
attaching to its process ID (as root) and calling on the  API,  can get
notifications of system calls. Because anything meaningful a process does goes through a system
call, this will provide a detailed trace of the activity, and reveal the names of the sysfs files

 uses to obtain its statistics, as shown in the following annotated output:

Output 5-3: Using  on 

* - Interestingly enough, in many Android releases the  call returns -EINVAL (Invalid argument), not
creating  and thus defaulting to polling on the  as an event source alone.

���

&KDSWHU�9��'DHPRQV

root@htc_m8wl:/ # ls -l /proc/$healthd_pid/fd | cut -c'1-10,55-'
lrwx------ 0 -> /dev/null
lrwx------ 1 -> /dev/null
lrwx------ 2 -> /dev/null

# Output: Log to kernell-wx------ 3 -> /dev/__kmsg__ (deleted)
lrwx------ 4 -> socket:[6951]
lrwx------ 5 -> /dev/binder
lrwx------ 6 -> anon_inode:[eventpoll]
l-wx------ 7 -> /dev/cpuctl/apps/tasks

# event_fd (NetLink socket)
# binder_fd
# epollfd
# fg_cgroup_fd (libcutils) 

l-wx------ 8 -> /dev/cpuctl/apps/bg_non_interactive/tasks # bg_cgroup_fd (libcutils) 
lr-x------ 9 -> /dev/__properties__                       # r/o property fd
root@htc_m8wl:/ # strace -p $healthd_pid
Process $healthd_pid attached - interrupt to quit
# healthd patiently polling (0xffffffff = indefinitely) until an fd signals an event
epoll_wait(0x6, 0xbebb5898, 0x2, 0xffffffff) = 1
# NetLink msg received on fd 4 (event_fd) - indicating core state change (going offline)
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000001}, 
msg_iov(1)=[{"offline@/devices/system/cpu/cpu1"..., 1024}], msg_controllen=24,  ....
# healthd's not interested, so it goes back to polling
epoll_wait(0x6, 0xbebb5898, 0x2, 0xffffffff) = 1
# message indicating change in battery status:
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000001}, 
msg_iov(1)=[{"change@/devices/platform/htc_bat"..., 1024}], msg_controllen=24, 
{cmsg_len=24, cmsg_level=SOL_SOCKET, cmsg_type=SCM_CREDENTIALS{pid=0, uid=0, gid=0}}, 
msg_flags=0}, 0) = 488
# 
# healthd goes into a flurry of statistics collection, opening and closing files:
#
open("/sys/class/power_supply/battery/present", O_RDONLY) = 10     # Is battery present?

= 2read(10, "1\n", 16)                                             # Yes (1)
close(10) = 0
open("/sys/class/power_supply/battery/capacity", O_RDONLY) = 10    # What is its capacity?

= 3read(10, "96\n", 128)                                           # 96%
close(10) = 0
open("/sys/class/power_supply/battery/batt_vol", O_RDONLY) = 10    # Voltage?
read(10, "4303\n", 128) = 5
close(10) = 0
...
open("/sys/class/power_supply/wireless/online", O_RDONLY) = 10   # Alas, no wireless charging 

= 2read(10, "0\n", 128)                                          # for the M8
close(10) = 0

# Report to kernel logwrite(3, "<6>healthd: battery l=96 v=4 t=2".., 51) = 51
ioctl(5, BINDER_WRITE_READ, 0xbebb5070)        = 0
epoll_wait(0x6, 0xbebb5898, 0x2, 0xffffffff) = ..

# Report to client listeners
# Back to polling

file:///Users/morpheus/Documents/Android/Book/Services-II.html#BatteryStats


 Experiment: Observing  (cont.)

Note the sysfs psuedo files (/sys/class/power_supply/*) are standard - in practice they are
symbolic links to the specific platform device nodes, which change between devices.

As an improvement on the above, you might want to send the  into the background
(by using ) and then disconnect and reconnect the USB cable. You will then see the NetLink
notification for battery change, followed by a change in /sys/class/power_supply/usb/online (from 1
to 0 on disconnect, or vice versa on connect).

As of Android L, healthd supports . You can actually take the Android L binary (from
a Nexus 5 or Emulator) and copy it to a device, as shown in this output:

Output 5-4: Running L's  on KK

If you use  to watch behind the scenes of , you'll see the following output
(file descriptors are different here, so they've been symbolically replaced)

Output 5-5: Running  concurrently on Output 5-4

This example, aside from showing the inner workings of  on L, also demonstrates an
important part of Android: IPC over binder. In the above, you can see how a file descriptor has
been passed from the calling process ( ) to . Binder internals are a complicated
discussion in their own right, and are left for Volume II of this work.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

# Before: Only KK healthd - note old service name (batterypropreg) 
#
root@htc_m8wl:/ # service list | grep batteryprop
91 batterypropreg: [android.os.IBatteryPropertiesRegistrar]   
root@htc_m8wl:/ # /data/local/tmp/healthd.L &                       # Run healthd from L 
[1] 7287
# After: new service name (batteryproperties) added. Name is different, so no conflict
# 
root@htc_m8wl:/ # service list | grep batteryprop
0 batteryproperties: [android.os.IBatteryPropertiesRegistrar] # L: diff. name, same iface
92 batterypropreg: [android.os.IBatteryPropertiesRegistrar]

# Calling dumpsysroot@htc_m8wl:/ # dumpsys batteryproperties
ac: 0 usb: 1 wireless: 0
status: 5 health: 2 present: 1
level: 100 voltage: 4 temp: 273

epoll_pwait(epoll_fd, {{EPOLLIN, {u32=37597, u64=12884939485}}}, 2, -1, NULL) = 1
= 0     # Incoming binder req
= 4     

ioctl(binder_fd, BINDER_WRITE_READ, 0xbeab1748)
write(...tasks, healthd_pid, 4) # Make healthd foreground

# Write output
     # to binder supplied 
     # file descriptor.

     # Make healthd background

..
write(new_fd, "ac: 0 usb: 1 wireless: 0\n", 25) = 25
write(new_fd, "status: 5 health: 2 present: 1\n", 31)  = 31
write(new_fd, "level: 100 voltage: 4 temp: 273\n", 32) = 32
fsync(new_fd) = -1 EINVAL (Invalid argument)
ioctl(binder_fd, BINDER_WRITE_READ, 0xbeab1600)       = 0
close(new_fd)                               = 0
write(...tasks, healthd_pid, 4) = 4
..
ioctl(binder_fd, BINDER_WRITE_READ, 0xbeab1758)       = 0

file:///Users/morpheus/Documents/Android/Book/IPC.html#binder


healthd as charger

In Android versions leading up to L, Android had a special daemon -  - which was
started by  when the system was detected to boot in charger mode (via a 

 directive, containing only a single service). In L,  has been merged into
, which makes sense, as 's main task is observing the battery state anyway.

When running as , healthd starts up in a manner similar to 's additional personae
(  and ) described previously. In other words, /bin/charger is now merely a
symbolic link to /sbin/healthd, which also starts with a  command line argument. The 
daemon is responsible for relaying the battery status graphically to the user while the device is
charging. It does so using the MinUI library (which is covered in depth in Volume II).

Though merely a speculation, it is likely that  will be augmented and play an
increasingly larger role in Android, possibly starting with L. A hint as to its importance can be found
in the fact that, aside from it being critical, it is also one of the few daemons that have made it into
the root file system (it's in /sbin, and not /system/bin like most others).

lmkd (Android L)

Android L uses another specialized core service class daemon called . It is defined
in the /init.rc as follows:

Listing 5-4: The  definition in /init.rc

The  provides an interface to the kernel's Low Memory Killer (LMK) mechanism, which
is an Androidism (i.e, a feature present in Android kernels, but not Linux ones). The LMK allows
Android finer control over the Linux Out-Of-Memory (OOM) mechanism, which automatically kills
tasks during memory pressure. Using the /proc/pid/oom_score_adj files, the  can adjust the
OOM score of processes, making them more or less "killable" - that is, prone to being killed when
the system experiences memory pressure. The Linux OOM mechanism is discussed in detail in a
later volume.

 has two possible modes of operation - depending on whether or not the LMK Androidism
is detected. If present,  merely writes OOM score adjustment values to the target processes'
/proc entries, leaving it to the LMK module to perform the actual killing on low memory pressure. In
kernels without LMK, however,  also takes it upon itself to respond to memory pressure events,
and perform the actual killing (that is, sending  to the process).  maintains a process
hash table to allow it to quickly look up processes and their memory scores.

As with all the other daemons discussed in this chapter,  uses  to
simultaneously wait on input from multiple sockets. The main socket - /dev/socket/lmkd - is the one
created for it by init, which is listening for connections. The only expected client is the

 (discussed in the next chapter), which uses this socket to notify the
daemon which process needs to have its score adjusted (via the ProcessList class). When the in-
kernel LMK is not available (i.e. its files in /sys/module/lowmemorykiller cannot be found), 
additionally listens on the memory cgroup files to pick up memory pressure events. This is shown in
Figure 5-3:

���

&KDSWHU�9��'DHPRQV

file:///Users/morpheus/Documents/Android/Book/Services-II.html#ActivityManager
file:///Users/morpheus/Documents/Android/Book/ANDROID_SRC_ROOT/L/L/base/services/core/java/com/android/server/am/ProcessList.java


Figure 5-3: The flow of 

When responding to memory pressure events, (that is, in cases where an in-kernel low memory
killer cannot be used)  parses the kernel's /proc/zoneinfo entry to extract the following values:

nr_free_pages: Amount of free memory (in units of 4K)

nr_file_pages: Amount of memory mapped by files (in units of 4K)

nr_shmem: Amount of shared memory. These pages are used by multiple processes, and
are therefore decremented from the file mapped page count.

nr_totalreserve_pages: Amount of reserved system memory. These pages are free, but
aren't really usable, so they are decremented from the free count.

The  then proceeds to kill processes until meeting the adjusted free and file mapped
targets.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



 Experiment: Observing 

At the time of writing, the Android source code for L hasn't been made available (aside from a 
very limited preview, which hasn't proven helpful). The binaries, however, are available for both 
the Nexus 5 and the Android Emulator. It is therefore easy to reverse engineer them in a level of 
detail sufficient for this work. Both static analysis (i.e. disassembly) and dynamic analysis (runtime
debugging) methods have been used. The method shown previously with  (using

) proves its efficacy once again. Note that  cannot be backported into KitKat, as it
relies on the seqpacket sockets created for it by init to communicate with the frameworks.

Output 5-6: Using  to figure out 

Looking at the above, you can see , like other daemon, blocks on the  (FD
3), waiting for an event. The fd used for input - 5 - is the /dev/socket/lmkd, the other end of which
is connected to the Android . Messages are variable length (up to 52
bytes), starting with a message type. Three message types have been observed:

Table 5-2:  protocol messages

Constant Type Parameters

LMK_TARGET 0x00000000 Integer array of parameters which  writes to 
/sys/module/lowmemorykiller/parameters/minfree

LMK_PRIO 0x00000001 PID to adjust (e.g. "\0\0\4\5" above for PID 1029), 
and oom_score_adj to set for it

LMK_PROCREMOVE 0x00000002 PID to remove from monitoring

���

&KDSWHU�9��'DHPRQV

root@LEmulator:/# ls -l /proc/$lmkd_pid/fd | cut -c1-10,55-
lrwx------ 0 -> /dev/null
lrwx------ 1 -> /dev/null
lrwx------ 10 -> socket:[7360]           # /dev/socket/lmkd (listening)
lrwx------ 2 -> /dev/null
lrwx------ 3 -> anon_inode:[eventpoll]
lrwx------ 4 -> socket:[7364]            # /dev/socket/logdw (to logd)
lrwx------ 5 -> socket:[7653]            # /dev/socket/lmkd (to ActivityManager)
lr-x------ 8 -> /dev/__properties__
root@LEmulator:/# strace -p $lmkd_pid
epoll_pwait(3, {{EPOLLIN, {u32=3069216345, u64=37428954713}}}, 2, -1, NULL, 8) = 1
read(5, "\0\0\0\1\0\0\4\5\0\0\0\v", 52) = 12
openat(AT_FDCWD, "/proc/1029/oom_score_adj", O_WRONLY) = 6
write(6, "647", 3) = 3
close(6) = 0



logd (Android L)

Android L defines a new, much needed logging mechanism with its  daemon. This
daemon serves as a centralized user-mode logger, as opposed to the traditional Android's
/dev/log/ files, implemented in kernel ring buffers. This not only addresses the main shortcomings of
the ring buffers - their small size and resident memory requirements, but also allows  to
integrate with SELinux auditing, by registering itself as the , which receives the SELinux
messages from the kernel (via netlink), and records them in the system log.

Another important new feature provided by  is log pruning, which allows the automatic
clearing or retaining of log records from specific UID. This aims to solve the problem of logs being
flooded with messages from overly-verbose processes, which make it harder to separate the wheat
from the chaff.  allows for white lists (UIDs or PIDs whose messages will be retained for
longer) and ~blacklists (UIDs or PIDs whose messages will be quickly pruned), using the new 
switch of .

The  service is defined in /init.rc as follows:

Listing 5-5: The  definition in /init.rc

Note this service is designed with not one, but four sockets:

/dev/socket/logd: The control interface socket.

/dev/socket/logdw: A write-only socket (permissions 022 = ).

/dev/socket/logdr: A read-write socket, designed for reading. Unlike the logd UN*X domain
socket, this is a seqpacket (sequential packet) socket.

An unnamed NetLink socket: Used when  also provides  functionality for
SELinux messages

The  spawns listener threads over its sockets, as well as threads for clients (spawned on
demand). The threads are individually named (using ) so you can see them for yourself in

's /proc/$pid/task/ when  is running.

As with the traditional logs,  recognizes the log buffers of main, radio, events, and system,
along with a new log - crash - added in L. These logs are identified by their "log ids" (lids),
numbered 0 through 5, respectively.

System properties used by 

The  recognizes several system properties, all in the  namespace, which toggle its
behavior. Those are well documented in the README.property file in 's directory, shown here for
convenience:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Listing 5-6: Properties used by 

Controlling 

Clients can connect to /dev/socket/logd to control logd with an array of protocol commands.
Commonly, the client doing so is the  command, which has been modified to use the socket,
rather than the legacy  codes over /dev/log. The commands are shown in Table 5-3:

Table 5-3:  protocol commands

Command logcat
switch Purpose

clear lid For callers with log credentials, this clears the specified log's buffers

getLogSize lid Get maximum size of log specified by lid

getLogSizeUsed lid Get actual size of log specified by lid

setLogSize lid Set Maximum size of log specified by lid

getStatistics lid For callers with log credentials, this retrieves statistics - # of log
messages by PID, etc.

getPruneList Get prune list (all logs)

setPruneList Set prune list (all logs)

shutdown Force daemon exit. Surprisingly, this doesn't require any credentials.

The commands in gray require the caller to possess log credentials - be root, possess a primary
GID of root, system, or log, or a secondary GID of log. To verify the last case the code of  uses
a crude method, of parsing the caller's /proc/pid/status and sifting through its "Groups:" line.

Writing to logd (logging)

Android's logging mechanism is supplied by , and therefore applications remain 
oblivious to the underlying implementation of logging. As of L, both Bionic and  can be 
compiled to use  (by ing ), which then directs all the logging 
APIs to use  rather than the traditional /dev/log device files, which have, in effect, become 
legacy (and apparently removed in M). Effectuating the change is a simple matter, since all system 
logging APIs eventually funnel to 's  (or Bionic's 

), which then open the  socket (instead of /dev/log), and write the log 
message to it. Figure 5-4 shows the flow of log messages from the application all the way to . A 
similar flow occurs for event log (android.util.EventLog) messages.

���

&KDSWHU�9��'DHPRQV

http://developer.android.com/reference/android/util/EventLog.html


Figure 5-4: The Android logger architecture

Reading from logd (logcat)

The familiar  command in L still sports the same command-line arguments it has in the
past. Its underlying implementation, however, has rewritten to use  through an updated

 API. Clients such as logcat can connect to the logd reader socket (/dev/socket/logdr), and
instruct the  instance of  to provide the log by writing parameters to it, as shown
in the following table:

Table 5-4: Parameters recognized by  over the reader socket

Parameter Provides
lids=value Log IDs

start=value Start time from log to dump (default is EPOCH, start of log)

tail=value Number of lines from log to dump (as per  command)

pid=value Filter by PID originator of log messages

dumpAndClose Tells reader thread to exit when log dumping is done

Log records are serialized into a  structures before being passed to the
reader over the socket. The structure format is shown in the following figure:

Calling Application

JNI

liblog

android.util.Log

android_util_Log.cpp

d(tag, msg)

priority=DEBUG

e(tag, msg)

priority=ERROR

i(tag, msg)

priority=INFO

v(tag, msg)

priority=VERBOSE

w(tag, msg)

priority=WARN

println_native(LOG_ID_MAIN, priority, tag, msg)

liblog

__android_log_buf_write(bufID, priority, tag, msg)

write_to_log(filedes, vector, count)

/dev/socket/logdw

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Figure 5-5: The format of a  message

Putting all the above together, we can now observe  in action, through the 
command, as shown in the following experiment:

 Experiment: Observing 

Using  will allow you a behind-the-scenes look at the workings of  - including
its connection to , the command it sends to dump the log, and the serialization of log
messages:

Output 5-7:  under , annotated

Sifting through 's thread to find and trace the  thread instance will
show you the logging from the perspective of , and is left as an exercise for the reader.

���

&KDSWHU�9��'DHPRQV

# Tracing logcat during an adb logcat operation shows messages are received
# from file descriptor 3, and sent to file descriptor 1 (stdout)

root@generic:/# strace logcat
...
connect(3, {sa_family=AF_LOCAL, sun_path="/dev/socket/logdr"}, 20) = 0
write(3, "stream lids=0,3,4", 17)       = 17  # Dump main, system, crash
...
# \16 = 14 bytes (payload). \30 = 24 bytes (header). T\1 = 340 (PID) ... \3\0\0\0 = System
recvfrom(3, "<\16\30\0T\1\0\0m\1\0\0\275bbT$+\2374\3\0\0\0\6Act".., 5120, 0, NULL, 0) = 3668
write(1, "E/ActivityManager(  340): ANR in"..., 5472) = 5472
# In case you missed the connect(2) call above (e.g. if attaching to logcat), you can still
# look through its /proc/..fd entry, to see file descriptor 3 is a socket - which you can 
# also deduce from the use of recvfrom(2):
root@generic:/# cd /proc/$LOGCAT_PID/fd
root@generic:/proc/337/fd # ls -l | grep "3 "
lrwx------ root     root              2014-11-11 14:24 3 -> socket:[2442]
# Looking through /proc/net/unix, which shows domain sockets, we can find the socket 
and its remote endpoint (next inode number) - which happens to be logdr
root@generic:/proc/337/fd # grep 2442 /proc/net/unix
00000000: 00000003 00000000 00000000 0005 03  2442
root@generic:/proc/337/fd # grep 2443 /proc/net/unix
00000000: 00000003 00000000 00000000 0005 03  2443 /dev/socket/logdr



vold

The Android  is a volume-management daemon. This concept, which originally appeared in
the (now deceased) Solaris operating system, employs a user-space daemon to automatically mount
file systems ("volumes") as they are detected by the kernel. Beginning with HoneyComb,  also
enables file system encryption, in particular /data. Listing 5-7 shows its definition in /init.rc:

Listing 5-7: vold definitions in /init.rc (KitKat)

 is the only daemon to have an  attribute, which specifies an I/O priority for the
service.

 and  share a common codebase in the form of , which is statically compiled
into both binaries. The  provides file system mounting and checking functionality, by
wrapping together system calls (such as ) and hard-coded calls the external binaries
(/system/bin/e2fsck) together.

Configuration

True to a mount daemon,  requires a configuration file, to list known file systems and their
mount points. This file is referred to as the file system table, or fstab, for short. Prior to 4.3, it
was called /system/etc/vold.fstab, and mapped the file systems by their block device paths, in /sys.
As of 4.3, however, the file has been moved to the rootfs, and has been made device specific by
renaming to /fstab.${ro.hardware}, similar to the device specific .rc files. It has also been formatted
along the lines of classic UN*X fstab files, like so:

Listing 5-8: Post 4.3 /fstab.${ro.hardware} syntax

You may remember we encountered the /fstab.${ro.hardware} file in the discussion of how /init
mounts file systems.  evaluates the file in a similar manner to /init (using the shared 
code), but whereas /init ignores lines with the ,  concerns itself with these lines
only. The  field, though incorrectly specified in the documentation as being ignored, is
passed verbatim to the  system call. The options are parsed by :

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Init.html#mounting


Table 5-5:  options

Option Purpose
wait Wait for file system to mount for up to 20 seconds before continuing

check Perform a file system check on the file system prior to mounting

nonremovable Volume is not a removable volume (i.e. not an SD-Card)

recoveryonly File system only mounted during recovery

noemulatedsd Tells vold this is not an emulated SD card. If vfat-formatted, ASEC can be used

verify As of KitKat: Enable the Linux kernel's dm_verity to cryptographically verify the
filesystem integrity (described in Chapter 8)

zramsize= Compressed RAM (ZRAM) size

swapprio= Specifies priority of partition as swap partition

length= Denotes the size of the partition

voldmanaged= Partition is managed by vold. Expects tag:number with partition number or "auto"

encryptable= Specifies the location of the keys for an encrypted partition

forceencrypt L: encrypt on first boot

Architecture

The  internally comprises three components:

: Responsible for maintaining volume state, and handling various volume
operations. This (singleton) class provides all the framework-facing functionality.

: Responsible for listening on kernel NetLink events of the
subsystems using the , which passes them to the volumeManager.

: Responsible for listening on the /dev/socket/vold socket, for commands
issued by the framework, and relaying the output of those commands, or other events
received from .

Figure 5-6 presents the structure of :

Figure 5-6: The internal architecture of 

���

&KDSWHU�9��'DHPRQV

file:///Users/morpheus/Documents/Android/Book/Security.html#DiskVer


The main client of  is , though applications
cannot call this service directly, and must instead use .
The  maintains a  which uses the client side of the
socket to send commands to 's . Most Android devices have a vdc utility,
which you can use to send these commands to vold yourself (as root), or listen to file system
mounting events (using ), as shown in Output 5-8:

Output 5-8: The  output generated by SD-Card events

The  utility is nothing more than a tiny UNIX domain socket client, whose source can be
found in system/vold/vdc.c. The commands, which it relays verbatim to , are shown in table 5-
9:

Table 5-6:  commands

Cmd Subcmd Arguments Purpose

dump Dumps loop, device mapper, and mounted
filesystems

volume

list List mounted volumes

debug on|off Toggle debug messages for
formatting/unmounting

mount path Mount a file system

unmount path[force[_and_revert]] Unmount a file system, possibly forcefully

[un]share ums Share/unshare USB Mass Storage

shared ums Return share state (enabled/disabled) of USB Mass
Storage

mkdirs path Make a directory/mount point

format [wipe] path
Format a FAT volume, optionally erasing its
contents first

storage
users List PIDs using a mounted volume (like )

mountall Call on fs_mgr to mount all filesystems in fstab

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

root@htc_m8wl:/ # vdc monitor
[Connected to Vold]
# SD-Card inserted
605 Volume ext_sd /storage/ext_sd state changed from 0 (No-Media) to 2 (Pending)
605 Volume ext_sd /storage/ext_sd state changed from 2 (Pending) to 1 (Idle-Unmounted)
630 Volume ext_sd /storage/ext_sd disk inserted (179:128)
630 Volume ext_sd /storage/ext_sd disk inserted (179:128)
605 Volume ext_sd /storage/ext_sd state changed from 1 (Idle-Unmounted) to 3 (Checking)
613 ext_sd /storage/ext_sd "8A07-A343"
614 ext_sd /storage/ext_sd
605 Volume ext_sd /storage/ext_sd state changed from 3 (Checking) to 4 (Mounted)
# SD-Card removed
632 Volume ext_sd /storage/ext_sd bad removal (179:129)
605 Volume ext_sd /storage/ext_sd state changed from 4 (Mounted) to 5 (Unmounting)
613 ext_sd /storage/ext_sd
614 ext_sd /storage/ext_sd
605 Volume ext_sd /storage/ext_sd state changed from 5 (Unmounting) to 1 (Idle-Unmounted)
631 Volume ext_sd /storage/ext_sd disk removed (179:128)
605 Volume ext_sd /storage/ext_sd state changed from 1 (Idle-Unmounted) to 0 (No-Media)



Table 5-7:  commands (cont.)

Cmd Subcmd Arguments Purpose

asec

list List all Android Secure Storage containers

create cid mb fstype key uid Create new asec with cid, as a filesystem
fstype of size mb

destroy cid [force] Destroy the asec identified by cid, possibly
forcefully

finalize cid Finalize container cid.

fixperms cid gid filename Fix permissions in container cid so as to be
owned by gid.

mount cid key uid Mount the container cid under app-id uid, with
key.

unmount cid [force] Unmount the container cid, possibly forcefully
if in use.

path cid Return the path to the container cid.

rename old_cid new_cid Change the name of old_cid to new_cid

fspath cid Return file system path corresponding to cid

obb

list List all mounted opaque binary blobs

mount filename key ownerGid mount the opaque binary blob specified by
filename for app ownerGid, with optional key

unmount source [force] unmount the opaque binary blob specified by
source filename

path source

cryptfs

restart Signal  to restart frameworks

cryptocomplete Query if filesystem is fully encrypted

enablecrypto inplace|wipe password Encrypt filesystem, possibly erasing first

changepw default|password|pin|pattern
new_passwd Change encryption password

checkpw passwd Check if supplied password can mount
encrypted fs

verifypw passwd Used by 

getfield name Get metadata field from cryptfs

setfield name value Set metadata field in cryptfs

fstrim do[d]trim Issues an  , allowing mmc
driver to wipe unused blocks

Android L removes support for xwarp commands, a relic of older versions of Android, which
used YAFFS. With the move to Ext4, this has been deprecated, and the commands, while they still
exist through KK, fail on missing file requirements.

Of particular interest is 's filesystem encryption handling. The Android Documentation1

provides a detailed explanation of the process as implemented in Honeycomb, as does this book,
next. 

���

&KDSWHU�9��'DHPRQV

file:///Users/morpheus/Documents/Android/Book/FileSystems.html#asec
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#obb
http://source.android.com/devices/tech/encryption/android_crypto_implementation.html


Decrypting filesystems

With Honeycomb, Android brings support for disk encryption. By extending Linux's 
mechanism, which already provides the foundation for the  mechanism, Android enables the
entire user data partition to be encrypted. The system partition still remains very much cleartext,
because the system has to somehow boot, but this is quite fine - The system partition is, for all
intents and purposes, identical on all devices, and never actually holds any user-specific data, so
there would be little advantage in encrypting it.

The  feature is described in more detail in Chapter 8. At a high level view, however,
suffice it to say that  transparently encrypts and decrypts block devices. The password
required for doing so, however, needs to be supplied in user mode. Android derives the passcode or
pattern the user is already using for the lock screen*, and uses the

 activity to prompt the user for the credentials required
to unlock the device, without which  cannot be mounted.

What follows, therefore, is a choreography between  (driving the system startup), 
(providing the actual mount services), and  (handling the UI displayed to the user).
This is shown in Figure 5-7:

Figure 5-7:The interaction between  and 

During boot,  calls on the  to mount the file systems. If none are encrypted, iW�
sets the  to "unencrypted" and enqueues any actions associated with the�
"nonencrypted" trigger - usually those services in the  class.

** - The Android Explorations blog2 shows how to decouple the encryption password from the pattern, by using 
.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#dmcrypt
file:///Users/morpheus/Documents/Android/Book/note1
http://nelenkov.blogspot.com/2012/08/changing-androids-disk-encryption.html


If a file system is encrypted, however, an encrypted mount will obviously fail, unless the
password is supplied. The  mounts the filesystem instead as a tmpfs, and returns 1 to ,
which sets  to "encrypted", and informs  of the need to decrypt /data (by
setting  to 1). Prior to kitkat,  would use the value of the

 property as mount options, but these options are now hardcoded.
The mounting of /data is a prerequisite for loading the UI frameworks, since those need to write
various files. As a temporary filesystem, however, the /data mount holds no data. When the

 is set, the  only runs the "core" apps and services.

The  activity registers itself as the home screen
(using an ), with a higher priority, so as to ensure it starts first. When it loads, it
checks the value of  in its . If unset, it simply exits, making room for
the "real" home screen. If the filesystem is encrypted, however, the  start an async

 in its  to contact the ,
calling its  to see if the partition is indeed properly encrypted.

Recall, that the  is connected to the  socket. It can thus send the daemon
the  command. This makes  check if the encryption is indeed
recoverable (as it may be that the encryption has been interrupted, rendering /data unmountable,
and forcing the user to do a recovery/reset). If the  operation is successful, the

 calls setupUi to input the user for the decryption password or sequence. It passes
this again to , which sends it to  as a  command.

If the password is correct, the  sends the  command. This
makes  update the  property to , and sleep for 2
seconds in the hopes that all the services loaded under the  class will be stopped, and the
tmpfs /data can be unmounted. If the unmount is successful,  remounts the (now unecrypted)
/data partition, and again updates the  property - first to 
(since those reside in /data), next to  (to get  to set up any paths in
/data defined in /init.rc) and then to , which makes  restart
the frameworks. The properties must be defined in /init.rc to arm the approriate triggers, as shown
in listing 5-11:

Listing 5-9: Actions in init.rc relating to encryption events

���

&KDSWHU�9��'DHPRQV



Encrypting filesystems

Encrypting file systems is handled in a similar manner to decrypting them. Once again, the UI is
supplied by , with the  providing the Dalvik level bridge to . The
UI prompts the user for the encryption password, and verifies the device is on AC power, to prevent
any power outage which may disrupt the encryption. The 's 
method is called, which sends  the , with either  (to format
/data before encrypting it) or  argument, and the password.

Upon getting the command and verifying it can proceed,  sets the  to
. This causes  to stop all services but the core ones. This is

exactly the mirror image of the state the system is in while booting, before the user password is
entered, and /data can be safely unmounted.  then sets  to start at
0, and  to , to get  to restart the main
services.

Once again,  loads as the home app. Upon seeing ,
it loads the status bar UI.. If all goes well, the progress bar reaches 100%. If not,

 is set to an  string. L offers resumable encryption, but if
resumption fails the user may be left with no choice but to reset the device to defaults.

The technical aspects of encryption, as well as the kernel perspective, are discussed in Chapter 8.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#dataenc


Network Services

netd

Android uses a dedicated daemon to control network interfaces and configuration management.
If you've ever used tethering, firewalling or WiFi Access-Point features, or even a basic DNS lookup -
consider yourself a proud client of . The daemon is defined in /init.rc:

Listing 5-10: The  service defition in init.rc

The  shares many structural similarities with , and in fact shares some code with it,
using the native  class (among others) in its socket handlers. Figure 5-8
shows the architecture (which you can compare and contrast with that of , q.v. Figure 5-6).
Unlike , each of 's subcomponents uses a dedicated socket. 's structure comprises
four components, discussed next.

The : Responsible for listening on the /dev/socket/netd socket, for
commands issued by the framework (specifically, , described in
detail in the next chapter), and sending notifications (broadcasts) to connected clients. As with

, the emulator includes a simple utility -  - which can be used as a client to issue
commands to , and listen on events (using ), as shown in output 5-9:

Output 5-9: The  output generated by connecting to a Wi-Fi network

Internally, the  dispatches the commands to one of several internal
Controller classes, each responsible for a specific aspect of functionality, shown in Table 5-8:

Table 5-8:  controllers and their subcommands

Controller Commands Provided by Used for
BandwidthController /system/bin/ip[6]tables Network quota control

ClatdController /system/bin/clatd 464XLAT (IPv4 over IPv6) control

FirewallController /system/bin/iptables Firewalling

IdletimerController /system/bin/ip, ip[6]tables Idle timer on interfaces

InterfaceController /proc/sys/net/* Network interfaces

NatController /system/bin/ip, ip[6]tables Network Address Translation

PppController /system/bin/pppd VPNs

SoftapController /system/bin/hostapd Wi-Fi tethering/P2P

TetherController /system/bin/dnsmasq
/proc/sys/net/ipv4/ip_forward

USB and Wi-Fi tethering

���

&KDSWHU�9��'DHPRQV

root@htc_m8wl:/ # ndc monitor
[Connected to Netd]
600 Iface linkstate wlan0 up
614 Address updated 10.100.1.192/21 wlan0 128 0
614 Address updated fe80::522e:5cff:fef3:9da6/64 wlan0 128 253

file:///Users/morpheus/Documents/Android/Book/Services.html#f5-6
file:///Users/morpheus/Documents/Android/Book/Services-II.html#nms


���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



From the figure, you can see that the controllers (for the most part) don't actually provide any
functionality. Rather, controllers hide external commands, by calling  to spawn
the respective daemons or , in effect taking a shortcut. A full discussion of controller
internals, along with the daemon they spawn and the framework interface is left for Volume II.
Table 5-9 provides a quick reference to the command set expected by the various controllers:

Table 5-9:  commands understood by the various  controllers

Controller Subcommand Purpose

Bandwidth

Enable bandwidth quota control

iface qBytes Set quota on iface not to exceed qBytes

iface Remove any quota previously set on iface

iface qBytes
Generate alert if bandwidth on iface
exceeds qBytes

iface
Remove an alert previously set by

alertBytes
Generate alert if any interface exceeds
alertBytes

Get statistics for device tethering

bytes Set an alert on bandwidth bytes spanning
all interfaces

uid

uid
Add "Nice" (allowed) apps by UID

uid

uid

Add "Naughty" (misbehaving) apps by
UID

enable/disable

Firewall

Globally toggle the firewall functionality

Apply an iptables rule on an interface

addr rule Set rule for outgoing traffic, by source

addr port rule
Set rule for outgoing traffic, by
destination

uid rule Apply an iptables rule for a specific uid

IdleTimer

List all interfaces

iface
Enable Idletimer mechanism: 
starts and flushes iptables chains

iface timeout classLabel Add or remove a timer on iface

Interface

List all interfaces

iface default/secondary 

dest prefix gateway
Add a routing table entry

iface mtu
Set Maximum Transferrable Unit size on
iface to mtu

iface enable|disable Toggle IPv6 support on iface

iface Remove IP addresses of iface

iface Display configuration of iface

iface (ifconfig args) Set configuration of iface

Firewall marking (L: moved to fwmarkd)

���

&KDSWHU�9��'DHPRQV



Table 5-10:  commands understood by the various  controllers

Controller Subcommand Purpose

nat int_iface

ext_iface
Toggle Network Address Translation

PPP

tty local remote

[dns1] [dns2]

Attach PPPd to tty to set up a point-to-point
connection between local and remote IP addresses,
specifying optional name server IPs.

tty Execs 

List ttys used by the PPP daemon as interfaces

tether

Starts the DNS Masquerading

Stop Tethering: Kills  using a  signal

[set|list] Set or list DNS settings

[add|remove] iface Add/remove tethering on iface

enable|disable|status
Toggle IP Forwarding (/proc/sys/net/ipv4/ip_forward)
or query status

Resolver

iface Assign iface to be default for DNS lookups

Flush default interface's DNS cache

iface Flush iface DNS cache

iface pid Assign iface for process ID pid to use

pid Remove iface assignment for Process ID pid

iface

low high
Assign iface for AIDs low-high

Softap

Toggle Access point (by exec()ing or kill()ing
), or query status

iface AP|P2P|STA Reload firmware

iface SSID hidden/*

channel security key

Set access point parameters. If any other word but
"hidden" is specified, AP will be broadcast

 is the  responsible for listening on the
/dev/socket/dnsproxyd socket for name resolution commands. The commands are shown in the
following table:

Table 5-11: 's DNS Proxying command subset

Cmd Arguments Purpose

getaddrinfo
name service ai_flags
ai_family ai_socktype
ai_protocol iface

Call  for the interface iface. GAI is a more
advanced and forward compatible alternative to the other
getXXXbyYYY functions.

gethostbyname iface name af Perform a forward lookup (A/AAAA, according to af) of an IP
address by its hostname

gethostbyaddr addrStr addrLen
addrFamily iface

Perform a reverse lookup (PTR) of a hostname by its IP
address

Android's LibC implementation - Bionic - provides all processes with library calls matching those
in 5-11, and implements them by opening the UNIX domain socket connection to
/dev/socket/dnsproxy. In this way, all clients - both native and Dalvik - are redirected through the
DNS proxy functionality.  can then enforce restrictions on DNS functionality based the calling
process uid. Since each uid represents a different application, this translates to fine grained control
of DNS functionality on a per-app basis.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



mdnsd

Multicast DNS (mDNS) is a popular discovery protocol first adopted by Apple (as its "Bonjour"�
service). Standardized in RFC6762, it is used extensively in iOS's family of "Air" protocols (e.g.
"AirPlay"), and allows devices to find one another by sending a multicast request to group�
224.0.0.253 (or IPv6's FF02::fc) and UDP port 5353. Unsurprisingly, Android chose to adopt this�
VWDQGDUG as well, and it serves as the basis for "WiFi Direct". Beginning with JellyBean, /init.rc�
defines the mDNS service as follows:

Listing 5-11: The  service defition in init.rc

Because of its multicast capabilities, the service is granted membership in both the  group
(allowing general TCP/IP capabilities) and the  group (allowing "advanced" capabilities,
such as raw sockets and crafting non-standard IP packets). The service listens on /dev/socket/mdnsd
( ) for requests, and has another socket (/dev/socket/mdns) connected to

.

The frameworks wrap the mDNS functionality with the Network Service Discovery classes
( , as of API level 16). This is discussed in greater detail in Volume II, in a
chapter dealing with connectivity. The mDNS implementation itself (found in the
external/mdnsresponder directory) is largely the same as the open source mDNS project, with the
Android specific modifications (such as the UNIX domain socket and Android logging) clearly marked
by  blocks.

mtpd

Though the acronym MTP is normally associated in Android (and elsewhere) with the Media
Transfer Protocol, the  couldn't be further from it - It is the daemon responsible for PPP and
L2TP (but not IPSec). It is defined in /init.rc as follows:

Listing 5-12: The  service defition in init.rc

The group permissions granted to mtpd reflect its need for network access (inet) setting up a
network interface (net_admin), and tunneling IP (net_raw). As a  and  service,
the  must be started manually, by setting the  property. Indeed, the

 does so (in its  inner class).
There is no programming interface for VPN functionality, which is meant to be started or stopped
from the Android system GUI.

���

&KDSWHU�9��'DHPRQV



racoon

Racoon is a de facto standard VPN daemon. As an external project, it is not part of Android per
se, but is used extensively (in both Android and iOS) to provide VPN services (VPN connectivity is
discussed in Volume II).

Listing 5-13: The  service defition in init.rc

Note that  starts as root (in order to bind the ISAKMP well known port, which is a
privileged port), but then drops privileges. This is why it requires the extra group memberships,
which (as we discuss in Chapter 8) allow network connectivity. From a strict security standpoint, it
would have been better to relinquish root altogether, and use capabilities (in particular

) instead. This is especially important considering racoon has had a
history of exploits (and was in fact used to jailbreak iOS 5) before.

rild

If your Android device is a phone or 3G/LTE connected tablet,  is undoubtedly one of the
more important system processes. The Radio Interface Layer Daemon provides virtually all the
telephony capabilities for these devices, by interfacing with the baseband. It is defined in /init.rc as
follows:

Listing 5-14: The  service defition in init.rc

The  daemon supplied by the AOSP is an empty shell: After parsing its arguments, it seeks
out the vendor supplied RIL library, which can be defined by the  argument, specified in the

 property. The library is dynamically loaded, and its initializer - exported as
 is called. The initializer returns the library's exported RIL handlers, which are then

registered, before the daemon goes into its event loop.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#paranoid


Though most users don't give this a passing thought, the telephony APIs used in today's mobile
devices aren't that far from the modems employed in the previous millenium. In fact, the low-level
call control is still carried out with the same set of commands used by modems - the "AT"
commands - which may be familiar to anyone who's ever used minicom and kermit back in the day.
The  is responsible for opening the telephony device (which is basically a serial port) and
generating these commands. The daemon also listens on the device for "unsolicited commands",
which are events generated by the baseband - for example, an incoming call.

Figure 5-9: A bird's eye view of the Radio Interface Layer architecture

As shown in the figure and definition, the  daemon uses the /dev/socket/rild, to provide the
interface by means of which the phone application can connect to the daemon, and issue various
phone-related solicited requests (e.g. dialing, answering, hanging up) to the baseband. The 
also uses the socket to propagate baseband generated events (e.g. incoming text, calls) to the
application as unsolicited requests. The socket is not meant to be used directly, and is wrapped by
the Java RIL implementation (  package).

The daemon also listens on another UN*X domain socket - /dev/socket/rild-debug: As the name
implies, this socket is intended for use in debugging, and is undocumented save for the source of
the  of . It defines a set of codes, which will cause requests to be
artificially injected into the RIL. (You can find a detailed discussion of the codes in Volume II).

Additionally,  also has its own debug facility - radio - which results in a dedicated logging
device - /dev/log/radio. Inspecting this log file using  will dump plentiful amounts
of debug information, which may (in some versions of Android) show the "AT" commands used by

 to dial numbers and establish codes.

The Radio Interface Layer is described in greater detail in Volume II, along with the Java
telephony frameworks, and the reference RIL code from the AOSP.

���

&KDSWHU�9��'DHPRQV



Graphics and Media Services

Android's graphics and media services are integral to provide the best user experience possible.
This section provides a cursory glance, with a far more detailed discussion of their internals deferred
to Volume II for both audio and Graphics.

surfaceflinger

The  provides the heart of the Android Graphics Stack. The notion of a
"flinger", or in other words, a "compositor", is a component which merges one or more layers of
input into a single layer of output. In the case of , the components are graphics
"surfaces" (instances of ), which are either rendered by the framework as
the user lays out various views, or by the developer, in the case of raw or GL Surfaces. To
communicate with the , the framework looks up the SurfaceFlinger service using

. The flinger therefore needs no sockets, and its definition in /init.rc is simple:

Listing 5-17: surfaceflinger definition in /init.rc

Though certainly deserving of a deeper discussion (and the focus of the graphics chapter in
Volume II), 's place in the Android Graphics architecture can be conceptually
grasped at a high level in the following (somewhat simplified) diagram:

Figure 5-10: A high level view of 's functionality

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



bootanimation

The  service is a small binary in , which is exclusive used by
 as a placeholder while it (and the media frameworks) are loading. It is defined in

/init.rc thus:

Listing 5-18:  definition in /init.rc

The binary is essentially a very simple one - it starts up and looks for one of three zip files:

/system/media/bootanimation-encrypted.zip: Used if the  property is set,
indicating the file system is encrypted.

/data/local/bootanimation.zip: Allowing the (advanced) user to drop their own animation file
via . If present, this will override the system boot animation.

/system/media/bootanimation.zip: System default animation, usually supplied by vendor

The three files are tried in order, and if none of them can be found,  defaults
to alternating between two images - android-logo-[mask|shine].png, both hidden in the /assets/images
folder in the /system/framework/framework-res.apk (you can easily see the png files yourself if you
pull the framework-res.apk to your host and unzip the file).

What makes  interesting is its raw (i.e., non-framework) graphics capability.
Since it is one of the first services to load, the frameworks have yet to initialize, leaving

 to fend for itself using low level OpenGL and SKIA calls. These result in direct�
access to the device's frame buffer (/dev/graphics/fb0), which is why is iW run under uid graphics (the�
owner of the device node). We take a closer look at the low level graphics calls in Volume II.

Using low level calls and direct write operations to the framebuffer also enables
 WR�override  even when it is active, as you can 

verify�by running  via adb shell on your device. The device likely has it by 
default,�WKRXJK�\RX�FDQ�DOZD\V�XSORDG�LW�IURP�WKH�HPXODWRU�LPDJH�
 Running  when�your device is active will hide your display behind the boot 
animation - either completely (in� portrait mode) or partially (in landscape mode). Touch 
screen input will still work - but you'll�OLNHO\�QRW�EH�DEOH�WR�VHH�ZKDW�\RX
UH�GRLQJ��XQWLO�\RX
Hxit (by using ).

Most device vendors will provide a bootanimation.zip with their logo or, in some cases, the
carrier's logo. Likewise cyanogen and other Android "mods" deploy a zip of their own. Such zip files
must contain a desc.txt, and an assortment of images which  will cycle through.
The first frame can be made to overlap with the ROM bootup image, if any, ensuring a smooth
transition into the animation.

Note that some vendors may drop the default binary in favor of their own animation and
accompanying sound (e.g. as Samsung has done, with /system/bin/samsungani and proprietary qmg
files). Alternatively, they may change the implementation to look at other directories (e.g. HTC One
M8, looking for hTC_bootup_one.zip and vendor_boot.zip in /system/customize/resource). The Kindle's
"FireOS" is somewhere in between, retaining the bootanimation binary, but modifying it to display
the "Kindle Fire" logo rather than that of Android.

���

&KDSWHU�9��'DHPRQV



The book's website3 contains miscellaneous boot animations you can experiment with on your
device. Try dropping them into /data/local (searched before /system/media and see how easy it is to
replace the boot animation. Make sure the zip file is readable (if running bootanimation from adb as
user shell), or else the animation will default to the "A N D R O I D" console text.

 Experiment: Determining files used by bootanimation

In devices like the Nexus 5, boot animation is in /system/media/bootanimation.zip. You can pull
it to a host using , and inspect its contents like so:

Output 5-10: bootanimation.zip example

The first line of the desc.txt specifies, in order, the width, height and frames-per-second (fps)
of the boot animation. Note this is consistent with the dimensions of the individual .png files.

On other devices, however, figuring out the bootanimation files might require a little bit of
reverse engineering on your part. Fortunately, using  even the most complicated

 binaries will yield their secrets. For example, consider the following output, from
an HTC One M8:

Output 5-11: Figuring out files used by HTC's 

As the above shows, the HTC One's animation is customized per carrier (in this example, a
Verizon phone). Replacing the /system/customize/resource/vzw_bootup.zip, or adding
/system/etc/customer/bootanimation.zip (searched first) will modify the boot animation.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

morpheus@Forge (~)$ adb pull /system/media/bootanimation.zip
1275 KB/s (1068873 bytes in 0.818s)
morpheus@Forge (~)$ unzip -t bootanimation.zip
Archive:  bootanimation.zip

OK    testing: desc.txt
OK    testing: part0/
OK    testing: part0/000.png
OK    testing: part0/001.png

..
    testing: part1/059.png            OK
# After unzipping:
morpheus@Forge (~)$ cat desc.txt
1080 230 24
p 1 0 part0
p 0 0 part1
morpheus@Forge (~)$ file part1/000.png
000.png: PNG image data, 1080 x 230, 8-bit/color RGB, non-interlaced 

# Using strace: -f: to follow forks and threads (since binary may be multi threaded)
#               -o: to save output to a local file
#
shell@htc_m8wl:/$ strace  -f -o /data/local/tmp/out /system/bin/bootanimation
# 
# Let the bootanimation run, watch logo, then hit CTRL-C.. and sift through output
#
shell@htc_m8wl:/$ grep open /data/local/tmp/out |
|                 grep -v /dev | grep -v /proc | grep -v /lib
...
21217 open("/system/etc/customer/bootanimation.zip", O_RDONLY) = -1 ENOENT 
21217 writev(4, [{"\5", 1}, {"zipro\0", 6}, {"Unable to open '/system/etc/"..., 88}], 3) = 95
21217 open("/data/data/com.htc.CustomizationSetup/files/boot_anim_mns", O_RDONLY) = -1 ENOENT
21217 open("/system/customize/CID/default.xml", O_RDONLY) = 10
21217 open("/system/customize/resource/vzw_bootup.zip", O_RDONLY) = 10
...

http://newandroidbook.com/files/bootanimations/


mediaserver

The  is one of Android's most important components. It serves as a focal point
for multimedia handling, controlling both playback and recording. It is defined in init.rc as follows:

Listing 5-19: mediaserver definitions in /init.rc

As can be seen from the group membership,  requires permissions for audio,
camera, network services, and the DRM framework (described next). The , however,
is really just a container for the actual services, somewhat like the concept of a service host
(svchost.exe) in Windows. Table 5-12 shows the services hosted:

Table 5-12: The  services

Service Published Name Provides

AudioFlinger media.audio_flinger Audio playback. The service gets one or more PCM audio
streams as input, and "flings" them into a merged stream.

AudioPolicyService media.audio_policy Audio policy. Informs  of the volume setting
and target audio device

CameraService media.camera Camera services. Its main client is the camera app,
whether the Android supplied one, or the vendor's

MediaPlayerService media.player Playing audio and video.

KitKat's  lays the groundwork for extensions, by providing a
 function, though at present no extensions are defined. We discuss the

services in more detail in Volume II.

 Experiment: Debugging  through the  service

A useful debugging feature in  is that, upon startup, it checks the value of the
property . If set, it forks the  instance as a child of the

 ( ) process, which (by virtue of parenthood) collects resource
usage statistics on the  itself. This can be shown in the following annotated output:

Output 5-12: Starting the  service using 

You can then view the  lifecycle and resource usage using 
, and call .

���

&KDSWHU�9��'DHPRQV

# Make sure property check exists in the binary (note: Crude, may yield false positive)
root@htc_m8wl:/ # grep ro.test_harness /system/bin/mediaserver
Binary file /system/bin/mediaserver matches
# Set the property
root@htc_m8wl:/ # setprop ro.test_harness 1
# Kill the media server
root@htc_m8wl:/ # kill -9 $mediaserver_pid
# Et voila! media.log is now the parent of mediaserver
root@htc_m8wl:/ # ps | grep media
media     19122 1     20548  6444  ffffffff b6edaab0 S media.log
media     19123 19122 59876  9520  ffffffff b6edb26c S /system/bin/mediaserver
root@htc_m8wl:/ # service list | grep media.log
0 media.log: [android.media.IMediaLogService] 



drmserver

Android provides a Digital Rights Management (DRM) framework for copy-protected content,
and the  is the component responsible for being the focal point of all DRM requests. It is
defined in /init.rc like so:

Listing 5-20: drmserver definitions in /init.rc

In truth, to say that Android provides a "framework" is somewhat of a misnomer, since it
defines just the APIs, but not any actual content verification logic. The actual work is left for vendors
to implement by a plug-in architecture. The plug-ins are shared object files, loaded by enumerating
/vendor/lib/drm, and /system/lib/drm. The  is thus quite small, consisting only of a main()
with a few lines , which register a  ( ) with the
ServiceManager, and call on its internal  class to service incoming DRM calls from the
framework, by finding the appropriate plug-in for the content.

Output 5-13: Viewing DRM plugins on a Galaxy S3

To be considered valid and called by the DrmManager, a plug-in must conform to the
 interface specification defined in IDrmEngine.h. A more detailed explanation of the

specification, including an examination of DRM message flow using a PassThru module, can be
found in Volume II.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

shell@android:/ $ ls -l /vendor/lib/drm
/vendor/lib/drm: No such file or directory # No vendor specific DRM modules
1|shell@android:/ $ ls -l /system/lib/drm

     root-- root     root        48336 2012-05-2
     root-rw-r--r-- root     root       117224 2012-05-21 
     root
     root
     root
     root
     root
     root

-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root
-rw-r--r-- root

-- root     root        68944 2012-05-
-- root     root        48604 2012-05-21 1
-- root     root        65312 2012-05-
-- root     root        48212 2012-05-2
-- root     root        65012 2012-05-21 17:
-- root     root        64836 2012-05-2

file:///Users/morpheus/Documents/Android/Book/$ANDROID_SRC_ROOT/L/frameworks/av/drm/libdrmframework/plugins/common/include/IDrmEngine.h


Other Services

The remaining services in the main class are somewhat difficult to group, as they provide
different facets of system support. Nonetheless, that does not make them any less important.

installd

The  daemon is responsible for package installation and removal. Whichever way a
package is installed - by downloading the .apk directly, via Google Play or via  -
installd gets involved in the process. The daemon itself, however, is passive, listening on a socket
set up by init, over which commands (generated by the Android framework) are delivered. The
socket is defined in the daemon's /init.rc service definition:

Listing 5-21: installd definition in /init.rc

Startup

startup of  proceeds as shown in Figure 5-11:

Figure 5-11: Startup of the  daemon:

initialize_globals Read environment variables and deduce
directory structure from them

initialize_directories Set up directory structure, migrate to multi-user

drop_privileges Give up UID/GID 0, but maintain some capabilities

android_get_control_socket Acquire socket from init

listen Put into listening mode, backlog of 5

accept Block until a client requests a connection

readx Read a request from a client

execute Fulfill client's bidding, no questions asked

Upon startup, the  is charged with setting up and maintaining the directory structure
where apps are to be installed. The base name is obtained from the  environment
variable, set up by init to be /data. To this base,  appends  (app/),

 (app-private/),  (app-lib) and  (media/).

���

&KDSWHU�9��'DHPRQV



 also obtains two other environment variables -  (pointing to
/system) and  (pointing to /data/asec). Once it has deduced its directory
structure, it proceeds to initialize the directories - making sure they exist (as /data initially starts up
empty on factory default). As of Jellybean,  is also charged with migrating the directory
structure to allow multi-user. The steps taken are as follows:

Create the /data/user directory, with ownership  and mode 

Create a symbolic link from /data/user/0 to /data/data

Upgrade /data/media to /data/media/0, moving any preexisting media there

Create a /data/media/## directory for any other existing users

Move OBBs from /data/media/0/Android/obb to /data/media/obb so they can be shared
amongst users, and reduce overall filesystem usage

Ensure user media folders (/data/media/##) exist and are  .

Though it is started as root, as of Jellybean, the  employs the principle of least
privilege. One of the first calls it makes is to , which sets the uid/gid to

. It also makes use of Linux capabilities (q.v. Chapter 8) to maintain ,
/  and DAC override, as it needs them to deploy and remove packages

owned by different user and group ids.

Finally, installd acquires the control socket (/dev/socket/installd), and enters an accept loop,
waiting for connections from client. Once a client forms a connection, an inner read/execute loop
handles this connection until it closes (meaning that  can only handle only one client at
any given time). An interesting observation is the  doesn't perform any verification of
"caller id" on the socket, and relies on the socket being chmod()ed to 
. Because only one client can be served at a time, there is the implicit assumption that it is held by

the . Note also, that  performs no signature verification on APKs,
assuming that its caller has done so already.

Commands

The framework uses the , via the undocumented
 class, to provide a Dalvik-level API trusted applications

can use in order to install or remove the various apps. The API methods are mapped to the
commands sent over the socket (as strings, preceded by a two byte binary length),which are shown
in Table 5-13:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Security.html#capabilities


Table 5-13: Installd commands (L commands in green)

Command Arguments Use

ping Null command, used for connectivity

install pkgname uid gid seinfo
Install package specified by pkgname under
uid/gid with SELinux context specified by
seinfo

dexopt apk_path uid is_public Optimize dex file of APK, creating an .odex
file

movedex src dst Rename DEX file specified by src to dst.

rmdex pkg Remove DEX file of package specified by pkg

remove pkgname, userid Remove package specified by pkg installed
under uid.

rename oldname newname Rename package from oldname to newname

fixuid pkgname uid gid Fix package pkgname so it is owned by
uid:gid

freecache free_size Free cache so it has free_size bytes left.

rmcodecache pkgname uid Remove code cache of package pkgname
owned by uid from cache.

rmcache pkgname uid Remove package pkgname owned by uid
from cache.

getsize pkgdir uid apkpath Return the size of the directory specified by
apkpath

rmuserdata pkgname uid Remove user data used by package
pkgname owned by uid.

movefiles Execute scripts in /system/etc/updatecmds

linklib pkgname asecLibDir uid Link native library to its real location

mkuserdata pkgname uid userid Creates data directory for package (owned
by id for user userid), and installs symlinks

mkuserconfig uid Ensure that /data/misc/user/uid directory
exists.

rmuser uid Remove user uid

idmap target overlay Runs /system/bin/idmap.

restorecondata pkgname seinfo uid Restore seinfo on pkgname owned by uid.

patchoat
apk_path, uid, is_public, pkgname,
instruction_set, vm_safe_mode,
should_relocate

Patch OAT file to relocate it in memory.

The phases of package installation, along with the  service, are both discussed in
Volume II.

���

&KDSWHU�9��'DHPRQV



Code Constant
1 [STATE_]NO_ERROR

2 [STATE_]LOCKED

3 [STATE_]UNINITIALIZED

4 SYSTEM_ERROR

5 PROTOCOL_ERROR

Code Constant
6 PERMISSION_DENIED

7 KEY_NOT_FOUND

8 VALUE_CORRUPTED

10-13 WRONG_PASSWORD_[0123]

14 SIGNATURE_INVALID

keystore

The keystore service is, as its name implies, provides a storage service for keys. By design, it
can provide storage for any arbitrary name-value pairs, though in practice it is only used for key
storage. It is defined in /init.rc as follows:

Listing 5-22: installd definition in /init.rc

The argument to the keystore daemon - /data/misc/keystore - is the directory used to hold the
various keystore files. As of Jellybean, each user has its own keystore directory, with the primary
user using /data/misc/keystore/0. The keystore password of the user is stored (encrypted with a
derivative of the lock screen authenticator) in a .masterkey file, and per-app keystores are in files
following the AID_xxxxx convention.

Unlike other daemons, and as of 4.4, keystore no longer uses a socket. It is accessible only via
, wherein it is published using the name . The

framework client of the  service is the  class. This is a
developer-accessible class modeled after the Java standard, and is reasonably documented4, but not
fully so: There are quite a few other public methods available, which the Android documentation
chooses to omit. The  command allows partial command line native-level access to
the keystore. Table 5-14 shows the commands exposed by the class and service, showing the
commands not implemented by the cli as grayed.

Response codes are defined in system/security/keystore/include/keystore/keystore.h and mapped
to error strings by  as follows:

Table 5-14: Keystore error codes 

Access to keys is governed by uid (hence its use as an argument), so each application
effectively has its own private store.In addition, similar to the ACLs hard coded in , the�

 daemon maintains a  array of permissions, with specific exclusions for�
 (all access),  and  (get, sign and verify only). The  user�

is actually the most restricted, with 
get
 being the only operation allowed (in practice, though, it's a
simple matter to  to ).

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://developer.android.com/reference/java/security/KeyStore.html


Table 5-15: keystore commands, exported by 

1 Test keystore daemon is active

2 Get value corresponding to name

3 Insert a name/value combination into keystore belonging to uid,
with flags

4 Delete name (and value) from keystore belonging to uid

5 Check if name exists in keystore belonging to uid

6 List all keys beginning with prefix in uid's keystore

7 Reset (wipe) keystore

8 Change keystore password to password

9 Lock keystore, requiring password to unlock

10 Unlock previously locked keystore by supplying password.

11 Check if keystore is empty.

12

Generate a private/public keypair in keystore owned by uid
under name. The key can then be used to sign and verify, or
retrieve the public key - but the private key will remain
inaccessible.

13 Import key specified in data blob into keystore owned by uid
into key name.

14 sign data with key corresponding to name without actually
retrieving key.

15 Verify signature on data using key specified by name

16 Get a public key associated with name

17 Delete key identified by name in keystore belonging to uid

18 Grant uid access to key name

19 Revoke access to key name to uid

20 Get modification time of name

21 Copy the key specified by srcKey in keystore belonging to srcUid
to keystore owned by destUid under name destKey.

22 Return integer specifying whether or not keyType is backed by a
hardware keystore implementation

23 Clear keystore for user uid

24 Reset keystore for uid

25 Sync keystore for uid

26 Set password for uid

���

&KDSWHU�9��'DHPRQV



 Experiment: Interfacing with 

The following experiment (if carried out incorrectly) can potentially lock you out of
your keystore. It's therefore recommended to try it on an emulator image, rather

than on a real device - at least until you feel confident

You can call on the the keystore service either through the  utility, or directly
through . Considering not all of its commands are (at the time of writing)
implemented, it can make more sense to use 
with the specific numeric codes and arguments instead. Output 5-14 demonstrates this in a "split-
screen" like view:

Output 5-14: Using  and  to interact with the keystore service

As table 5-16 shows, however, there is a large command subset you cannot call through
. You can the grayed commands in the table by invoking them through their

numeric code, passing arguments using the  utility's  and  specifiers.

Output 5-15: Generating a key directly through 

The keystore implementation (over a Hardware Abstraction Module and/or possibly a hardware
component) is discussed in Volume II.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

# Note root is not allowed access to the keystore
...# keystore_cli test                      service call android.security.keystore 1
test: Permission denied (6)                 Result: Parcel(00000000 00000006   '........')
#
# SU to system to gain full control
...# su system 
...$ keystore_cli test                      service call android.security.keystore 1
test: No error (1)                          Result: Parcel(00000000 00000001   '........')
#
# Set keystore password to be "123", then lock keystore
...$ keystore_cli password 123 service call android.security.keystore 8 s16 123
password: No error (1)                      Result: Parcel(00000000 00000001   '........')
...$ keystore_cli lock                      service call android.security.keystore 9
lock: No error (1)                          Result: Parcel(00000000 00000001   '........')
#
# Attempt to unlock with bad password: System will count down attempts (errors 13,12,11,10)
# then reset (return UNINITIALIZED followed by SYSTEM_ERROR) 
...$ keystore_cli unlock bad service call android.security.keystore 10 s16 bad 
unlock: Wrong password (4 tries left) (13)  Result: Parcel(00000000 0000000d   '........')

system@generic$ service call android.security.keystore 12 s16 name1 \  # Name
i32 13       \  # Len
s16 hello    \  # Value
i32 -1 i32      # UID (-1 = caller)

Result: Parcel(00000000 00000001   '........')
# 
# Attempt to retrieve value from keystore
system@generic$ service call android.security.keystore 2 s16 name1
Result: Parcel(
  0x00000000: 00000000 0000000d 00000005 00650068 '............h.e.'
  0x00000010: 006c006c 0000006f 'l.l.o... ')



debuggerd[64]

Try as hard as developers will, their applications will inevitably face bugs, which will result in
crashes. In order to fix those bugs, there must be an efficient mechanism to collect the crash data.
On a desktop system, the crash results in a core dump - but that is simply not an option in a mobile
device. Core dumps are often very large - in the hundreds of MB and sometimes more - and space is
limited. What more, even if the core dump were saved, it's not a trivial matter to move such large
files out of the device.

Similar to iOS's CrashReporter, Android introduces . This small daemon is normally�
dormant, sleeping on its socket, until an application crashes. All processes on Android, WKDQNV� WR�
WKH�$QGURLG�OLQNHU, automatically install a signal handler for the lethal signals, shown in table 5-16:

Table 5-16: Signals caught by debuggerd

Signal Full Name ample
Illegal Instruction Illegal machine opcode

Debugger Trap Breakpoint

Voluntary Abort Assertion failure

Bus Error MMU fault

Floating Point Exception Division by zero

Segmentation Violation NULL pointer dereference

Broken Pipe Termination of process on read end of pipe

All signals use the same action, , which establishes a
connection to  over its socket, and sends it a message. The message wakes up the
daemon, and causes it to engrave a tombstone. A tombstone is, essentially, a crash report, which

 generates by attaching to the failing process (using Linux's  APIs), catching
its signal for it, and inspecting its memory. This way, rather than a full core dump, a tombstone can
(hopefully) capture the essence of a crash and perform the basic crash processing. Tombstones are
created in /data/tombstones.

If the  property is set to the uid of the crashing process,  freezes
the process in its final death throes and waits for user to start . It logs a message which
can be easily seen in :

Listing 5-21: Android log messages emitted by 

pid

pid

The  uses the low level Linux  APIs (discussed in Volume II) to wait until the
user presses one of the keys, and lights up the debug (red) led on the device to draw the user's
attention.

On 64-bit systems, an instance of  is also spawned, in order to handle the
different instruction set, memory layout and ABI. We discuss debugging in general and tombstones
in particular, in Volume II.

���

&KDSWHU�9��'DHPRQV

file:///Users/morpheus/Documents/Android/Book/2.do
file:///Users/morpheus/Documents/Android/Book/2do


sdcard

Not all Android devices necessarily support SDCards - but in those which do, the sdcard daemon
provides the user-mode support, including the enforcement of permissions on the otherwise
permission-less FAT filesystem. This is accomplished by using a mechanism known as FUSE (File
systems in USEr mode). The mechanism registers a stub filesystem in the kernel, and passes all of
its calls to the user space daemon - in this case, . Using FUSE allows for much more
flexibility and stability than implementing a filesystem in kernel mode. The complexity involved with
filesystem code, coupled with the untrustworthiness of possibly (potentially maliciously) corrupted
structures make FUSE a good choice for relatively infrequently accessed filesystems. (There is a
significant performance impediment involved in a kernel to user mode and back to kernel mode
traversal, which makes FUSE somewhat of a poor performer in other cases).

Figure 5-12 shows the flow of a file system request from a user mode client to the kernel, its
redirection via FUSE to the SD card daemon, and back to the originating client.

Figure 5-12: To there and back again: The SDCard daemon and its operation, via FUSE

The  daemon accepts the command line parameters shown in the following table:

Switch Purpose
-u uid Specify user id to run as, for ownership of the filesystem. Usually 1023 ( )

-g gid Specify JURXS id to run as, for ownership of the filesystem. Usually 1023 ( )

-l path Specify path to real mountpoint of the filesystem

-t # Specify number of threads (default is 2)

-l Specifies mount is a legacy (emulated) mount

-d Derive permissions from path

-s Split permissions for media, av, etc

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



After processing the command line parameters,  opens the /dev/fuse node, (to
communicate with the kernel driver), and then calls the  system call to perform a FUSE
mount, specifying hard coded options to the system call: /dev/fuse

fd gid.
Once privileges are dropped (to the /  specified GIDs), the daemon calls the aptly named

 and enters a message loop, to handle incoming requests from the /dev/fuse fd.

The SD card filesystem, as provided by the daemon, was discussed in Chapter 2. The following
experiment further exemplifies the flow of the SD Card filesystem requests, via FUSE.

 Experiment: Observing 

Android devices use the  daemon whether or not they have an actual SDCard. The
/data/media directory is mounted via an  daemon instance as /mnt/shell/emulated. If the
device also has a physical SDCard, its filesystem is also mounted, though this requires an
additional instance of the daemon, as shown in the following output:

Output 5-16: Viewing FUSE filesystems mounted with 

Observing  in action is a tad trickier, however. The method demonstrated time and
again in this chapter - the all powerful  - can be used in this case as well, but tracing the
main thread will likely show nothing. Any one of 's threads may be serving the FUSE
requests, which means you'll first need to see which threads were created, via
/proc/$SDCARD_PID/task, and then use  on them. (The handy  won't be of use here
since the threads were created prior to the  attachment). A good experiment is to use two
adb sessions - one to trace the  threads in, and another to try operations on the FUSE
mount (e.g. ). Doing so will show you data passing to and from the  file
descriptor, as the client's requests are, in effect, proxied by the daemon, which translates them
into the underlying system calls - for example in the following output, demonstrating the trace of
executing :

Output 5-17: Tracing  through 

���

&KDSWHU�9��'DHPRQV

# 
# Use mount to view all mounted file systems, but isolate only FUSE ones
#
shell@htc_m8wl:/ $ mount | grep fuse
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023, ...
/dev/fuse /storage/ext_sd fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,     ...
#
# busybox's ps applet will show you the full command line (or you can cat -tv /proc/.../cmdline)
#
shell@htc_m8wl:/ $ busybox ps | grep sdcard
 844 1023 0:02 /system/bin/sdcard -u 1023 -g 1023 -l /data/media /mnt/shell/emulated
1599 1023 0:10 /system/bin/sdcard -u 1023 -g 1023 -w 1023 -d /mnt/media_rw/ext_sd /storage/ext_sd 

# Get stat() request from client
read(3, "8\0\0\0\3\0\0\0?P\1\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 262224) = 56
# perform stat() on underlying file system
lstat64("/mnt/media_rw/ext_sd", {st_mode=S_IFDIR|0770, st_size=32768, ...}) = 0
# relay to client
writev(3, [{"x\0\0\0\0\0\0\0?P\1\0\0\0\0\0", 16},  .....   = 120
# Get getdents64() request from client
read(3, "P\0\0\0\34\0\0\0?P\1\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 262224) = 80
# perform request
lseek(5, 0, SEEK_SET)                   = 0
getdents64(5, /* 60 entries */, 4200)   = 2216
# relay to client
writev(3, [{"0\0\0\0\0\0\0\0?P\1\0\0\0\0\0", 16}, 

{"????\0\0\0\0\n\0\0\0\0\0\0\0\7\0\0\0\4\0\0\0Android\0", 32}], 2) = 48

file:///Users/morpheus/Documents/Android/Book/FileSystems.html#sdcard


zygote[64]

Though last, both alphabetically and in this chapter, the  is hardly the least of all
services. It provides the core support for all of the Android Framework Runtime services, in the form
of an initialized empty Dalvik Virtual Machine, stopped just shy of the main class loading. The /init.rc
definition is as follows:

Listing 5-22: Zygote definitions in /init.rc

As the listing shows, zygote's "true name" is . The name "zygote" however, is far
more apt, as this process mimics, in some senses, its namesake. Just like the biological zygote, this
process is full of unlimited potential - it can load any Dalvik class specified, and can become any
user. This, however, is a one-way process (again, just like the biological parallel). The rest of the
command line provides the arguments, all of which but the double-dashed get passed directly to the
Dalvik VM. The last two arguments get processed by app_process itself, and result in the VM loading
the  class, and ing to start the  process.

The  process (discussed in detail in next chapter) goes on to load all of the
Android runtime frameworks, whereas the  binds its socket (/dev/socket/zygote) to listen for
incoming requests. When such requests will arrive, they will contain a class name to load, and
Zygote will similarly  and load the classes - which will result in the creation of a new app. A
new "Life" will be born. But all these apps, and indeed zygote itself, are, from the Linux perspective,
merely instances of , which renames itself accordingly (and you can verify with an 

pid ).

Because  can specialize into potentially any process, it must leave all its options open.
Because of that, it maintains its root privileges, and an unlimited set of capabilities. Prior to forking,
however, Zygote drops all privileges, and then calls  to assume the AID of
the app in question. Because all this happens prior to loading any app code (both VM and native),
this setup is considered secure. It has, however, suffered in the past from vulnerabilities (e.g.
Froyo's Zysploit, due to not checking 's return value), and more recently (2013) from a
fork-bomb denial of service attack.

Further, it follows that all apps must be spawns of Zygote - the only exception to that are direct
invocations of  from the command line (for example, by the upcall scripts mentioned
in Chapter 2). You can verify that for yourself by looking at the output of  on your device:
Processes will either be offspring of  (PID 1), as holds for all the daemons discussed in this
chapter, or Zygote spawn, in which case some other PID will be the PPID - and you can bet the PID
is that of Zygote.

The rationale behind Zygote

At this point, you might be asking yourself why go to all this trouble, just in order to load a new
app. But it turns out that the effort invested yields plentiful dividends, in not one but two ways:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services-II.html#system_server
file:///Users/morpheus/Documents/Android/Book/FileSystems.html


Application startup time is greatly decreased: Regardless of actual app, all virtual
machines need to be initialized in the same, deterministic way. The class loading of the app is
the final stage of this process, but the real overhead is in the loading of the multitude of
runtime classes which make up Android's rich frameworks. If you imagine the app loading to
be a race, of sorts, using Zygote enables Android to "camp by the finish line", and run the
last leg of the race - which is relatively short, reducing load time by orders of magnitude.

Memory sharing is optimized: Because all virtual machines fork from Zygote, they can
take advantage of implicit memory sharing performed by the kernel. Specifically, though each
instance of  has its own virtual memory, the majority of that memory - being
read only (class code) - can be backed by only one physical copy in RAM. The rest of the
memory (class data, read write) - can be backed by additional pages only when absolutely
necessary (a technique known as copy-on-write). thus, most of Android's apps implicitly
share 80-90% of their memory with other apps (and with , which is the first
real instance of a full VM). This maximizes memory usage and allows quite a few apps to "fit"
in RAM, even on relatively low memory devices. You can see an example of this if you skip
ahead to Output 7-14, in a hands on experiment showing the use of the  and

 utilities, which provide memory usage diagnostics.

It is Zygote's unique design, which has enabled it to triumph where Java has failed. There are
additional optimizations in the Virtual Machine architecture itself (for example, keeping reference
counts separate from objects), but those merit a deeper discussion from the programmatic
perspective, which is left for Volume II. Likewise, the step by step walk through of application
startup can be found there.

The approach is not without some drawbacks: As we discuss in Chapter 8, forking all the
applications from the same binary effectively undermines Address Space Layout Randomization
(ASLR), which is an important layer of security against code injection attacks. That said, the needs
of the many outweigh those of the few, and so performance trumps security. Recent academic
research has proposed Morula5 (another biological term, resulting from Zygote division) as an
alternative architecture, which may address ASLR shortcomings, but that has yet to make its way to
Android.

With the move to the Android RunTime (ART), Zygote's architecture becomes even more
efficient, as all of the preloaded classes are also precompiled. That, however, complicates matters
somewhat, because 32 and 64-bit layouts are not compatible.

Zygote 32 and Zygote 64

With the move to 64-bit computing on the one hand, and the need to retain 32-bit compatibility
on the other, Android now has to maintain not one but two versions of Zygote. In a 64-bit
architecture, the "secondary zygote" is a 32 bit process, which is started by an instance of

. Because the primary (i.e. 64-bit) zygote instance holds the zygote socket, the
secondary zygote requires an additional socket. This is shown in listing 5-23:

Listing 5-23: Zygote32 definitions in /init.zygote64_32.rc

User applications are entirely oblivious to which instance of Zygote they are using, though this
makes a difference in terms of which libraries are loaded - and therefore JNI. 32-bit Zygote
instances use /system/lib, whereas 64-bit ones uses /system/lib64. Inspecting the process address
space maps (by using pid ) will reveal the different mappings, as further
discussed in Chapter 7.

���

&KDSWHU�9��'DHPRQV

https://taesoo.gtisc.gatech.edu/pubs/2014/morula/morula.pdf
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#maps


Summary

This chapter covered the native services of Android, which are the daemon processes spawned
by init through the various  entries in the /init.rc files. The native processes are responsible
for various housekeeping operations, as well as providing the basic level of support for the system
frameworks.

The framework services, however, are another matter in entirety - Due to the large number of
services and the detail required, we leave that discussion for Volume II. Nonetheless, the next
chapter provides the preliminaries, by providing an overview of the service architecture, through an
elaboration on  and . It is the latter process which serves as the
container for all services, and the one which takes over the UI from the .

Files discussed in this Chapter
Section File/Directory Contains

adb
system/core/adb/

Implementation of adb, both client
and server

f/b/s/ja/com/and/ser/usb/UsbDebuggingManager.java
USB Debugging Manager server, used
by 

vold f/b/s/ja/com/and/ser/MountService.java
The Mount Service Manager, used by

debuggerd /system/core/debuggerd Source of debuggerd

installd f/native/cmds/installd Source of installd

bootanimation f/base/cmds/bootanimation/BootAnimation.cpp Bootanimation source

sdcard sys/core/sdcard/sdcard.c Source of sdcard

References

1. Android Full disk encryption:
http://source.android.com/devices/tech/encryption/android_crypto_implementation.html

2. Android Explorations: http://nelenkov.blogspot.com/2012/08/changing-androids-disk-
encryption.html

3. BootAnimation collection: http://www.NewAndroidBook.com/bootanimations/

4. Android Developer, Keystore Documentation:
http://developer.android.com/reference/java/security/KeyStore.html

5. Georgia Tech, "From Zygote to Morula":
https://taesoo.gtisc.gatech.edu/pubs/2014/morula/morula.pdf

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://source.android.com/devices/tech/encryption/android_crypto_implementation.html
http://nelenkov.blogspot.com/2012/08/changing-androids-disk-encryption.html
http://www.newandroidbook.com/bootanimations/
http://developer.android.com/reference/java/security/KeyStore.html
https://taesoo.gtisc.gatech.edu/pubs/2014/morula/morula.pdf


VI: The Framework Service Architecture

The previous chapter painted only a partial picture of the runtime services in Android. The
services detailed therein were all native-level processes - implemented in C/C++, and with no direct
programmatic interface from the Java layer. As such, they can be classified as services which
support the operating system itself. Applications, however, make use of an entirely different set of
services, provided by the Dalvik-level frameworks, with special interfaces. These services have a
Java language interface, and most of which run in the context of one process: system_server, and
are reachable with the help of .

Both  and  were introduced throughout the previous
chapter.  in the section dealing with core services, and  as a
subset of Zygote - i.e. started by zygote when the  argument is
provided. Both, however, deserve a much more in-depth investigation, as together they provide the
support and the context of the entire Android framework service architecture - which is what this
chapter discusses.

We begin by revisiting the service manager, which provides the role of an endpoint mapper
(that is, allows service location and invocation). The services make themselves visible to clients by
registering with , and from that point on clients may approach the

 and request a connection (or a handle) to the service. All framework services are
invoked in the same way, and this service calling pattern, is discussed next. In particular, two key
components are introduced - The Android Interface Definition Language, or AIDL, providing the
interface (or set of APIs) exported by the services, and the  utility, which allows the testing
and debugging of those interfaces from the command line.

The underlying transport for service (and, indeed, all inter-app) communication is Android is the
Binder mechanism, which is accessible to applications via /dev/binder. What looks like a simple
device node is, in fact, an elaborately designed IPC framework, which is charged with not only
dispatching messages, but also with passing around objects, descriptors, and more, as well as
providing reliability and security. This is discussed as we take a a closer look at service internals.

Lastly, we take a look at system_server itself, which functions as the service host process,
wherein most services* are implemented as threads. We detail the startup, operation, and internals
of this important process. As for the services themselves - they're detailed in the next volume of this
work.

* - A few notable exceptions are SurfaceFlinger and the media services. Note that application (3rd
party) services run in their own process.

���

file:///Users/morpheus/Documents/Android/Book/Services.html
file:///Users/morpheus/Documents/Android/Book/Services.html#servicemanager
file:///Users/morpheus/Documents/Android/Book/Services.html#zygote
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#servicepattern
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#aidl
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#binder
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#system_server


Revisiting servicemanager

If you recall from the previous chapter, one of the services classified by init in the "core" class is
the . The other key services are dependent on it, and must be restarted with it if
it crashes. Further,  is designated as critical, which means that init will agressively
attempt to restart it, or boot to recovery if it fails to do so.

The reason behind the utmost importanFH of the  is its function: It serves 
as�the locator, or directory, for all other operating system services. If any application or system�
component needs to use another service, be it what may, it must first consult the

 to obtain a handle. Similarly, services cannot expect clients until they register
their presence with it. It is for this reason that, if the manager is restarted, so must all of its
dependents - after all, restarting implies the service directory must be rebuilt from scratch, and
services thus need to register. It likewise follows that, if  cannot operate, Inter-
Process Communication (IPC) cannot subsist.

The IPC model of Android is discussed later in this chapter. For the moment, however, suffice it
to say that it is provided by a dedicated kernel component - the Binder. User-mode services access
the binder for IPC via a character device node - /dev/binder, which is readily accessible
(readable/writable) to all processes. Only one user-mode process at a time, however, can request to
register as a context manager with the Binder, however, and from that point on it becomes the
focal point for all other processes - both clients, and servers. The servers must register their service
name and interface with the context manager, and the clients must consult the context manager in
order to lookup and find the service.

The  is therefore a pretty small binary, with a simple operation: a call to
binder_open obtains the /dev/binder descriptor, and a call to 
establishes its position. Thereafter, the  enters an endless , which
blocks on the descriptor, until a transaction (i.e. request from a client) occurs. This wakes process,
and calls its  callback, which processes the transaction.

The service lookup must somehow be bootstrapped - in other words, the 
should be globally accessible, so that services can register with it, and clients can look them up. At
the native level, services and clients alike can call on  to get a handle
to the service manager (technically, to its interface, as a ). The interface
(defined in IServiceManager.h) exposes a simple set of transaction request codes. Table 6-1 shows
the requests, as well as the native level calls which implement them. Note, that there is no API to
remove the service. Services are automatically removed when their proceeses die, because Binder
can detect that, and send a death notification.

Table 6-1:  requests and the programmatic methods to invoke them

Request Code API Notes

Used by servers to register themselves with the service
manager. Servers can decide whether or not they want
to allow isolated (sandboxed) processes to connect.

name Get a handle to the service specified by name.

Return a vector (list) of all services. Not used by the
framework, but used by .

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html#servicemanager


The  functionality is considered sensitive: UID 0 or �000 (AID_SYSTEM) can freely�
register services, but other system services are restricted. Up to and including KitKat, this is done by�
a hard coded  list, restricting registration, as shown in Table 6-2:

Table 6-2: Hardcoded service registration restrictions

AID_MEDIA media.audio_flinger, media.log, media.player, media.camera, media_audio_policy

AID_DRM drm.drmManager

AID_NFC nfc

AID_BLUETOOTH bluetooth

AID_RADIO radio.phone, radio.sms, radio.phonesubinfo, radio.simphonebook

AID_RADIO* phone, sms, iphonesubinfo, simphonebook

AID_MEDIA common_time.clock, common_time.config

AID_KEYSTORE android.security.keystore

* - These are legacy service names, deprecated by their radio.* counterparts

In Lollipop, the hard coded list is moved into the /service_contexts file of SELinux, which
provides a far more scalable way to control services - system_server.c code is simplified by a call to

, which then calls on . In this manner, service
registration and lookup can be enforced for all services, further allowing the device vendor to add
their own services, without the need to recompile any code.

Listing 6-1: The /VHUYLFHBFontexts SELinux policy file

The programmatic APIs are wrapped by the framework class
, which is further encapsulated in

. Apps aren't expected to use this directly, and instead call on
 in order to look up system services, and use intents for third

party services. Either way, communication with services - both system and third party - is performed
over binder messages, with the  serving as the service directory, as shown in
Figure 6-1:

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH



Figure 6-1: Registering and accessing Android framework services

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Using the  command to interface with service manager

Android provides the  command line utility as a simple interface for the service
manager. This simple utility also demonstrates how to use the programmatic APIs to query
services. Using  you can display all registered services, as well as their published
interfaces (discussed later in this chapter), and using , see if a given service can
be contacted.

Output 6-1 shows an output of  on a Nexus 5 Android L. Because you can
easily run this command on any device, the output is partial, highlighting only those services which
are new in L, or are not present in the emulator.

Output 6-1: Using  on an Android L Nexus 5

The output from the command may vary considerably between devices. Some differences are
obvious (for example, the Phone service will not be found on tablets), while others may be less so
(vendor specific services, or Android version specific).

The  interface defines a  method, which is used by the  command
to provide diagnostics on services. When invoked without arguments,  iterates over all
services in the same manner as , and dumps each in turn. In some cases,
additional arguments may be supplied, which vary with each service. Some services also expose a
"checkin" method, which can be used by  or .

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH

root@generic# service list
Found 93 services: # Emulator shows only 87 services, 75 in KK
11  # Not in emulato sip: [android.net.sip.ISipService
22 
33 
44 
55 
66 
77 
88 
99 
1010  
1111  
1212  
1313  
1414  
1515  
1616  

 phone: [com.android.internal.telephony.ITelephony
 iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo
 simphonebook: [com.android.internal.telephony.IIccPhoneBook
 isms: [com.android.internal.telephony.ISms
 nfc: [android.nfc.INfcAdapter]                 # Not in emulato
 telecomm: [com.android.internal.telecomm.ITelecommService]   # L
 launcherapps: [android.content.pm.ILauncherApps
 trust: [android.app.trust.ITrustManager]           # 
  media_router: [android.media.IMediaRouterServic
  tv_input: [android.media.tv.ITvInputManager]         #
  hdmi_control: [android.hardware.hdmi.IHdmiControlService]  #
  media_session: [android.media.session.ISessionManager]     #
  print: [android.print.IPrintManage
  assetatlas: [android.view.IAssetAtla
  dreams: [android.service.dreams.IDreamManage

..
2020  0
21
22

  voiceinteraction: [com.android.internal.app.IVoiceInteractionManagerService]2
    appwidget: [com.android.internal.appwidget.IAppWidgetService]
    backup: [android.app.backup.IBackupManager]
    jobscheduler: [android.app.job.IJobScheduler]  # L23

...

..
3838  
39
40
41
42
43
44
45

  ethernet: [android.net.IEthernetManager]    # Not in emulat
    wifiscanner: [android.net.wifi.IWifiScanner]  # L 
    wifipasspoint: [android.net.wifi.passpoint.IWifiPasspointManager] # L
    wifi: [android.net.wifi.IWifiManager]
    wifip2p: [android.net.wifi.p2p.IWifiP2pManager]
    netpolicy: [android.net.INetworkPolicyManager]
    netstats: [android.net.INetworkStatsService]
    network_score: [android.net.INetworkScoreService]  # L 

...
    bluetooth_manager: [android.bluetooth.IBluetoothManager]  # Not in emulator55

..
    display.qservice: [android.display.IQService]   # owned by SF,Not in Emulator87

#
# Use "service check" with one of above names to see if service is alive
#
root@generic# service check media.camera
Service media.camera: found

file:///Users/morpheus/Documents/Android/Book/SystemServer.html#callsvcs


The Service Calling Pattern

Android's framework services are implemented in  threads. Applications thus
need to rely on Inter-Process Communication (IPC) in order to invoke them. This is where the
Binder, Android's properietary IPC mechanism, comes into play. Applications need to call on the
Binder in their own process to obtain an endpoint descriptor, which is then connected to the remote
service. Methods can then be invoked through IPC messages, through a pattern known as Remote
Procedure Call (RPC).

IPC? RPC?

The terms IPC and RPC are often used interchageably, though not often correctly. Because
both terms are fundamental in the context of Android services, it's worth clarifying the
difference:

Inter Process Communication (IPC) is a blanket term for all forms of
communication between processes. These include various forms of message passing,
but also shared resources (most notably, shared memory), along with synchronization
objects (mutexes and the like), meant to ensure safety in concurrent access to shared
resources (i.e. prevent data corruption which occurs when two writers attempt to
modify the same data item, or race conditions between readers and writers).

Remote Procedure Call (RPC) is a specific term for a method of IPC, which hides the
actual communication inside procedure (method) calls. The client calls a local method,
which in turn is responsible for transparently handling the IPC with the remote server -
which may at times be on a different machine. The method serializes its arguments into
a message, which is then transported to the server's method, where the arguments are
deserialized, acted upon, and the same occurs (in reverse) for passing the return values
of the method, if any.

Thus, any RPC mechanism is also an IPC mechanism (the former being a special case of
the latter), but not vice versa. Android's service calling pattern implements RPC, as we discuss
and detail in this section. Table 6-3 compares the RPC mechanisms used in contemporary
OSes:

6-3: Comparison of RPC mechanisms in common operating systems

OS Mechanism Scope Directory Preprocessor Transport
UN*X SunRPC Local/Remote portmapper rpcgen UDP/TCP

OS
X/iOS Mach Local

(Remote)
launchd

(mach_init) mig Mach messages

Android Binder Local* servicemanager aidl /dev/binder

As shown in the table, all RPC mechanisms have common denominators, specifically:

scope: denoting whether the RPCs are used in between hosts (remote), or only on the
local host

Directory: The server providing the lookup functionality for locating services

Preprocessor: The tool used to generate the serialization and deserialization code for
messages

Transport: The medium for message passing

We revisit RPC and discuss it in far more detail when dealing with Binder.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Android developers remain blissfully oblivious to the underlying implementation of service
invocation. Instead, as most Android developers are familiar with, they are required to call on the

 method of the  object, which accepts the name of an Android
system service, and returns an opaque object. The object returned can then be type cast into the
specific service object, and the service methods can be invoked through it.

Figure 6-2 shows the general pattern followed by most service method calls. The figure is
somewhat simplified (for example, the system service handles are cached), but still presents the
flow. Services are registered, a priori, by the server process (commonly, , or a 3rd
party process), through a call to . Recall this class provides a Java
interface to the service manager. 

Figure 6-2: Android system service call pattern

Advantages and disadvantages

The system service architecture of Android follows a generic local client/server pattern, common
to other OSes, such as iOS. Though iOS has no Binder, it uses its own implementation of a message
passing architecture, called Mach messages. The role of  (i.e. the endpoint
matter) is assumed by 's  process, which (among other things) also handles the
traditional PID 1 roles that Android's /init does.

A disadvantage which quickly stands out in this architecture is the overhead of IPC, particularly
the need to serialize and deserialize messages, as well as the context switch required when
alternating between the processes. This disadvantage does have a noticeable performance impact.

* - Android's Binder is, by design, limited to a local scope. It's a fairly simple hack to set up a local proxy process to further
serialize and deserialize requests over a TCP or UDP socket, thus extending Binder's scope - a highly useful capability for a
Remote Access Tool (RAT).

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH



Given such a considerable disadvantage, it must be offset by advantages greater or equal in
magnitude - and indeed, it is: Aside from the cleaner design and separation of privileges which
follows, a client/server architecture gains security as a corollary. The client process - which is, by
definition, an untrusted user app, is entirely devoid of any permissions, and therefore relies entirely
on service calls to perform any operations. At the native level, this means that an app can be run
sandboxed, without any access to devices and datastores, if any. Indeed, this is the case in iOS
(wherein apps are "jailed"), though Android relies (for most processes) on filesystem permissions to
deny access.

The server processes are trusted, and expected to perform all security checks, ensuring the
client has the necessary permissions before agreeing to serve the request. Once again, the two arch
rivals are similar here, with iOS relying on entitlements, (embedded in the binary's code signature),
and Android on the application's Manifest file. In both cases, the permissions are declared outside of
the application's runtime scope - i.e. they can be verified when installed (or, in iOS's case, when
Apple vets the app), but cannot be modified by the App: Specifically, iOS's Entitlements are stored in
kernel space (as part of the cached code signature blob), whereas Android's permissions are
maintained by the .

Serialization and the Android Interface Definition Language (AIDL)

In design pattern parlance, the object obtained from  serves as a Proxy:
Internally, it holds a reference to the actual service, which it obtains over a Binder call. The methods
exported by the object are, for the most part, merely stubs, which take their arguments, and
serialize them into a Binder message, referred to as a . The methods and objects serializable
in this way are specified using AIDL. AIDL isn't really a language, per se. It's essentially a derivative
of Java which is understood by the  SDK utility, which is invoked in the build process when .aidl
files are encountered. The  automatically generates the Java source code required to serialize
any parameters into a Binder message, and extract the return value from it. The code is
"boilerplate" - i.e. it can be automatically generated from the definition files and is guaranteed to
compile cleanly. A sample .aidl file is shown in Listing 6-2:

Listing 6-2: A sample .aidl file

As you can see, an .aidl is somewhat similar to a header file, in that it defines methods (and
possibly objects), but not their implementation. As we explore the individual framework services
later in the book, you'll be able to see many more examples of actual .aidls from the AOSP.

The  tool does a marvelous job of hiding the implementation details of Android's IPC from
the developers. So great a job, in fact, that most developers remain blissfully ignorant of the role of
Binder, or its very existence. This work, however, recognizes the role of Binder, providing an
introduction to it later in this chapter, and discussing internals in Volume II.

Power users can remain equally oblivious to Binder, especially with a powerful tool like the
 utility, which enables the invocation of Android service methods right from the command

line. This is shown in the following experiment.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Using the  command to call services

A previous experiment demonstrated the basic usage of the  command line utility, as
a method of interfacing with the  process. The true power of ,
however, lies in its ability to call the services themselves.

Calling a service is a simple enough matter - using , and specifying the
service name and method number: Internally, methods are assigned numbers in order of their
appearance in the service's .aidl file. Depending on the method, optional arguments may be
supplied. The  utility supports two types of arguments: , which are integer values,
and , which are used for unicode strings. In practice, however, integers can be used for any
32-bit value (e.g. ), and strings - being unicode - can be used to serialize any object.

Any service retrieved by  (Output 6-1) with an interface (specified in
brackets) can be called on in this manner. Each interface has a corresponding .aidl file in the
AOSP, wherein its methods and their arguments are clearly defined. Once you have the
definitions, you can invoke any method of your choice, by figuring out its call number and passing
the appropriate arguments. A few of the interesting ones are shown in Table 6-4:

Table 6-4:  commands

service call... Interface Method Action
phone 2 s16 "foo"
   s16 "555-1234"

call(String callingPackage,
      String number);

Place a call to the specified
number.

statusbar 1 expandNotificationsPanel() Brings up notifications

statusbar 9 expandSettingsPanel() Brings up settings

statusbar 2 collapsePanels() Hides all panels

dream 1 dream() Screensaver (if configured)

power 10 (< 4.4.1)
power 11 (> 4.4.2) isScreenOn() Returns 0 if screen is off, else 1

The low level call numbers assigned to methods can change between Android
versions - even within the same API version (For example, 

and  within KitKat). It's rare, but could happen. Beware. In general, it's
a bad idea to rely on hard coded numbers - if creating a tool or app to use these private
APIs, compile them alongside the updated .aidl files

Invoking calls in this way will return a result in a Parcel (the Binder term for a message). Each
parcel contains, at a minimum, a 32-bit return value (0x00000000 indicating success, otherwise
some error value, commonly  or  if a call
number is outside the defined range). Depending on the AIDL definition, what follows is either an
integer value (i32), or a length specification, followed by an opaque object (usually, but not
necessarily, a string). Because , like Binder, has no idea of what the opqaue object is, it
will display the result in a manner not unlike the  command, with a hex dump of the message
contents, alongside an ASCII dump of it.

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH



Experiment: Using the  command to call services (cont.)

Only services with a published interface (specified in [brackets]) can be invoked. Note, not all
services will blindly lend themselves to this type of invocation: Depending on the security policy,
which is implemented differently by individual services, your service call request may be denied. If
that is the case, the output of  will contain a unicode error message, like so:

Output 6-2: Error messages returned from 

Once you get past permissions, however, (for example, by running as root), the possibilities
of using  in this manner are nearly endless, spanning all the features and
capabilities of the Android frameworks. As we cover the framework services in this work one by
one, we'll be showing their respective AIDL definitions, and number the calls accordingly.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

# Attempt to call cancelMissedCallsNotification(), which requires MODIFY_PHONE_STATE
# (You can get past this, as well as most other permission checks, by running as root)
#
shell@htc_m8wl:/ $ service call phone 13
Result: Parcel(
  0x00000000: ffffffff 00000050 0065004e 00740069 '....P...N.e.i.t.'
  0x00000010: 00650068 00200072 00730075 00720065 'h.e.r. .u.s.e.r.'
  0x00000020: 00320020 00300030 00200030 006f006e ' .2.0.0.0. .n.o.'
  0x00000030: 00200072 00750063 00720072 006e0065 'r. .c.u.r.r.e.n.'
  0x00000040: 00200074 00720070 0063006f 00730065 't. .p.r.o.c.e.s.'
  0x00000050: 00200073 00610068 00200073 006e0061 's. .h.a.s. .a.n.'
  0x00000060: 00720064 0069006f 002e0064 00650070 'd.r.o.i.d...p.e.'
  0x00000070: 006d0072 00730069 00690073 006e006f 'r.m.i.s.s.i.o.n.'
  0x00000080: 004d002e 0044004f 00460049 005f0059 '..M.O.D.I.F.Y._.'
  0x00000090: 00480050 004e004f 005f0045 00540053 'P.H.O.N.E._.S.T.'
  0x000000a0: 00540041 002e0045 00000000          'A.T.E.......  0x00



The Binder

The discussion so far has mentioned the Binder several times, but kept it a very high level
overview. Indeed, at a high level, suffice it to consider the Binder as a special type of a file
descriptor, which - through a dedicated kernel driver - is connected to the service. This is also how
Linux sees it, when the process is viewed through the /proc/pid/fd directory. Virtually every process
in the system (With the exception of a few native processes) opens a handle to /dev/binder.

Much of Binder's inner workings, however, are shrouded in darkness - probably because, for�
most developers, ignorance is bliss. For those who want to know the details, there is, after all,�
always the source. For the scope of this work, however, it's benHILcial to elucidate some of these�
dark cornerV and provide a closer view of Binder, explaining its functionality without going into 
the�(not so well documented) source.

A little history

The Android Binder mechanism traces its root back to the Binder of another mobile operating
system, BeOS. Binder served as the underlying support interconnecting BeOS's rich set of
frameworks. Once heralded as the "next generation operating system", BeOS never gained much
traction save for a few fans, and was eventually acquired by Palm. If the name doesn't ring a bell,
that's fine - Palm Pilots were all the rage back at the end of the last millenium, catapulting 3COM to
great heights before Palm was split off and spiraled back to earth. Palm was eventually acquired by
HP, and its OS served as the basis for "WebOS", another venture that fell far short of its promise.

Binder, however, survived. Besides being ported to PalmOS (and integrated into their Cobalt
architecture), it was also ported to other operating systems - including, of course, Linux. The Linux
port was open sourced (at http://openbinder.org/, and though the website seems to have died
since, some mirrors1 survived). The original developers left Palm to join Android, and brought Binder
with them. Chief amongst them was Dianne Hackborn, a well renowned developer and still one of
the major figures driving Android today. An interview she gave to OSNews2 back in 2006< explained
the fundamentals of OpenBinder.

Android's implementation of Binder is more specific than OpenBinder, and - just like as originally
intended in BeOS - serves as the fulcrum for all of its frameworks.

So, what, exactly, is Binder?

Binder is a Remote Procedure Call mechanism, allowing applications to communicate
programmatically, but without having to worry about how to send and receive messages. From the
application's perspective - server or client - all it needs to do is either call a method (client) or
provide a method (service). When the client calls the method, the corresponding method is
magically invoked in the service, with all the "details" handled transparently by Binder. These
"minutiae" include:

Locating the service process: In most cases, the client and the service are two different
processes (  notwithstanding). The Binder needs to locate the service
process for the client, so as to be able to deliver the message. This "location service" (also
known as "endpoint mapping") is technically handled by , as explained
previously, but the  is only responsible for maintaing the service directory,
mapping an interface name to a Binder handle. The "handle" is an opaque identifier, which
was given to the  by Binder, and which only Binder knows the "true"
meaning of - that is, the underlying PID wherein the service is located.

Delivering the message: As discussed previously, AIDL is used to generate the code which
takes the parameters of the called method and serializes them (i.e. packs them into a
structure in memory), or deserializes them (unpacks the structure back to individual
parameters). The passing of the serialized structure from one process to another, however, is
handled by Binder itself. Clients call the  , which sends the
message over Binder, and blocks until a reply is returned (hence, the code - first write, then
read).

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH

http://openbinder.org/
http://www.angryredplanet.com/~hackbod/openbinder/docs/html/
http://www.osnews.com/story/13674/Introduction_to_OpenBinder_and_Interview_with_Dianne_Hackborn
file:///Users/morpheus/Documents/Android/Book/SystemServer.html#ipcrpc


Delivering objects: Binder can be used to pass around objects - the service handles
mentioned previously are one such type of an object, but so are file descriptors (just like
UNIX Domain sockets). Passing around descriptors is an especially important feature, as it
allows a trusted process (such as ) to natively open a device or socket for
an untrusted process (such as a user app) - assuming the untrusted process has the required
permission (as specified in the App's manifest).

Supporting credentials: Inter process communication naturally has significant security
aspects. A recipient of a message has to be able to verify the identity of the sender, so as not
to be tricked into compromising overall system security. Binder is aware of its users'
credentials - PID and UID - and securely embeds them in messages, so peers can operate
with a reasonable level of security.

Using Binder

Binder is used in all applications, whether or not the developers themselves realize it. The code
involved in binder operates on no less than three levels, as shown in Figure 6-3:

Figure 6-3: Message flow between client and server using Binder

In an effort to be true to the power user's view adopted in this work, Figure 6-3 is as far as we
go - for now. More detail on the various levels - from the Java objects, through AIDL, native, and
kernel - can be found in Volume II.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Tracing Binder

The /dev/binder connection multiplexes any number of service connections over the same file
descriptor. This means that a process will hold that descriptor irrespective of whether it is connected
to one service, or to many. Indeed, a process can hold this descriptor and not be connected (yet) to
any services at all.

It follows, then, that there's no simple way to see exactly which services a given handle is
connected to. If the Binder debug functionality is enabled through the Linux debugfs filesystem
(/sys/kernel/debug/binder), however, you can use the  tool (on the book's companion
website) to figure out who's connected to what, as shown in the following experiment:

Experiment: Using the  tool to view open binder handles

The  tool, which you can find on the Book's companion website is nothing more than
a simple derivative of the  command, which obtains a handle to the system service of
choice (as does ), and then inspects its own entry in the
/sys/kernel/debug/binder/proc directory. Each process using binder has a pseudo-file containing
various statistics, and the  entries contained therein reveal the PIDs connected on the other
end. Because all the binder debug data is world readable, you can run this tool on unrooted
devices as well.

Output 6-3: Revealing binder endpoints using the  utility

The book's companion website also provides a special version of , the Linux system
call tracing tool, with augmented functionality that includes parsing of Binder messages (i.e.
deciphering  codes and payloads).

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH

#
# Inquire about wallpaper service 
shell@htc_m8wl:/ $ /data/local/tmp/bindump wallpaper
Service: wallpaper node ref: 2034

com.htc.launcherUser:  PID  1377 
User:  PID  1194 
Owner: PID  1008 
User:  PID   368 

com.android.systemui
system_server
/system/bin/servicemanager

#
# Who owns the batterypropreg service?
shell@htc_m8wl:/ $ /data/local/tmp/bindump owner batterypropreg
Service: batterypropreg node ref: 105785
Owner: PID  8153 /sbin/healthd

http://newandroidbook.com/files/bindump.tar


system_server

Android devices have dozens of services, and along with vendor and user-installed apps, this
number can exceed one hundred. Fortunately, the vast majority of framework services are simple
enough that they do not require their own process, and can instead run as threads. These threads,
however, need a host process to run in - and that is exactly what system_server provides.

Similar to Windows' svchost.exe, the  provides nothing more than a shell - a
container process. The two can also be compared in the sense that svchost.exe loads services
through dynamically linked libraries (DLLs), whereas  loads Java classes. In
Android, however, this is even more important a function: Though the Dalvik VM is optimized for
sharing, running services alongside one another in the same VM provides an even greater savings in
resources. This does not come without a bit of risk, however, as a misbehaving service can thus
affect its siblings. For the most part, though, this isn't much of a concern, as only Android's system
services, and not those of the vendor or additional apps, are allowed to run inside system_server.

The  is not a native app: It is implemented mostly in Java, with some JNI calls
in places where it must start native services. The services it loads are similarly implemented in Java,
though a great deal of them also rely on JNI to escape the virtual machine and interact with
hardware components. Zygote automatically starts the system_server when it itself is started by the
/init.rc (q.v. Figure 5-22) with the  switch. The switch makes Zygote
invoke , in which are hardcoded the arguments - capabilities, group
memberships ( ), the "nice name" (system_server), and the class to load -

. The  does not execute with root
privileges, but comes pretty close - uid:gid of , enhanced capabilities, and a host
of secondary group memberships. The security perspective of  - GIDs and
capabilties - is shown in Chapter 8.

Startup and Flow

For such an important fulcrum of the entire system, system_server has a rather simple flow.
Once it has forked off from Zygote, the child process drops its privileges, and toggles the capabilities
as discussed above. It then proceeds to load the class, whose  performs basic initialization
(notably lifting its VM limits and loading the  to perform JNI component
initialization), before instantiating the framework services. Once all services have been created (and
their corresponding threads spun), with nothing else to do the main thread enters a looper, to loop
(hopefully) endlessly (unless the system is shut down). The high level flow is shown in Figure 6-4,
on the next page.

There are numerous system services to start, however, and  needs to
instantiate them one by one. Android L takes great steps in refactoring this flow. Even though much
work remains, the flow is significantly simplified from previous version by grouping services of
similar classification. There are currently three "classes":

Bootstrap services: These include the , ,
, ,  and

. Additionally, a check is performed if the device's /data partition is
encrypted or in the process of encryption - which affects startup by starting only apps
designated as "core apps".

Core services: These include the , ,
, and the . The last is a new service in L

which periodically checks the browser component for any updates.

"Other" services: basically, everything else. There are dozens of services in this class
(which the source admits is "a miscellaneous grab bag of stuff that has yet to be refactored
and organized").

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html#f5-22
file:///Users/morpheus/Documents/Android/Book/Security.html#ss


Figure 6-4: The flow of system server

Not all the services are visible to applications: Some, like the  are internal, and thus
invisible both to apps as well as . We discuss all the services - internal and app
facing - one by one in the next chapters.

Once the services are started,  has nothing more to do in its main thread. The
thread therefore enters its looper, which hopefully loops indefinitely. We say "hopefully", since the
looper is not expected to exit, and will throw a runtime exception if it does. Internally, the loop
blocks, polling its file descriptors (and in particular, its Binder handle) for incoming messages. When
messages arrive, they are dispatched to their respective targets.

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH

file:///Users/morpheus/Documents/Android/Book/Services-II.html


Modifying startup behavior

The flow of  and the classes of services it starts can be modified by setting
certain system properties.

A key parameter is the  system property, which defines whether or not the
device is configured for a "factory test" mode, affecting the startup of  according to
the following values:

Table 6-5: Factory test values and their impact on startup

value #define Implies

0 (default) FACTORY_TEST_NONE Normal startup.

1 FACTORY_TEST_LOW_LEVEL

2 FACTORY_TEST_HIGH_LEVEL

Another important parameter is the  system property, which - if set - disables the
WallPaper service, and the System UI services. The  family of properties can also be used to
selectively disable subsystems, as shown in Table 6-6:

Table 6-6:  properties affecting system services

 Property Disables
disable_storage MountService

disable_media AudioService,WiredAccessoryManager, CommonTimeManagementService

disable_bluetooth BluetoothManagerService

disable_telephony Unused

disable_location LocationManagerService, CountryDetectorService

disable_systemui StatusBarManagerService

disable_noncore UpdateLockService, LockSettingsService, TextServicesManager,
SearchManagerService, WallpaperManagerService, DockObserver, UsbService

disable_network
NetworkStatsService,NetworkPolicyManagerService,WifiP2pService,
WifiService,ConnectivityService,
NsdService,NetworkTimeUpdateService,CertBlacklister

Thanks to the Linux /proc filesystem, you can examine system_server and its many threads.
Looking at its file descriptors is somewhat futile - it's impossible to tell which descriptors belong to
which thread - and most of them are sockets and pipes anyways. Enumerating the threads,
however, can be useful. This is shown in the following experiment.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

No bluetooth, input, accessibility, lock settings 

Uid 0 for factory test applications



Experiment: Unraveling the threads of system_server

Dalvik's thread objects may be named when created. Naming a thread calls the underlying 
system call - a little known but highly useful API which allows the renaming of threads and processes at the
kernel level. The name is then visible through the /proc filesystem in the status proc entry of the thread. The
method is not perfect, as it allows for only 16 characters in a name - but it sure beats rummaging through
random thread identifiers, trying to figure out which does what.

Using a basic script (which even Android's OLPLWHG shell supports) you can easily enumerate the threads, 
and� get their individual names (this works on any process, so as long as the  iterates over its task/ 
subdirectory,�which contains a directory entry for each thread). Binder threads and thread pools are omitted 
from this output:

Output 6-4: Iterating through threads

TIDs aren't normally predictable, but a large part of system_server's are started incrementally, and so looking at
the IDs can give you a sense as to the system's framework startup.

���

&KDSWHU�9,��7KH�)UDPHZRUN�6HUYLFH�$UFKLWHFWXUH

root@flounder:/proc/507/task # for t in *; do echo Thread $t  `grep Name: $t/status`; done
507: Name:  system_server     # The main thread (same as PID)
512: Name:  Heap thread poo   # L: ART Heap thread pool
514: Name:  Signal Catcher    # Dalvik signal catcher
515: Name:  ReferenceQueueD   # Dalvik Reference Queue Daemon
516: Name:  FinalizerDaemon   # Dalvik object finalizer
517: Name:  FinalizerWatchd   # Dalvik finalizer watchdog
518: Name:  HeapTrimmerDaem   # L: ART Heap Trimmer Daemon
519: Name:  GCDaemon          # Garbage Collector (L: "GCDaemon", for ART)
524: Name:  SensorService
525: Name:  SensorEventAckR
526: Name:  android.bg
527: Name:  ActivityManager
529: Name:  FileObserver      # FileObserver$Thread
530: Name:  android.fg
531: Name:  android.ui
532: Name:  android.io
533: Name:  android.display
534: Name:  CpuTracker        # Created by ActivityManager
535: Name:  PowerManagerSer   # Created by PowerManagerService
537: Name:  BatteryStats_wa
562: Name:  PackageManager    # Created by 
594: Name:  PackageInstalle   ##  PackageManage
596: Name:  AlarmManager      # Created by AlarmManagerService
597: Name:  InputDispatcher   # Started by InputManager

# Started by InputManager598: Name:  InputReader       
599: Name:  MountService      
600: Name:  VoldConnector     
602: Name:  NetdConnector     

# Created by MountService
# Created by MountService
# Created by ConnectivityManager

603: Name:  NetworkStats
604: Name:  NetworkPolicy
605: Name:  WifiP2pService
606: Name:  WifiStateMachin
607: Name:  WifiService
608: Name:  ConnectivitySer   # Created by ConnectivityManager

# Neighbor Services Discovery (State Machine Thread)609: Name:  NsdService
610: Name:  mDnsConnector     
611: Name:  ranker
613: Name:  AudioService      
622: Name:  UEventObserver    
623: Name:  backup

# Created by NsdService
# Created by NotificationManagerService
# Created by AudioService$AudioSystemThread
# Kernel uevent observer (shared by many services)
# Created by BackupManagerService

626: Name:  WifiWatchdogSta
627: Name:  WifiManager
628: Name:  WifiScanningSer
629: Name:  WifiRttService
630: Name:  EthernetService
634: Name:  LazyTaskWriterT   # ActivityManager's TaskPersister
635: Name:  UsbService host
844: Name:  watchdog
845: Name:  SoundPool         # AudioService$SoundPoolListenerThread
846: Name:  SoundPoolThread   # AudioService$SoundPoolListenerThread
906: Name:  NetworkTimeUpda   # NetworkTimeUpdateService's HandlerThread
984: Name:  IPC Thread
1009: Name:  WifiMonitor
1507: Name:  SyncHandler-0
1513: Name:  UsbDebuggingMan



Summary

This chapter discussed the Android framework service architecture, explaining the underlying
mechanisms of Inter Process Communication (IPC) through Remote Procedure Call (RPC) in Android,
focusing on the role of the  and the  utility. It then focused on the

 process, which serves as a host to Android's myriad frameworks, all implemented
in Java.

This naturally begs much more discussion - specifically, of the dozens of services, and of Binder
- the transport that facilitates RPC. This discussion, however, is left for Volume II.

Files discussed in this chapter

Component File Contains

ServiceManager
f/native/cmds/servicemanager/service_manager.c Body of service manager

frameworks/native/cmds/servicemanager/binder.[ch] Binder interface

SystemServer f/b/services/java/com/android/server/SystemServer.java The  class

References

1. OpenBinder documentation (mirror):
http://www.angryredplanet.com/~hackbod/openbinder/docs/html/

2. OSNews, Interview with Dianne Hackborn: http://www.osnews.com/story/13674/

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://www.angryredplanet.com/~hackbod/openbinder/docs/html/
http://www.osnews.com/story/13674/Introduction_to_OpenBinder_and_Interview_with_Dianne_Hackborn


VII  Android Through a Linux Lens

Android developers are accustomed to thinking about their applications in terms of the Android
lifecycles described in the previous chapter. From the Linux perspective, however, Android
applications are Linux processes, and aren't much different from any other process on the system.

This chapter puts that very perspective in focus. We first discuss the facilities Linux provides for�
process monitoring and tracing, through the /proc filesystem, which was touched on briefly in�
Chapter 2, but is now explored in the detail it deserves. We discuss the per-process and per-thread�
entries in /proc/pid which allow you to poll for real-time, on-the-fly statistics. First, we discuss the�
symbolic links that report working directories. We next focus on the highly useful fd/ and fdinfo��
subdirectories, which provides accurate representations of open file descriptors. Next up is the�
status entry, which gives a high level view of the process - and in particular, thread state and virtual�
memory.

Virtual memory is an important metric for diagnosing performance, so the next section focuses
on the basics of user memory management, going into theoretical concepts, but also presenting the
smaps proc entry, and two tools - procrank and librank - which you can use to get accurate memory
statistics. We then explain the dreaded Out-Of-Memory condition, the bane of Android's application
lifecycle, forcing the app to live in the shadow of ever-looming, and very unpredictable death.

Lastly, we explain system calls, showing the  tool, the proc entries of wchan and
syscall, and the all-powerful strace tool, which you can use for active tracing.

The chapter relies heavily on concepts from operating system theory, and is full of hands-on
experiments meant to further elucidate these concepts, which are far from trivial. The methods and
experiments shown in this chapter are all based on Linux kernel features, which makes them just as
applicable on a Linux system, as they are in Android - so you might consider referring to this chapter
for Linux Debugging tips, a subject on which there is a surprising dearth of books on.

���

file:///Users/morpheus/Documents/Android/Book/Anatomy.html#lifecycle
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#proc
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#symlinks
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#fd
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#fdinfo
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#status
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#threadstate
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#hlmem
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#memmgmt
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#oom
file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#syscalls


/proc, revisited

The /proc filesystem was touched on in Chapter 2. The touch was hardly a graze, however, as it
has not begun to scratch the surface of this extremely important filesystem. In particular, the per-
process (and thread) directories in /proc, with their plethora of real-time diagnostic information
about the inner workings of applications.

To understand the per process directories, think of a process as in object-oriented terms: A
process can be thought of as an instance of a process class, all instances of which have the same
properties - though naturally property values may differ. The pseudo-files in the per-process
directory simply show you the values of the properties, and - in some cases, if they are writable -
allow you to modify these properties.

Output 7-1 shows the entries the Android shell would see in its own directory (using  as the
process ID of the current shell - note we don't use /proc/self, because  would see itself!). The 
filter is optional, and is used only to improve readability.

Output 7-1: Annotated per-process entries in L (3.10 kernel).

Remember - none of these are actually files. This means two things:

The exact listing of the file may change, according to your kernel version. In general, the
newer the kernel, the more likely you are to have more pseudofiles, though support for some
of them may be disabled when compiling the kernel.

���

&KDSWHU�9,,,��6HFXULW\

file:///Users/morpheus/Documents/Android/Book/Filesystems.html#proc


The files aren't really there, until you ask for them: which means that every time you
display the files, you're likely to get different content. When using , the kernel doesn't
even bother reporting file sizes, which is why (if you try the above command without the 
filter, all file sizes are shown as 0.

The last point is a very important one to consider: Because the files are purely virtual, there is
no overhead in maintaining the /proc entries - the kernel maintains all these statistics anyway during
normal operation. All it takes is "faking" the existence of these files, and - when the user asks for
any - collecting the statistics in real time, and providing them in pseudo-file form. This makes the
/proc filesystem an extremely powerful mechanism for system and process tracing, provided the
method used is that of polling.

Tracing by polling means that the tracing program or script has to keep on explicitly asking for
specific /proc entries periodically, because /proc entries do not support on-change callbacks (at least,
not yet). This does have certain disadvantages - if the polling granularity is too coarse, you may end
up missing the exact event you were trying to intercept. But the advantage - zero overhead - clearly
outweighs the disadvantage. The human-readability and ease of parsing of the pseudofiles is
another clear advantage, as we demonstrate in this chapter.

Because kernels change so frequently, this unfortunately has the side effect of leaving the
documentation (  on Linux systems with  installed) somewhat outdated, and not all
these are properly documented. We next turn our attention to some of the more important of these
pseudo-files, which you can readily use when profiling or debugging the system.

The symlinks: cwd, exe, root

Looking at output 7-1, three entries immediately stand out - those of cwd, exe and root. The
reason they are different is because they are shown as symbolic links, whereas other entries are
shown as pseudo-files.

The rationale behind displaying these entries as symbolic links is readability. All three entries
point to files or directories, and by using symbolic links, it makes it easier for the user to apply a file
operation (e.g. , ) on the target of the link (which most commands follow
automatically), rather than have to first display the contents of a pseudo-file, then embed the output
into the next command.

The three entries give you the most important high-level statistics for the process, namely:

cwd - which displays the current working directory. In output 7-1, you could see from the
prompt that the shell's present working directory is /data - and that is exactly what the cwd
link is pointing to. A fun experiment is to  to any directory of your choice, then repeat the

. You will see that you can run, but youcan't hide - Any time you use
the query the cwd entry, the kernel retrieves the working directory at that moment, which
means you will always get the right directory.

exe - which displays the full path to the executable used to start this process (that is, the
one loaded by the  system call. This is useful because many processes can
change their name, as displayed in  during their lifetime, but they cannot change this
entry.

root - which displays the root directory. Normally, this will be the real root directory - (/). If
an application is ed, that is, confined to a subdirectory which is defined as its
new root, this will be clearly visible from this entry.

The cwd and root entries are used by tools such as fuser and lsof, which find open files and
directories by patname (fuser) or by process (lsof). Knowing this, it becomes a simple matter to
implement both these utilities as shell scripts, which could become quite useful on systems which do
not have these tools pre-installed. The following experiment shows how a similar shell script trick
can be used with the seemingly less useful exe entry.

���



Experiment: Determining the 32/64-bitness of Android apps

At first glance, an entry such as exe seems somewhat useless - after all, in most cases the
executable name isn't really expected to change during the process lifetime.. or is it?

It turns out, that's not always the case. A good example in Android are the various Dalvik
apps, spawns of Zygote, all changing their name to that of the loaded class they are executing.
This is done by changing the value of argv[0], using the  system call.
The real name of all these apps is still /system/bin/app_process, which is the "true" instance of the
VM which loaded them. In L this is even more useful, because 32-bit apps will be clearly visible as
app_process32, whereas 64-bit ones will be app_process64. The following example shows how you
can use that to your advantage in a shell script:

Output 7-2: Using the exe proc entry to figure out 32/64-bitness of an app

To understand the script better, note the pattern used:

1.  to the /proc directory: Because everything starts here.

2. Iterate over [0-9]* entries: The root of /proc contains additional files, alongside the per-
process entries. We want just the per-process directories, so we isolate only those entries
beginning with a digit. This will run a loop with  set to the PID iterator.

3. Perform check by looking at the exe /proc entry: Note the use of , with output
discarded ( ). We're only interested in whether or not there was output -

's implicit return value, which is what the  will branch by. Because there are
actually three cases here ( ,  or neither), we don't use
and /  construct, but two separate  statements.

4. Print out the user-facing output:: Using , taking advantage of its NUL-
separation, when employing , only argv[0] is printed. This is better than the comm
entry, since the latter is truncated at 16-bytes. Note also the use of  - our iterator, which
holds the PID (which shows the initial  was like Chekhov's Gun).

At first glance, the idea of running a script inline might deter some readers. That's
understandable, especially when considering the rigid syntax of shell scripting (which is why this is
an experiment - you're urged to try this at least once for yourself!). Remember, however, that
every inline script like that can easily be put into a file, ed  - thereby becoming a new
tool for you to add to your arsenal. The exact same pattern - iterating and ping - albeit
with different /proc entries - can be adapted to create custom, reusable tools, which will work
correctly both on Android and Linux systems.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



fd

A process performs all of its I/O through file descriptors. The files, pipes and sockets opened
- irrespective of language, Java C or other, all map to numbered file descriptors, with three default
ones - standard input (  and standard error ( ) - numbered 0, 1 and 2,�
respectively. When a process opens or creates a file (or socket, pipe, etc), the created object is�
linked to the next available descriptor. What appears to the process as a number is, in fact, a handle�
to an opaque object, that only has true meaning in the kernel, wherein that handle is deciphered as�
an index to an array of objects.

It is therefore of the utmost importance to be able to figure out which descriptors a process is
using in real time. There are quite a few tools for that - most notably,  (list open files), which
dumps open files per process along with other mappings. Rather than rely on , however (which
may or may not be present in a given distribution), it often makes sense to get the information
straight from the horse's mouth - that is, from /proc/pid/fd.

The fd/ subdirectory follows the same symlink convention as the cwd, exe and root entries
described in the previous section. This makes it extremely useful to just  a given PID's fd/
directory in order to figure out which files are in use. So useful, in fact, that this work demonstrated
the technique several times by now in previous chapters. It couldn't be simpler, but be aware that
listing descriptors does require root privileges if you are not the owner of the process (and, by
corollary, the /proc/pid/fd directory):

Output 7-3: Showing the file descriptors of a process (Zygote) through /proc/pid/fd:

For regular files, this works perfectly. The convention isn't as useful, however, when it gets to
sockets. Since sockets have no filesystem representation (some UN*X sockets notwithstanding),
there is nothing to symlink to. It would be trivial to add a fake symlink, which would contain a string
of the IP or domain socket in question, but at the time of writing the Linux kernel opts instead to
take the path of least resistance, and simply spit out the inode number associated with the socket.
You can see the socket numbers above, for descriptors 7, 10, 11 and 13. But where do these
sockets connect to?

Fortunately, there are other pseudofiles in procfs which will resolve this data for you. The
following experiment shows how to figure out sockets - both UN*X and IP:

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



Experiment: Resolving inodes to socket names through /proc/net

It's always possible to "cheat" and use a tool like  (but not the toolbox tool) to
automatically resolve all descriptors, including sockets, for you. But with a little bit more
knowledge of Linux procfs files, it's not that hard to do so on your own. The sockets in Linux and
Android are usually one of the following types*:

UN*X domain sockets: Used for local only communication. Some of these sockets are
named, i.e. they have a filesystem representation. In practice, these are not really files -
domain sockets are in-memory kernel constructs, and the filename is used to ensure
system-wide uniqueness. In Android these sockets are located in /dev/socket, with an
additional type of sockets using "@" naming conventions, which do not appear on the
filesystem. Other sockets may remain unnamed. The kernel keeps the domain socket
statistics in /proc/net/unix

IP based sockets: Over IPv4 and/or IPv6. Linux (and Android) differentiates between the
two address families, and further differentiates by protocol type - udp or tcp. As a
consequence, there are thus no less than four files to consult - tcp6, udp6, tcp and udp.

Netlink sockets: Used as an efficient kernel-user space notification mechanism. These are
unique to Linux, and are also favored because of their multicast capabilities - i.e. it is
possible to share a socket between members of a group, sending messages to all of them
at once. Statistics are kept at /proc/net/netlink.

For IP-based sockets, a simple method is to look for the inode number in the various
/proc/net** statistics files. Since there are four files, it's quicker to do so by using , as
shown in the following output:

Output 7-4: Figuring out IP sockets from /proc/net

Tools such as  or  (but not those of  can 
parse�the output - but if you do it manually, all it takes is a bit of hex-juggling: The format of 
the lines�is:

which gives you the details you need.

Mappings for UN*X domain sockets are unfortunately not always this easy. Sometimes using
 will yield the socket name from /proc/net/unix, but often times the socket is unnamed, which

makes it difficult to figure out which peer is connected to it. In some cases, it's possible to recover
the other end by trying one number lower or higher, which may still be an unnamed socket, but
using  and looking for it often reveals the other end point's holder.
This is not a fool-proof method, because at times sockets are not created in pairs, but it's the
simplest way of deducing the number in absence of kernel symbols and /proc/kcore.

* - There are less often encountered types, such as raw sockets, which naturally maintain statistics in other files.
** - Technically, it's more accurate to read /proc/pid/net/family, since sockets may be contained in a namespace. /proc/net
offers the global namespace, however, so this works well too.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



fdinfo

At first glance, the fdinfo directory looks unimpressive - just like fd, but without symbolic links
(or fancy colors). The information contained in fdinfo, however, is just as important as fd/, if not
more so.

For every open file descriptor, the corresponding fdinfo/## entry holds metadata about the file.
Device drivers and filesystem implementors may use this file to convey information about the
current state of the file descriptor back to user space, though in practice few do, leaving only the
default information maintained by the kernel itself, specifically:

flags: The flags used in the  system call, when creating or opening the file. These
are defined in the <fcntl.h> header file.

pos: The current position of the "file pointer": i.e. the offset of the next byte to be read or
written from the file.

The pos statistic in a real gem, because it can let you monitor a process and figure out roughly
where along its timeline it presently is - all entirely unobtrusively. With a little bit of shell scripting,
you can harness this functionality to create custom tools to conditionally operate on a process, as
shown in the following listing:

Listing 7-1: A small script to watch and act on a file position in a process

The one drawback of the above script is that it relies on polling, rather than notification. Simply
put, the results will potentially change in between executions, and - depending on when you choose
to execute it - you might end up missing the precise offset you were looking for. This can be
assuaged by running the script at regular intervals, and/or changing the OFFSET parameter to allow
for more leeway (i.e. set the offset to a little bit before the actual required offset, and use
conventional debugging from the point on).

The script shown above is really an example of a pattern, which can be used all over
procfs to harvest data, and perform operations based on values collected. Because
procfs exports its data as pseudo-files, it just takes knowing the right filename, and
a mastery of the UN*X filters (cut, grep, sort and their ilk) to create any number of

customized tools. In fact, most of the tools you probably know and love (or at least,
respect?) can be implemented in script form by iterating over procfs, and the useful per-
process/thread entries (especially stat or status, shown next).

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



status

The status proc entry is a one-stop shop for all the things you'd want to know at a high level on
the process being inspected. And not just what you would like to know, so much as what the kernel
would: The /status is effectively a human-readable dump of the , which is a
mammoth structure in the Linux kernel serving as the process control block (PCB). This is what the
kernel sees, at a glance, when handling a process:

Output 7-5: The annotated /proc/pid/status entry

There is copious output here, so it makes sense to go over the non-obvious fields step by step:

Sorting out the pid, tid, tgid, and ppid confusion

It's tempting to think that "pid" would stand for Process ID. Right? Well, tough. It doesn't.
Originally, Linux did actually use PID as Process IDs, but ever since the turn of the millenium Linux
joined other modern operating systems, in scheduling threads and not processes. As such, 
correctly describes the thread, and not the process id of the entry being inspected. A process is,
therefore, a group of threads sharing the same resources (virtual memory, file descriptors, etc), and
that is what is shown by the  field.

Some readers may first balk at this, especially when in the above example the  fields and
 fields hold the same value. There's no contradiction here, though: For the  of a

process, the  and the  values will always match. This is, in fact, how one can easily
determine this is the main thread of the process - in other words, the first thread in the thread
group. For child threads, however, The Pid will change, while the Tgid will remain constant.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



By the same reasoning, the Ppid field - Parent Process Identifier - is therefore more correctly
the Parent Thread Group IDentifier. Somehow, PTGID just doesn't sound as catchy, so it's still
referred to as PPID. It's important to know one's lineage, because parents are responsible for
collecting their children's return code (returned from  or a call to ). Some parents
also drag all their offspring when they die, killing the entire process group.

Most UN*X tools are "conditioned" to only show statistics for main threads, and so the notion
(or illusion) or processes still works pretty well - and thus merits this section for explanation. The 
command, in an effort to maintain backward compatibility with days of yore, maintains the lie by
calling  as , and (when displaying threads, as in Linux's ) will actually refer to the

 as . Android's , which displays threads with the  switch, doesn't bother, and still calls
the field . The threads in any thread group can be seen by looking at the task/ subdirectory, as
shown in the following experiment:

Experiment: Viewing threads and processes in /proc

It often benefits an administrator or debugger to sift through the threads of multi-threaded
processes. The /proc filesystem offers per-thread statistics. Unlike Linux , which offers the 'l'
state to denote multi-threaded processes (in BSD mode), Android's  tool only provides  to list
all threads. You can use the Android  tool to display the number of threads:

Output 7-6: Using  to show number of threads:

You can extend the pattern of iterating over processes, from the previous experiment, to also
iterate over a given thread group's threads. You can  to /proc/tgid/task to find numbered
subdirectories corresponding to all threads in the group (including the main one). If you then 
to the individual task/ subdirectories, you'll see they are similar to the main thread's entry
(/proc/tgid/task/tgid in fact being the same). The per-process and per-thread entries are essentially
the same (recall Linux sees threads, not processes), with nearly all process level attributes (maps,
fd, etc) remaining the same, but a few (syscall, wchan, and a few others) potentially different per
thread.

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



Experiment: Viewing threads and processes in /proc (cont.)

The status entry can be particularly confusing, because most of its entries apply to the thread
group (and are thus identical across threads) whilst others do change on a per thread basis. The

 for example, can indeed be corroborated to be the real process ID by the following:

Output 7-7: TGID vs. PID, hands-on

Thanks to Android's best practice of naming individual threads, you can iterate over individual 
threads of most multi-threaded processes and actually tell them apart. This is especially useful for 
Dalvik apps (such as system server, q.v. Output 6-4), or even for Zygote itself - For example :

Output 7-8: Showing named threads

A little known fact is that you can  directly into a thread. While listing /proc will only show
main threads (or kernel threads), invoking  with a valid TID will simply switch into the per-
thread statistics, which are the same as what you would get through /proc/tgid/task/tid. When you
perform the list, procfs gets picky and filters out child threads. When you  directly, procfs
doesn't care - if you specified a valid thread, child, main or kernel - you got it.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

shell@flounder:/proc/211/task $ for t in *; do
> echo -n "PID $t: "; grep Tgid: $t/status;
> done
PID 19130: Tgid: 211

211
211
211

PID 19131: Tgid: 
PID 19132: Tgid: 
PID 19133: Tgid: 
PID 19134: Tgid: 211
PID 211: Tgid: 211

shell@flounder:/proc/211/task $ for t in *; do
> echo -n "PID $t: "; grep Name: $t/status;
> done

ReferenceQueueDPID 19130: Name: 
PID 19131: Name: 
PID 19132: Name: 
PID 19133: Name: 
PID 19134: Name: 

FinalizerDaemon
FinalizerWatchd
HeapTrimmerDaem
GCDaemon

PID 211: Name: main



Thread states and context switches

While a thread would, optimally, want to always be running, more often than not it doesn't
need to. Threads spend their lifecycle executing every now and then, but more often than not they
are waiting. For an event, for user input, for I/O, maybe a mutex, or maybe just a chance to
execute, because all CPUs or cores are presently occupied by other threads. At any given time, the
kernel maintains the list of threads, and for each, it records the state.

The process itself is not a runnable entity. Thus, the state and context switching 
statistics you see in the per-process entry is in reality that of the main thread.

The  field in /proc/status shows the same state shown in Android's  tool (or Linux's
, in BSD syntax). The states used are quite similar to states in other UN*X (such as Darwin and

other BSD), and in fact not unlike those of all operating systems, including Windows (though the
nomenclature is obviously different). The following state diagram depicts the transitions between
states:

Figure 7-1: The Linux thread state machine

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



As shown in the diagram, there is no clear distinction between Running (i.e. presently executing
in a core or hyperthread) and Runnable (that is, on the run queue, but waiting for an available CPU)
- both are, from the kernel's perspective, the same state. A thread will actually run for as long as it
can, until one of two occur:

Preemption: occurs when, due to an external interrupt, the kernel realizes that either the
thread quantum (allotted timeslice) has expired, or some higher priority thread has become
runnable. In both these cases, while the thread would no doubt benefit from prolonging
execution, it is kicked out in favor of another thread which takes its place, in what's known as
a context switch. This is obviously contrary to what the thread would have wanted (if it
had a will or a say), and is therefore considered nonvoluntary.

Sleep/Wait: occurs when the thread simply has nothing to do at the present moment. This
can occur because of one of several reasons, namely:

The user stopped the thread: by using the  signal. UN*X users are likely
familiar with the CTRL-Z combination, which causes the terminal driver to send the
signal to the main thread, thereby stopping the entire thread group - or what they
know as the process. A thread or group thus stopped can only be resumed with the

 signal, which is usually what  or  send. You can, of course, stop and
resume threads manually by using pid and pid,
respectively.

The terminal driver stopped the thread: because of an attempt to run a full-
screen command (e.g. vi, more) in the background, or any background command on
input, or on output when the  setting is set. The signal sent here is

, but otherwise behaves similarly to .

The thread actually yielded the CPU: which occurs when the thread calls
 or other forms of delayed execution, or - more commonly - when the

thread is waiting for an IPC object (e.g. a mutex). This can also occur implicitly, when
the thread makes an I/O call that cannot be immediately serviced (i.e. is not present
in the buffer or page caches). Such I/O requires storage or human user input, both of
which are orders of magnitude slower than the CPU. The I/O system call therefore
chooses the greater good, which is to suspend the thread and put it on an I/O wait
queue*. When the I/O is complete (via an interrupt), the thread can be rescheduled,
possibly preempting another thread. In any of these cases, however, the thread
"agrees" (or, at least, acquiesces) the context switch, which is why it is referred to as
a voluntary context switch.

The distinction between voluntary and nonvoluntary context switches is an important one,
which is why you can find those statistics as fields in the status entry. A thread with an unusually
high number of nonvoluntary context switches keeps getting "kicked out" of the CPU when it still
needs it - which implies it might benefit from an increased priority (or is just a plain CPU hog).

The last two states shown in the diagram - Zombie and Dead - are non-states. A UN*X process
has a very clear raison d'etre - its return code, which it is supposed to provide in an 
system call, or as a return value from its . This code, however, must be picked up by the
parent process. This requires responsible parenting, in the form of calling one of the 
system calls (usually after obtaining the child's SIGCHLD death notification) to collect the return
code. A main thread briefly enters the Zombie state when it exits (or returns from ), in the
hopes of being put out of its misery by its parent. If the parent fails to live up to its obligations,
however (by ignoring the signal or forgetting  after , as some programmers do),�
the child is condemned to a Walking Dead state. Fortunately, UN*X Zombies are quite benign, and�
don't actually consume any resources - memory, CPU, or other - aside from a process table entry.�
The Zombies PD\�also find peace when their recalcitrant parent dies (or is killed), leading to an
adoption by ) (PID 1), which is always happy to call  and provide Requiem.

* - The choice of whether to enter  (which still accepts signals) or 
(which pends signals) is left up to the system call, or more accurately the driver in charge of servicing said call.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



High-Level memory statistics

The /proc/pid/status entry also offers valuable high-level insights into process memory utilization
(note here, we use "process" rather than "thread", because resources are handled at the process,
not thread level). The various statistics are shown in Table 7-1:

Table 7-1: High Level memory statistics in /proc/pid/status

Metric Meaning

VmPeak Virtual Memory high-water mark: The highest value obtained by VmSize
over the lifetime of this process

VmSize Virtual Memory size, at the present moment.

VmLck Memory locked by mlock(2) APIs. For most applications, this is 0.

VmPin Pinned memory. For most applications, this is 0.

VmHWM Resident memory footprint high-water mark: The highest value obtained by
VmRSS over the lifetime of this process

VmRSS Resident memory footprint, at the present moment.

VmData Size of data segment - This is the size of the process heap memory

VmStk Size of process thread stacks

VmExe Size of executable

VmLib Memory used by shared library (.so) files

VmPTE Memory used by Page Table Entries

VmSwap Memory used by process in swap (In Android - no swap, ergo always 0,
unless using swap to ZRAM)

Looking at the high level statistics can often provide a quick diagnosis as to memory hogging
problems - particularly high levels of . To gain more insights into memory problems,
however, we need to consider the more fine grained statistics of /proc/smaps - and memory
management in general.

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



User mode memory management

Programmers don't normally pay attention to memory. It's a given that each process gets its
own address space, wherein it can allocate memory freely according to need, and be assured that
the kernel will handle all the minutiae. The address space is private - that is, belonging only to this
process, and virtual - i.e. abstracted from the actual RAM by the kernel and memory management
unit.

In practice, however, memory is one of the most critical bottlenecks an application can face.
Improper memory management not only has an adverse effect on the mismanaging process, but
also on the entire system. The effect is further exacerbated on Android: whereas on Linux memory
allocations which would deplete the RAM could be backed by swap (leading to excessive swapping
and performance degradation but still being satisfied), Android has no swap - and, as a
consequence, it's simply not possible to deplete the RAM without triggering a global out-of-memory
condition. At that point, the only way to recover RAM would involve killing a victim process to
recover its RAM.

Android does a remarkable job of optimizing the available memory, to compensate for the lack
of swap. The very design of the Dalvik Virtual Machine emphasized sharing as much virtual memory
as possible. Indeed, multiple instances of the traditional Java VM (such as that of Sun's J2ME)
simply could not be satisfied without 100+ MB of RAM per instance. Dalvik VMs instances, by
contrast, are nearly all shareable, resulting in a fairly low memory footprint for individual apps.

Virtual Memory classification and lifecycle

It's tempting to think that "all virtual memory is the same", but that is far from true. Virtual
memory can be classified by no less than four types, which impact its usage - and, even more
importantly, its release. Pages have their own lifecycle, depicted in the following figure:

Figure 7-2: The page lifecycle

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Named (mmapped) vs. Anonymous

The first classification of a memory page denotes its source - mapped pages are pages taken
from files on the storage (disk, flash, or network file system). The pages are loaded from a file, (via
the kernel's page cache), contiguously into the process' virtual memory. The file name serves as a
name for the memory itself, which is why mapped pages are often also referred to as named
memory.

By contrast, some memory is not file backed, and is created ad-hoc for the process' immediate
need. This includes memory used by the stack or the heap, when the program sets up a stack frame
or calls . This memory has no backing in a file, and therefore has no name - which is
why it is often referred to as anonymous memory.

The maps per-process proc entry will show you all memory mappings. Named mappings are
easy to see because the device and inode number, along with the corresponding filename, are
clearly listed. Anonymous file mappings have a no numbers, but "special" anonymous mappings -
such as the stack or heap, are clearly shown.

Dirty vs. Clean

Once a page is loaded into memory, it may remain unaltered - used as read-only memory, or it
may be modified by the process for whatever reason. Unaltered memory is referred to as clean
memory, whereas modifying memory makes it dirty.

This distinction is more than just cleanliness - The system needs to know if a page is dirty or
clean for several reasons, including knowing what to do when the page has spent too much time in
memory, and how it affects sharing - which brings us to the next classifications:

Active (referenced) vs. Inactive

Virtual Memory pages , when mapped to RAM, have an "age". The kernel and MMU work
together to maintain a reference mechanism, tracking the Least Recently Used (LRU) pages. When
a page is accessed, it is immediately marked as Active. If left unused for more than a given period,
the status is changed to inactive.

The activity indication is important for purposes of purging and writeback. Purging refers to
the process of discarding a page, when it is no longer required. If the page is both inactive and
clean, it implies that it has either a zeroed page, or it has been backed up to storage. In either case,
it can be rid of immediately, to make room for another process' virtual memory paging request.

Writeback refers to the process of taking dirty pages, and writing them back to storage -
commonly, the files whence they came, but - in the case of anonymous memory - to swap. Mapped�
pages are especially important to write back within reasonable time, because the system could face�
power lRss (or a crash) unpredictably. Mapped pages not written will result in data loss. The kernel�
therefore maintains page expiration paramHters in /proc/sys/vm. Anonymous pages are written to�
swap (compressed RAM, in Android systems which support it). If there's no swap (or compressed�
RAM) to write back to, the system faces an Out-Of-Memory condition (as we describe later).

Private vs. Shared

Memory that is unique to the process is considered private. This implies that only the process
has access to the memory page, and no other process can physically access the memory. Normally,
this is when a process requests a file mapping using  with the  flag, or
(more commonly) allocates anonymous memory using  or .

Memory can also be shared, in between two or more processes. This is usually the result of a
deliberate sharing done by the programmer, using memory sharing calls such as  with the

 flag, or other mechanisms (such as System V  APIs, or - in Android -
). This is known as , because the process specifically tells the

kernel - I want this memory to be shareable with others.
���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



Shared memory may be mapped in different virtual addresses in process A and process B, but
both will eventually get to the same physical page. This means that there is only one physical copy
of shared memory in the system - after all, why waste two RAM pages with exactly the same
content? This also has the upside of relieving the kernel from having to maintain the sharing by
updating multiple copies of memory on change. If there's only one copy mapped to all processes,
any change in that copy is instantly reflected among all processes.

Things get a little bit more complicated: Sometimes, a process may request private memory,
but the system may decide to share it anyway, without informing the process - in what's known as
implicit sharing. Examples of this abound - in fact, most memory is implicitly shared, unless
otherwise stated. For example, consider libraries and frameworks: Each process certainly needs a
copy of them, but the vast majority of the processes use the copies verbatim, not making any
changes. Library and framework code, for example, is mapped read-only, and therefore, by
definition, cannot change. It doesn't make sense, then, to map individual copies of libraries
(especially commonly used ones, like Bionic), when all copies are the same. In these cases, even
though the process may request , the kernel basically says "sure, sure", but performs
sharing anyway, outright lying to the process, which remains entirely oblivious.

To maintain this elaborate ruse, the kernel does require a little bit more overhead: If memory is
implicitly shared, and one of the parties tries to modify it anyway, the kernel will have to allow that
party to modify the memory, without affecting any of the others. This is when the kernel employs
copy-on-write, which involves intercepting the write attempt (by a page fault), then creating a
new copy which can be written to, and remapping that copy to the process virtual memory, instead
of the original page, which is left unmodified and mapped to all other parties' address space.

Experiment: Examining address space mappings through /proc/pid/maps

The per-process procfs maps entry provides a full layout of the process address space,
enabling you to quickly determine which files have been mapped, alongside the anonymous
memory regions. Output 7-9 demonstrates the entry for the shell (on a 64-bit system), with
annotations:

Output 7-9: Examining a process address space (e.g. the shell) through /proc/pid/maps

You can see even more detail by examining the smaps per process entry. This provides the
same information as maps did, but with the additional breakdown by classification for every region
- but that will be demonstrated shortly, in the next experiment.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



To view memory statistics on a system-wide level, you can consult the /proc/meminfo file. The
file (used by utilities like top and vm_stat uses the same nomenclature and classifications just
defined:

Output 7-10: Examining system wide memory utilization with /prc/meminfo

Memory Metrics

To calculate memory statistics, one has to take into account quite a few factors, such as
whether or not memory is resident, shared, and other parameters. We can start off with the
following simple formula:

In plain English, this means that the virtual memory of a process may be classified into four
disjoint categories:

VmRSS: The Resident Set Size - are those pages of virtual memory which are presently
backed by physical RAM pages. This may be because they have been recently active, or - in
some cases - because the process (or kernel) requires them to be locked in memory. The
resident memory may further be subclassified as Unique (private to this process) or Shared
(in between one or more processes).

VmFileMapped: Pages which were retrieved from files, by means of the  system
call, may be written back to the files at any time to free memory. In fact, in most cases if the
pages remain clean (unmodified), they can simply be discarded as - if need arises - they can
always be reloaded from the files, which are still on flash/disk. The size of pages in this
category is not directly reported in /proc/pid/status, but can be figured out from /proc/smaps,
and - on a system-wide level - from /proc/meminfo.

VmSwap: Pages which resulted from memory allocation (i.e.  or similar) do not
have any file backing. These are also known as anonymous pages, since they have no
name (read: filename) to back them up. It follows that there is no way to write them back
out. In Linux, swap space comes to the rescue, as a portion of storage set aside to back
anonymous pages. In Android, however, there is no swap. This value is therefore almost
always 0, unless the system swaps to compressed RAM (ZRAM).

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



VmLazy: Programmers are a greedy lot, often allocating far more memory than they actually
need. The kernel takes a lazy approach to allocation, preferring to set aside pages "on paper"
until they are actually required, or written to. These pages are allocated in the process Page
Table Entries (visible in /proc/pid/status as ), but the actual allocation is deferred until
a pointer to the page is actually dereferenced. The kernel then experiences a page fault from
the MMU, which reports - correctly - that the page does not exist. The kernel then proceeds
to actually allocate the page. Using lazy allocation saves a great deal of memory, but does
impact performance marginally. A worse scenario occurs when the page fault cannot be
satisfied due to no available physical pages, and no way to write back any to disk. That's
when an Out-of-Memory (OOM) condition occurs, which we discuss later in this chapter.

It's tempting to sum up VmRSS over all processes in order to calculate the overall RAM
footprint. Doing so, however, would be wrong - because Some of the resident memory of the
process may in fact be shared with others, in which case a simple summation would end up
overcounting the shared regions. A more accurate measure is needed, and this is what Linux offers
with the PSS - Proportional Set Size statistic. In mathematical speak, PSS would be defined as: 

If, like most non-math-types, you find the equation a tad alarming (or promised yourself to not
ever use Sigma notation again), this can be put in words, like so:

PSS will count 1K for every 1K of private memory (USS). That is, if a process has a private
memory page, it counts in full for purposes of calculating the PSS footprint

PSS will only count 1/n K for every 1K of shared memory, with "n" dependent on the number
of processes sharing this region. Because there may be more than one regions, we need the
Sigma notation - which basically says, add 1/n1 for the first region found, then add another
1/n2 for the second region found (assuming n2 sharers), etc.

This might seem odd at first, but when you take the sum of PSS over all processes in the
system - mathematical magic adds up the shares in a way that every shared region is counted in
full, and exactly once, for the purposes of determining the footprint (If you want a slight challenge,
you can work out the (double) sigma notation required to prove the correctness of this claim).

Fortunately, PSS measurements prove far more useful than the algebraic equations backing
them, and are readily obtainable (with virtually no need for math) directly from the /proc/smaps file.
This is best exemplified in the following experiment:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/LinuxLens.html#oom


Experiment: Observing RSS, USS and PSS through /proc/pid/smaps

The per-process smaps entry breaks down memory regions from the maps entry and provides
detailed information on each. For this experiment, find a binary that isn't concurrently executing as
another process, and doesn't terminate quickly. A good candidate for that is , which is an
actual binary (not a  tool), and will run indefinitely.

Start  with some address - it doesn't even matter if the address is reachable - what
matters is that  will run. If you choose another binary, that's fine too - the choice of binary is
entirely inconsequential for this experiment - what matters is that the binary loads, and creates a
process instance, which you can then suspend. Once the binary is running (possibly paused for
input), hit  to suspend it and go back to a prompt, or leave it running in the background.
Then, inspect the first 10 or so lines of its smaps entry. Using , it will look something like this:

Output 7-11(a): Examining the USS, RSS and PSS of a single instance of a given binary

What do we see in the output?

The first memory region is loaded from /usr/bin/ping on disk (no surprise here). The region
is readable, executable, and (seemingly) private ( ). It was loaded from device

, inode #463.

The VmSize of this region is 36Kb. Of which, 4k have been immediately freed - because the
Rss is 32k. This amounts to a portion of the ELF header, which has no practical use in
memory during runtime.

The 32k of RSS are all private, and clean: Private, implies unique to this process (i.e. USS),
and clean implies that they have not been modified since their loading. All 32k are also
recently active (Referenced), which again is no surprise, since ping is executing. The pages
are not anonymous (because they are mapped to a file).

Consequentially, the PSS is 32K. With no shared memory, every 4k of USS map to 4K of
PSS.

So far (hopefully), so good. But what happens when we start another instance of  (or
our process)? Doing so, we then inspect the smaps entry of the first instance (not the second!),
and see that it has changed!

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



Experiment: Observing RSS, USS and PSS through /proc/pid/smaps (cont.)
Output 7-11(b): Examining the USS, RSS and PSS of the first of two concurrent instances of a given binary

Comparing the two outputs you can see that most metrics in the original process have not
changed - The VmSize is still 36k with a 32k RSS. The RSS, however, is now all shared - between
the two instances of the binary - and therefore the PSS has dropped by half, to 16k.

Running this example with another instance of the process will bring down the PSS to 10k
(technically 10.6k, but rounded down), and with four instances - to 8k (32k divided cleanly by
four). Killing instances reduces the number of sharers, and brings up the PSS value.

Note, that throughout the example, the region remained seemingly private (
in both outputs). This is obviously false, since smaps clearly shows the region

becomes shared. This paradox is resolved by explaining 'p' not as private, but as
 - i.e. the argument to  when mapping the region. This is the

same "ruse" that was previously discussed when explaining private/shared memory.
Stated otherwise, the process mapped this region as private, and the operating system
plays along - but if another process maps this same region, the kernel reserves the right
to make this implicitly shared between the processes, so long as neither process
actually writes to (dirties) the region. If a write occurs, the writing process triggers a
copy-on-write fault, which forces the kernel to actually allocate another copy of the
page(s) written to, so as not to violate the existing copy. This is in contrast to 's' in the
permission flags, which means explicitly shared (i.e.  in the 
arguments) - denoting that the region can be dirtied and still remain shared as a single
copy.

The experiment hopefully served as a simple example of how PSS is calculated. 'Simple',
because this was a simple case where all memory was shared, thereby reducing USS to zero, and
making the PSS calculation straightforward. Other regions may be mixed - both private and shared,
which makes PSS calculation a bit more challenging, but fortunately smaps does that automatically.

If you're not a fan of parsing /proc/smaps manually, there's a tool for that - two, in fact. This is
shown in the next experiment.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Observing RSS, USS and PSS through procrank and librank

The AOSP provides two useful tools to show memory statistics - procrank and librank. These
are not present in most production devices, but it's a simple enough matter to copy them from the
emulator image to the device, along with their dependency, /system/lib/libpagemap.so. This is
shown in the following output:

Output 7-12: Moving binaries from the emulator to a real device

On the device, you'll need to make the binaries executable (by using ), and then
execute them. Because the library dependency is also in /data/local/tmp, and libraries are searched
for in /system/lib[64], you'll need to alter the library load path. On a rooted device, this is not
necessary if you drop the library dependency in /system/lib.

Output 7-13: Moving binaries from the emulator to a real device

Once you have procrank and librank copied (or, if you just run them on the emulator), you can
turn to analyzing their output. Both tools operate by iterating over the per-process smaps statistics
(newer versions work with the pagemap entry), but they differ in how they output the statistics:
procrank does so by sorting processes in descending order of memory usage, while librank sorts
regions of memory by the processes using them. There's a lot to be learned from the output about
memory utilization (and optimization) in Android. Starting with pagemap:

Output 7-14: The output of procrank from the L Emulator

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV



Experiment: Observing RSS, USS and PSS through procrank (cont.)

As the output shows, processes are ranked by descending order of Vss (as per , the
default; you can also sort by ss, ss, or ss). More advanced options will show only cached
( ) or non-cached ( ) pages - try  for more options.

In the output, however, something stands out very quickly - though Vss sizes are humongous
(565M for the Launcher, really?), the actual RSS sizes are small (indicating plenty of discarded
mappings), and the PSS sizes are smaller still. As you can see, the average unique footprint of
apps is no more than a few MB! About 85%-90% of the RSS of the average app is all shared,
reducing its PSS dramatically. This shareability is owed to the structure of Zygote and the Dalvik
VM (ART included) which maximize shared memory in ways Java never could (but still not as
efficiently as iOS, some would argue).

You can work back to see how much memory is shared by subtracting the USS measure from
the RSS. Subtracting the USS from the PSS will give you the weighted average of the shared
regions, and dividing the shared memory size by this amount will give you a rough idea of how
many processes are sharing the same regions. This is a rough idea only, because summing up PSS
loses some granularity - different regions likely have a different number of sharers.

The  tool's output is slightly different, as it is sorted by memory region. Otherwise,
however, the terminology remains the same. The following output demonstrates the usage of the
boot.oat shared region, which holds precompiled framework classes in ART:

 shows, yet again, the efficiency of sharing - The VSS associated with the boot.oat is
some 48MB. In practice, however, less than half is resident, and - in most processes unique
memory footprint of the oat is in the low KB.

Newer versions of Android make use of an even more clever forms of sharing, through the
Linux kernel's Kernel Samepage Merging (KSM) mechanism. This features lets the kernel auto-
detect identical physical pages in memory (by comparing hashes), even if they are not memory
mapped. If an identity is detected, the pages can be merged, subject to the usual copy-on-write
restrictions. KSM has been a feature in the Linux kernel as of 2.6.27 or so, but has only recently
entered Android.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

Output 7-15: The output of librank demonstrating sharing on the ART precompiled classes

root@generic:/ # librank
      RSS      PSS      USS  Name/PID RSStot      VSS

..
27179K /data/dalvik-cache/arm/system@framework@boot.oat

    6468K        system_server [354]
    3982K    
    3802K    
    3164K     
    1933K     
    1302K     

48556K   19576K
48556K   13488K
48556K   13984K
48556K   14800K
48556K   11880K
48556K   10544K

     958K         9268K48556K
     861K          9048K
     826K          8200K
     759K          8628K
     655K          7960K

    7280K     588K      
    7220K     566K      
    6772K     474K       
    6132K     429K       
    5796K     405K       

    zygote [66]
    com.android.phone [538]
    com.android.systemui [709]
    com.android.launcher [581]
    com.android.inputmethod.latin [500]
    android.process.media [766]
    com.android.email [997]
    com.android.server.telecom [532]
    com.android.calendar [955]
    com.android.providers.calendar [843]
    com.android.deskclock [978]
    com.android.browser [1077]
    com.android.exchange [1037]
    com.android.dialer [1061]
    com.android.sharedstoragebackup [1096]

3268K
2112K
2192K
744K
324K
160K
104K
64K
96K
20K
12K
24K
20K
0K
0K
4K

48556K
48556K
48556K
48556K
48556K
48556K
48556K
48556K
48556K



Out of Memory conditions

Despite all the extensive memory sharing in Android, along with tricks like KSM or ZRAM, lack of
real swap space is an inherent problem. Android is not at fault here - swap and flash simply do not
go well together, due to flash memory's limited Program/Erase (P/E) cycles. As a consequence,
running out of memory at any given time is a clear and present danger.

The Linux kernel has long had a mechanism to deal with memory shortage. This mechanism -
called OOM (Out-Of-Memory) is triggered when a memory request cannot be satisified. In Linux, this
happens rarely - if the system is low on RAM there is usually ample swap space to fall on. It's only
when the system is both out of RAM and swap space that OOM is triggered.

OOM isn't a thread - it's implemented as a code path following the page fault which occurs. The
code looks through the list of processes, and attempts to find the most suitable candidate, whose
sacrifice will result in the best memory gain for the system. All processes are candidates on this
"death row" , sorted by their  - a heuristically devised score which evolved as did the
kernel. This score is visible in the per-process /proc/pid/oom_score as a read-only pseudofile.

The problem with the heuristic is, that - as will all heuristics - it doesn't always reliably work.
Often times, innocent processes are sacrificed just for being with the wrong score at the wrong
time. Execution is imminent and swift, with no saving throw - essentially a  - and there is
nothing the victim can do about it.

It is for this reason that the Android application lifecycle exists with the perpetual fear of
untimely death. Applications are not guaranteed persistence in any way, and are instead given
callbacks to save their state (as an opaque ), with the only promise that, if
they are killed, they will be reincarnated with that bundle. An application has no way to predict
when and even if it may be terminated. As opposed to iOS's jetsam (a mechanism designed for a
similar functionality), the application doesn't even leave a tombstone (though some detail to the
kernel log is saved).

In an effort to bring a bit more determinism to the heuristic, Linux offered a method to adjust
the score from user space. First, as /proc/pid/oom_adj and (in later kernels) as
/proc/pid/oom_score_adj. These files enable a user space process to add a modifier to the score - a
negative modifier to reduce the score (thus making the process less killable) or a positive modifier to
increase the score (effectively giving the process suicidal tendencies).

Android's system processes use this mechanism to make themselves unkillable. /init and its
cohorts from the various .rc files give them an  of -16 or -17 (which completely disables
OOM for the task). In newer kernels, setting the  to -1000 achieves a similar
result, which effectively makes their score close to (if not) 0.

In the wrong hands, this could have also been abused by apps (after all, who wouldn't resist
the temptation for immortality?) but Android's  automatically resets the score
adjustment along various stages of the application's lifecycle (as we discussed in Volume II). As of
Android L, The  relies on the  (discussed in Chapter 5), because the�
adjustment files are owned E\��and writable to� root only.

Android takes another precautionary measure, in the form of the LowMemoryKiller (lmk). This is
an Androidism which enhances OOM by preemptively killing processes before a real OOM condition
is triggered. In previous Android versions, init would set the module's parameters via sysfs on
startup. With L, init merely ensures file permissions on the sysfs pseudofiles, leaving the task to lmkd
instead.

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV

file:///Users/morpheus/Documents/Android/Book/Services.html#lmkd


Experiment: OOM memory adjustments in action.

You can observe the OOM score adjustments in real time by examining the procfs entries
during application lifecycle. For this experiment, open an ADB shell while using an app. For
example, if you're using the Chrome web browser, you'll see:

Output 7-16(a): Viewing an active application's OOM scores

Moving the application to the background (by simply pressing the home button) will 
automatically reflect in OOM. The oom ad  increases, and the score shoots up accordin ly

Output 7-16(b): Viewing an active application's OOM scores

In Android L, you can also attach a trace to  during the application lifecycle events, to 
see incoming messages from  to , in order to adjust the scores. This 
was shown in the Experiment in Chapter 5 (specifically, output 5-6). Suspending  (by 

)  will prevent any OOM modifications.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Tracing System Calls

Virtually any "meaningful" operation performed by a user-mode thread requires some kernel-
involvement. Whether it is dealing with a file, opening a socket, or handling any type of resource
outside one's own previously allocated virtual memory, a user-mode thread must request that
service from the kernel, by means of a system call.

System calls require the user mode process to first traverse into kernel mode. The method of
doing so differs with each architecture, but always involves a special machine instruction - ARM's

 (a.k.a ), or Intel's  (or ). These instructions set the processor mode to
privileged (supervisor) mode, and are setup by the kernel upon boot to transfer control to a
predefined kernel entry point - . All system calls are thus funneled to one function.
The system call number (passed in ARM's  or Intel's ) is used to redirect execution to the
specific system call implementation, by consulting an internal table.

Given all the above, it should be clear why system calls deserve special focus, when it comes to
debugging and tracing processes. Most of the time, the internal operations inside a process -
changing this or that variable - aren't of too much interest, if only because they are so plentiful and
hard to trace. Operations on files or sockets, however, are especially interesting, and tracing system
calls provides a simple way to trace these operations, among others.

The  tool

Toolbox's  tool, however crude, does offer two valuable fields pertaining to system calls:
 and . The first denotes the "Wait Channel", which is the kernel address the entry is

presently in, or -1 (0xfffffff) if this cannot be determined (Recall each line in  refers to a kernel
thread or the main thread of a process, unless  is used). The second is the return address (in
user space), where execution resumes after the system call. Resolving the kernel address requires
some manual work, as shown in the following experiment:

Experiment: Manually resolving 's  value
When faced with a  address - or any kernel address - you can follow the simple method

shown here to use /proc/kallsyms and resolve it to a more readable symbol. You start at the exact
address - which never produces a match, since entries in kallsyms are only for entry points, and
the  is inside a function. You then go back by removing the least significant digits, taking 
advantage of 's ability to match the prefix. At some point,  will match one or more 
addresses - and the closest one to the one checked is the name of the function the kernel is in.

Output 7-17: Resolving a kernel address using /proc/kallsyms

One caveat to keep in mind - make sure to find the closest symbol before and not after the
address you're looking for. Sometimes (like in this example) the closest symbol may wrap, and
other times  might return matches which are after your symbol (and therefore incorrect).

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV

The toybox in Android M's preview automatically maps the WCHA  address to a 
symbol, by lookin  at / ro / / ha  (as shown next). The experiment is ust as 
relevant, however, since it shows the techni ue for resolvin  kernel addresses.



wchan and syscall

The /proc filesystem also offers system call tracing mechanisms. The wchan per-thread entry,
like the  output, shows the location in kernel mode where a thread is sleeping (or 0, if 
the thread is presently active), but also resolves it to the closest symbol, saving you the hassle of the 
previous experiment. What more, it works even if the  file restricts addresses.

In some kernels, the syscall per-thread entry offers even more detail: It captures the system call 
number, along with arguments, that the thread is in at the time of polling. The format of this is 
demonstrated through Output 7-18:

Output 7-18: The syscall and wchan procfs entries

You can resolve the program_counter value - which is also the value quoted by 's 
 - using the method shown in the previous experiment. A caveat with system call numbers, 

however, is that they are not guaranteed to remain constant across architectures. The system call 
numbers of Intel and ARM are understandably different, but more surprisingly those of 32-bit and 64-
bit are sometimes different. You will need the specific system call file for your architecture, which you 
can find in the Android NDK, under platforms/android-APIversion/arch-arch/usr/include/asm/unistd.h, 
replacing arch with arm, arm64, x86 or x86_64. Fortunately, kernels with syscall procfs entry normally 
have wchan as well, so you can resolve the syscall number via wchan, as demonstrated above. Most 
kernels also have a stack entry, which details the kernel stack.

The  tool

The methods shown so far all used polling - i.e. you could get an exact reading on a system
call, but were responsible for initiating the reading, and could only capture one result at a time. This
is useful in case of diagnosing a hanging or unrespnsive process. Most system call tracing, however,
is best performed as an on-going operation, attaching to the process as unobtrusively as possible,
and getting notifications on every system call it performs.

This is where  comes into play. This powerful binary, which has been used several times
by now in this book to trace and explain the internals of processes, is utterly invaluable as a tracing
tool. A complete example of its usage would likely take up a chapter by itself, but table 7-2
summarizes some of the more useful switches:

Table 7-2: The more useful switches of 

Switch Use
Print instruction pointer at time of syscall

Print timestamp, with/without usecs

Follow the clone() syscall, auto-attaching to child processes/threads

file Save output to file

Verbose mode for various syscall arguments

 is exceptionally good at understanding the system call arguments (even more so when
 is used. At the time of writing, there is no Android-aware version of the tool, nor is there an

ARM64 compatible version. The  tool, from the book's companion website, provides an
 clone which addresses both these issues.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://newandroidbook.com/files/jtrace.tgz


Summary

This chapter focused on the usage of the /proc file system - in particular, the per-process�
entries in /proc/pid and per-thread entries in /proc/pid/task/tid - and the plethora of information they�
provide, to allow for powerful native-level debugging and tracing of processes. The methods�
demonstrateG apply to mainline Linux in the same ways, because procfs is an integral part of the�
Linux kernel.

References and Files Discussed in this Chapter
Reference Provides

/proc/pid/fd
/proc/pid/fdinfo

Information about open file descriptors for process

/proc/pid/maps Address space of process, as list of mapped and anonymous regions

/proc/pid/smaps As per /proc/pid/maps, but with per-region statistics

/proc/pid/status Information from process or thread's control block (kernel's )

1. www.kernel.org/doc/Documentation/filesystems/proc.txt Documentation about the procfs
filesystem entries.

���

&KDSWHU�9,,��7KURXJK�D�/LQX[�/HQV

https://www.kernel.org/doc/Documentation/filesystems/proc.txt


���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



VIII: Android Security
As with other operational aspects, Android relies on the facilities of Linux for its basic security

needs. For most apps, however, an additional layer of security is enforced by the Dalvik Virtual
Machine. Android Security is therefore an amalgam of the two approaches - VM and native - which
allows for defense in depth.

This chapter starts by providing a brief insight into threat modeling: A practice taken by security
experts to try and analyze the possible attack vectors and threats which may compromise a device.
Malicious apps, and theft are just two of the possible threats considered, as mobile security must
address all the "traditional" faults of desktop security, and then some.

We continue by exploring the Linux user model, and its adaptation to the Android landscape.
Starting with the native Linux permissions, and the clever usage of IDs for Apps and group
membership. We then proceed to highlight capabilities, an oft overlooked feature of Linux used
extensively in Android to work around the inherent limitation using the almighty root uid in the
classic model. Next is a discussion of SELinux, a Mandatory Access Control (MAC) framework
introduced in 4.3 and enforced in 4.4. Lastly, we consider various protections against code injection,
the bane of application security.

At the Dalvik level, we consider the simple, yet effective permission model enforced by the
Virtual Machine and the package manager, as well as the bindings to the Linux level. But up to this
point, both Linux and Dalvik can be thought of as aspects of application level security.

We therefore next consider user-level security: protecting the device against human users by
locking the device. No longer the domain of simple PINs and patterns, device locking methods get
ever more innovative, and have expanded to include biometrics as well. As of JB, Android allows
multiple users to coexist, each with his or her own private data, and set of installed applications, and
so the implementation of multiple users is covered as well.

At this point, we turn to a discussion of encryption on Android. Beginning with aspects of key
management, we explain the inner workings of the keystore service, and the maintenance of
cetificates on the device. We then touch on Android's storage encryption feature (introduced in
HoneyComb) and filesystem authentication using Linux's dm-verity (as introduced in KitKat).

Last, but in no way least, is a focus on device rooting, without which no discussion about
security would be complete. Rooting brings with it tremendous advantages to the power user (and is
one of the reasons Android's popularity has exploded in hacker and modder circles), but also woeful,
dire implications on application and system security. The two primary methods - boot-to-root and
"one-click" are detailed and contrasted.

���

file:///Users/morpheus/Documents/Android/Book/Security.html#SELinux
file:///Users/morpheus/Documents/Android/Book/Security.html#lockScreen
file:///Users/morpheus/Documents/Android/Book/Security.html#multiUser
file:///Users/morpheus/Documents/Android/Book/Security.html#dataenc
file:///Users/morpheus/Documents/Android/Book/Security.html#DiskVer
file:///Users/morpheus/Documents/Android/Book/Security.html#rooting


Threat Modeling Mobile Security

If one considers the evolution of hacking, a logical progression can be seen: At first, the main
targets were servers. It was much easier to hack into a server, a "sitting duck" in terms of being
always connected to the internet, than try to hack into a desktop, which only sporadically, if at all,
was ever connected - and even then, through a low bandwidth modem.

This changed with the proliferation of broadband connections, and the rise of local area
networks. Suddenly, millions of new potential targets emerged on the Internet. As desktop
machines, the security posture was off to a much weaker start than a server. Insecure defaults and
the overly user-friendly (and complex) operating system that was Windows provided a ripe breeding
ground for hackers, and brought on waves of worms and malware.

Attack vectors

Mobile devices, while similar in some respects to desktops, have an entirely different threat
landscape. Unlike the latter, their very mobility exposes them to far more risks, as they may be
accidentally misplaced, or deliberately stolen. This effectively negates the aspects of digital security
one could enforce on a desktop, by restrictring access at the lock and key (or keycard) level,
opening up a slew of attacks an adversary could try once physical access to a device is obtained.

But that, alas, is only half of it: Unlike desktops, mobile devices - being far more personal - are
more likely to contain personal user data, which makes them more lucrative a target for hacking.
The attack profile has also changed - rather than obtain full control of the device remotely (what
hackers call "pwning"), it often suffices to just get access to user data, and - using a likely always on
Internet connection - smuggle it out to a remote server.

The Rogue App

The primary attack vector on a mobile device is from within: That of a rogue application.
Users are eager to expand the functionality of their devices by installing more and more apps. But a
misbehaving or deliberately malicious app, could attempt to access the user's information, or even
take over phone functionality, for example by sending premium SMS messages for outrageous
prices. Generally, this is classified as local privilege escalation, as an application is already
installed and running on the local device, but with a restricted set of privileges, which is wishes to
elevate.

To prevent this, Android must treat all applications as suspect. By default, applications are given
a minimal set of permissions, but are otherwise restricted. The minimal set, however, does not
include anything which might be potentially sensitive - even if it is vital. Accessing the network, for
example, could be used maliciously to funnel out information from the device. For this reason, any
permission outside the minimal set must be explicitly requested by the application, in its manifest.
Each application is given its own UID, which isolates it from others, and - needless to say - root
access for applications is out of the question.

Android took a step up in application restrictions in Jellybean, with the introduction of SELinux,
a mandatory access control framework which effectively sandboxes all processes except the very
trusted ones. In Android L, the frameworks have also been extended to support package
restrictions.

That, however, is not enough - Android must also protect itself, as it is likely that a malicious
application could try - within the limited subset of permissions it does have - to attack vulnerable
components of the operating system which houses it. This is not without precedent. It's possible to
exploit such vulnerabilities and trick more privileged components of the operating system -
particularly those running as root - to perform an operation on behalf of the application. Due to the
vast amount of code in the Android frameworks, and even more code in the underlying Linux kernel,
this is a serious threat. Most past vulnerabilities have in fact done just that in order to elevate their
privilege.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



The Rogue User

It's hard to think of the device user as an actual threat (although iOS certainly seems to do so).
The potential of device theft, however, makes it unclear as to just who the valid user is. The system
must therefore be secure at all times, especially when outside the user's reach.

The first line of defense is the lock screen, which must balance the need for strong
authentication credentials with an easy to use (and quick) unlock operation. After all, you wouldn't
want to type in a 20 character, case-sensitive password every time your screen blanks! It therefore
falls upon the user to decide what is "acceptable" security, in choosing the authentication
mechanism, as well as the timeout to enforce it.

Android introduced face unlock as a method for quick (albeit not too safe) unlock, and (in
Lollipop) has followed iOS with built-in support for fingerprint authentication as well. Lollipop also
brings unlocking via paired devices (over Bluetooth, when the paired device - usually an Android
Wear device) is near.

There is also the potential of a device being stolen, turned off, and rebooted. For this, Android
must ensure its boot process is secure. Otherwise, someone could override the boot loader and
restart the device in an alternate configuration, which could be less secure. This is why boot loaders
are often locked by default, and if unlocked - will first efface the entire /data partition.

Finally, the user's data should be encrypted - else a sophisticated attacker can simply pry it
open and access the raw flash storage. Android offered encryption as early as Honeycomb, but once
again trailed iOS as it only enabled it by default beginning with Lollipop. The encryption key must
not rest anywhere on the device, and be derived from the user's unlock code for maximum usability.

Remote Code Injection

Last, but not least (if all the above weren't bad enough), mobile devices are still subject to the
very same attack vector servers and desktops were - remote code injection. The same class of
vulnerabilities which plague desktop can also affect mobile devices, as attackers seek to target
devices over the Internet, either as random "drive-by" (malware spam or malicious banners), or
through targetted attacks (usually socially engineered email).

Webkit, which served as the basis for Android's browser and webviews, has proven to be an
inexhaustible font for vulnerabilities. These were often carried out by a combination of malforming
HTML, CSS, Javascript, or all of the above. Google has now moved to Chrome as the default
browser, but the potential of a vulnerability in such a frequently used code based is so great, that
Lollipop checks and automatically updates Chrome indepedently of the rest of the OS.

It's worth noting that code injection can also exist in the boot loader phase. Such a vulnerability
could offer the same effect as unlocking the bootloader - i.e. booting into any configuration desired -
but without effacing data, and thereby compromising the user's data.

The Android approach to security

In security, the union of two elements does not necessarily make them secure. Quite the
contrary, in fact, as it suffices that one of the elements contains a vulnerability, in order for the
entire system to be compromised. Android has learned this oh-so-well over its relatively short
existence, as its security has been broken time and time (and time) again, despite significant
improvements with each version. Sometimes, the vulnerability lay in Android itself, and other times
in the underlying Linux. It follows, therefore, that Android security must incorporate both worlds -
Linux and its own - and combine them together as efficiently and as securely as possible.

���

&KDSWHU�9,,,��6HFXULW\



Security at the Linux Level

Android builds a rich framework on top of the Linux substrate, but at its core, relies on Linux for
virtually all operations. The Linux inheritance also binds Android to use the same security features as
those offered by Linux - the permissions, capabilities, SELinux, and other low-level security
protections.

Linux Permissions

The security model of Linux is a direct port of the standard UN*X security model. This model,
which has remained largely unchanged since its inception some 40 years ago, provides the following
primitives:

Every user has a numeric user id: The actual user name doesn't matter, though some
usernames are reserved for system users (which are designated the owners of configuration
files and directories). Two users may share the same user id, but this in effect means that, as
far as the system is concerned, this represents a single user with two username/password
combinations.

Every user has a numeric primary group id: Much like the username, the group name
doesn't matter, and some GIDs are reserved for system use.

Users may hold memberships in additional groups: Traditionally, additional group
memberships is maintained by the /etc/group file. It lists the group names, group ids, and any
members who are not already in a group by virtue of the primary GID.

Permissions on file are granted for a specified user, group, and "other": This is the
familiar output of " ", which maps the permissions (read, write or execute) to the user
and group, and the "rest of the world". Both files and directories follow this extremely limited
model, for which UN*X has been duly criticized. Because of its limitations, file access
requirements basically force the creation of specialized groups

(Almost) everything in UN*X can be accessed as files: It thus follows that access to
system resources - named IPC objects, UNIX domain sockets, and devices - is a corrolary of
file permissions. In other words, since the resources have a filesystem representation they
can be ed just as files can be, and have the same type of permissions.

UID 0 is omnipotent: Because of the way permission checks are implemented, "0"
effectively short circuits the checks and grants access to all files, or resource. What follows is
that uid 0 (the "root" user) wields power absolute over the system.

SetUID or SetGID binaries allow assuming another uid (or joining another group)
during their execution: with no questions asked. Having execute permission to a Set[ug]id
binary will automatically bestow those special permissions. This mechanism, which rightfully
looks like a gaping design flaw, is actually a feature, used to work around privileged
operations, such as changing one's uid ( ) or password ( ). Such operations - by
definition - are only possible for uid 0, but can be enabled if the root user empowers specific
binaries (by xxx and xxx, for SetUID and SetGID, respectively). As a precaution,
copying or moving the binaries will strip those bits.

Android takes the classic model - which it obtains for free from the underlying Linux system -
and naturally employs it, but offers a different, somewhat novel interpretation: In it, the "users" are
granted to individual applications, not human users. Suddenly, much in the same way as human
users sharing the same UN*X server were comparmentalized from one another, applications enjoy
(and are limited by) the same seclusion. A user cannot access another user's files, directories, or
processes - and this exact isolation enables applications to run alongside eachother, but with no
power to influence one another. This approach is quite unique to Android - iOS runs all applications
under one uid (mobile, or 501) and relies on kernel-enforced sandboxing to isolate applications from
one another.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



When an application is installed for the first time, the PackageManager assigns it a unique user
id - which is understandably referred to as an application id. This id is taken from the range of
10000-90000, and bionic - the Android C runtime library - automatically maps this to a human
readable name - app_XXX or u_XXXX.

Android can't get rid of SetUID support entirely - because this requires recompilation of the
kernel and other modifications. Beginning with JB 4.3, however, no SetUID binaries are installed by
default, and the /data partition is mounted with the  option.

System defined AIDs

Android maintains the lower range of user ids - 1000-9999 - exclusive for system use. Only a
subset of this range is actually used, and it is hardcoded in android_filesystem_config.h. Table 8-1
shows the UIDs defined and used by Android. Most of these are used as GIDs as well: By joining
secondary groups, system processes like , ,  and others gain the
ability to access system files and devices, which are owned by these groups - a simple yet effective
strategy.

Table 8-1:: Android AIDs and their default holders

GID #define Members Permits

1001 /dev/socket/rild (To Radio Interface Layer Daemon)
Access net.*, radio.* properties

1002 Bluetooth configuration files

1003 /dev/graphics/fb0, the framebuffer

1004 /dev/input/*, the device nodes for input devices.

1005 /dev/eac, or other audio device nodes
access /data/misc/audio, read /data/audio

1006 Access to camera sockets

1007 /dev/log/*

1008 Compass and location services

1009 /dev/socket/vold, on the other side of which is the VOLume
Daemon

1010 WiFi Configuration files (/data/misc/wifi)

1011 Reserved for ADBD. Owns /dev/android_adb.

1012 Owns some application data directories

1013 Access /data/misc/media, and media.* service access

1014 Access /data/misc/dhcp
Access dhcp properties

1015 Group owner of emulated SDCard

1016 /data/misc/vpn, /dev/ppp

1017 Access /data/misc/keystore (system keystore)

1018 USB Devices

1019 Access to /data/drm

1020 Multicast DNS and service discovery

1021 Access /data/misc/location

1023 Group owner of /data/media and real SDCard

1024 MTP USB driver access (not related to mtpd)

���

&KDSWHU�9,,,��6HFXULW\

http://newandroidbook.com/src/Android/system/core/include/private/android_filesystem_config.h


Table 8-1 (cont):: Android AIDs and their default holders

1026 DRM RPC

1027 Near Field Communication support: /data/nfc, and nfc
service lookup

1028 external storage read access

1029 CLAT (IPv6/IPv4)

1030 Loop Radio devices

1031 DRM plugins. Access to /data/mediadrm.

1032 Package information metadata

1033 PICS folder of SD Card

1034 Audio/Video folders of SD Card

1035 All SDCard folders

Android system properties also rely on UIDs for access control - init's property_service limits
access to several property namespaces, as was shown in Chapter 4. It likewise falls on the

, as the crux of all IPC, to provide basic security. Though the Binder eventually
provides security through a uid/pid model,  can restrict the lookup of well known
service names to given uids, though uid 0 or SYSTEM are always allowed to register. Up to and
including KitKat, this was in a hard-coded  array, as shown in Listing 8-1:

Listing 8-1: Hard-coded service permissions (from service_manager.c) on KK

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html#4-propn
http://newandroidbook.com/src/Android/frameworks//native/cmds/servicemanager/service_manager.c


With the introduction of SE-Linux, and the slow but steady migration of Android to it, the hard-
coded method has been finally abandoned, in favor of integration with an SE-Linux policy, much in
the same way as init's properties have. At any rate, it's important to note this is but one layer of
security:  refuses to allow untrusted AIDs to register well known names. As we
discuss later, the Binder allows both client and server to perform additional permission checks, and
an additional layer of Dalvik-level permissions is also employed.

Paranoid Android GIDs

Android GIDs of 3000 through 3999 are also recognized by the kernel, when the
 is set. This restricts all aspects of networking access to these GIDs

only, by enforcing additional gid checks in the kernel socket handling code. Note that 
overrides these settings, because it is running as root. Table 8-2 shows the known network ids

Table 8-2: Android Network-related AIDs and their holders

GID #define Members Permits

3001 Creation of AF_BLUETOOTH sockets

3002 Creation of sco, rfcomm, or l2cap sockets

3003 /dev/socket/dnsproxyd, and AF_INET[6] (IPv4,
IPv6) sockets

3004 Create raw (non TCP/UDP or multicast) sockets

3005 Configure interfaces and routing tables

3006 Reading bandwidth statistics accounting

3007 Modifying bandwidth statistics accounting

Isolated Services

As of Jelly Bean (4.1) Android introduces the notion of isolated services. This feature is a form
of compartmentalization (similar to iOS's XPC) which enables an application to run its services in
complete separation - in a different process, with a separate UID. Isolated services use the UID
range of 99000 through 99999 (  through ), and the servicemanager
will deny them any request. As a consequence, they cannot lookup any system services, and are
effectively limited to in memory operations. This is primarily useful for applications such as web
browsers, and indeed Chrome is a prime example of using this mechanism. As shown in output 8-1,
isolated services are marked as u##_i##:

Output 8-1: Chrome's isolated services

���

&KDSWHU�9,,,��6HFXULW\

file:///Users/morpheus/Documents/Android/Book/IPC.html#security
file:///Users/morpheus/Documents/Android/Book/Security.html#DalvikLevel


Root-owned processes

As with Linux, the root user - uid 0 - is still just as omnipotent - but far from omnipresent: Its
use is limited to the absolute bare minimum, and that minimum is shrinking from one Android
release to another. Quite a few previous Android exploits targetted root-owned processes (with vold
being a perennial favorite), and the hope is that by reducing their number, the attack surface could
be greatly reduced. The  is an example of such a process, whose root privileges have
been removed beginning with JellyBean.

It is likely impossible to remove all root owned processes: At the very least, init needs to retain
root capabilities, as does Zygote (whose fork() assume different uids, something only uid 0 can do).
You can see the root owned processes on your device by typing

(The  ignores kernel threads, whose PPID is 2).

Table 8-3 shows the services which still run as root by default in KitKat (but note your device
may have more, as added by the device vendor)

Table 8-3: Android services still running as root

Service Rationale

init Somebody has to maintain root privileges in the system and launch others - might as well
be PID 1

ueventd (init) Minimal operation

healthd Minimal operation

zygote[64] Requires setuid() to change into AID when loading APKs, retains capabilities for

debugger[64] Requires root privileges to use , in order to read process memory when
generating tombstones

adb
Developers may need legitimate root access; 
system trusts ADB to immediately drop privileges to  if  is 0 or

 is 1

vold [Un/]Mounting filesystems, and more.

netd Configuring interfaces, assigning IPs, DHCP and more

lmkd Adjusting OOM settings, possibly killing other processes

As stated back in Chapter 2, the vendor binaries greatly increase the attack surface of Android,
especially when they are run as root. What exacerbates the matter is that, whereas the AOSP
binaries remain open source and therefore easy to analyze for security by all, the vendor binaries
are closed source - and some vendors sacrifice security in favor of functionality. When you hear of a
specific vulnerability in a device (e.g. HTC One M8), rather than a version of Android, it is very likely
the cause lies within a vendor binary.

Eventually, it is expected that Android will leave only those services which absolutely must
have root, and others will follow in the steps of . To do so, Android will have to increase
its usage of another important Linux security feature - Capabilities.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Linux Capabilities

Originally part of the POSIX.1e draft (and thus meant to be incorporated as a standard for all
UN*X), capabilities were an early adoption into the 2.2 line of kernels. Though the POSIX draft was
eventually withdrawn, capabilties remained implemented in Linux, and have since been expanded
and improved on. Distributions of Linux don't make use of capabilities all that often, but Android
makes extensive use of them.

The idea behind capabilities is to break the "all-or-nothing" model of the root user: The root
user is fully omnipotent, whereas all other users are, effectively, impotent. Because of this, if a user
needs to perform some privileged operation, the only standard solution is to resort to SetUID -
become uid 0, for the scope of the operation, then yield superuser privileges, and revert to a non-
privileged user. This holds true for even relatively simple operations: Setting the system time,
binding privileged (< 1024) network ports, mounting certain filesystems, and more. As a result,
UN*X systems traditionally contained a very large number of SetUID binaries.

If a SetUID binary can be trusted, then - in theory - the model should work. In practice,
however, SetUID poses inherent security risks: If a SetUID binary is somehow exploited, it could be
tricked into compromising root. Common tricks include symlinks and race conditions (diverting the
binary to overwrite system configuration files), and code injection (forcing the binary to execute a
root shell - hence the term "shellcode" for injected code).

Capabilities offer a solution to this problem, by "slicing up" the powers of root into distinct
areas, each represented by a bit in a bitmask, and allowing or restricting privileged operations in
these areas only, by toggling the bitmask. This makes them an implementation of the principle of
least privilege, a tenet of security which dictates that an application or user must not be given any
more rights than are absolutely required for its normal operation. You can see a logical view of
capabilities in Figure 8-1:

Figure 8-1: A logical representation of capabilities

���

&KDSWHU�9,,,��6HFXULW\



Restricting a subset of allowed privileges to only those absolutely required, while revoking the
rest, increases security significantly. Even if a given application or user ends up being malicious (or
cajoled to the dark path by code injection), its scope of damage is compartmentalized. Capabilities
are like a sandbox, allowing only those operations which an app, by design, requires - while at the
same time preventing it from running amuck and compromising system security. In fact, a nice side
effect of capabities is that they can be used to restrict the root user itself, in cases where the user
behind the uid is not fully trustworthy.

init still starts most of Android's server processes as root, and these processes have the full
capabilities bitmask ( ) as they launch. Before these processes actually do
anything, however, they drop their privileges, and retain only the capabilities they need. A good
example of adhering to the principle of least privilege can be seen in , which makes sure
to drop all but the privileges it needs for package installation:

Listing 8-2: Installd's usage of capabilities

The heaviest user of capabilties is, unsurprisingly, , since it is a 
owned process, but still needs root privileges for many of its normal operations. Table 8-4 shows the
Linux capabilities, and the Android processes known to use them:

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Table 8-4: Linux capabilities used by Android processes

capability #define Users Permits

0x01 Change file and group ownership

0x02 Override Discretionary Access Control on
files/dirs

0x20 Kill processes not belonging to the same uid

0x40 allow setuid(2), seteuid(2) and setfsuid(2)

0x80 allow setgid(2) and setgroups(2)

0x400 Bind local ports at under 1024

0x800 Broadcasting/Multicasting

0x1000 Interface configuration, Routing Tables, etc.

0x2000 Raw sockets

0x10000 Insert/remove module into kernel

0x800000 Set process priority and affinity

0x1000000 Set resource limits for processes

0x2000000 Set real-time clock

0x4000000 Configure/Hangup tty devices

0x400000000 Configure kernel ring buffer log (dmesg)

0x1000000000 Override�0$& policies��DFWXDOO\�LJQRUHG�

Note, that table 8-4 provides a limited (albeit large) subset of the Linux capabilities. It is likely
that over the evolution of both Linux and Android more capabilities will be added. The following
experiment demonstrates how you can see capabilities used by processes:

Experiment: Viewing capabilities and group memberships

You can easily view system_server's capabilities and group memberships (or those of any
other process, for that matter), by looking at /proc/${PID}/status, replacing ${PID} with the pid of
the process in question:

Output 8-2: Viewing system_server's capabilities and group memberships

In the above, you can see four bitmasks for capabilities: Those inheritable by child process,
those potentially permitted for this process, those actively in effect (as in, permitted and also
explicitly required by the process), and the bounding set. The bounding set (added in Linux
2.6.25) is a bitmask which limits the usage of ).

���

&KDSWHU�9,,,��6HFXULW\



Beginning with JB (4.3),  calls  and
, to ensure that no further capabilities can be added to its child

processes (i.e. the user apps). It is likely that, going forward,  and  will both drop their
privileges and rely on capabilities, rather than retain their root privileges. This is especially important
considering 's history of vulnerabilities.

Experiment: Viewing capabilities and group memberships (cont.)

By looking over PIDs in /proc, you can single out the processes which use capabilities. This requires a bit of
shell scripting, as shown in the following output:

Output 8-3: Processes with capabilities

As the above showV, the capabilities are in line with Table ���. Note that some vendors (above, HTC) may�
add their own processes (above, qseecomd) with additional capabilities.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

  

 

 

 

 

 

 

 

  



Figure 8-2: The SELinux logo

SELinux

SELinux - Security Enhanced�/LQX[ - marks a step further in the evolution
of Linux beyond standard UN*X. Originally developed by the NSA,
SELinux is a set of patches which have long since been incorporated into
the mainline kernel, with the aim of providing a Mandatory Access
Control (MAC) framework, which can restrict operations to a predefined
policy. As with capabilities, SELinux implements the principle of least
privilege, but with much finer granularity. This greatly augments the
security posture of a system, by preventing processes from operating
outside strictly defined operational bounds. So long as the process is
well behaving, this should pose no problem. If the process misbehaves,
however (as most often is the case of malware, or the result of code injection), SELinux will block
any operation which exceeds those bounds. The approach is very similar to iOS's sandbox (which
builds on the TrustedBSD MAC Framework), though the implementation is quite different.

Though long included in Linux (and, like capabilities, not always implemented by default),
SELinux was introduced into Android with JellyBean (4.3). The initial introduction was gentle -
setting SELinux in permissive mode, wherein any violations of the policy are merely audited. With
KitKat (4.4), however, SELinux now defaults to enforcing mode for several of Android's services
(specifically, , ,  and ), though still permissive for all other processes.
In general, it is considered a good practice to use the per-domain permissive mode, in order to test
a policy before setting it to enforcing, and it is likely that enforcement will expand with the next
version of Android.

SELinux's port to Android - commonly referred to as SEAndroid - was first described in a paper1a

and a presentation1b by Smalley and Craig of the NSA (who have followed up on SEAndroid with an
excellent presentation in the 2014 Android Builders Summit1c). Google provides basic documentation
in the Android Source site2. Of the mainline Linux distributions RedHat has been an early adopter,
and provides a comprehensive guide3.

SEAndroid follows the same principle of the original, but extends it to accommodate Android
specific features - such as system properties, and (naturally) the Binder (via kernel hooks). Samsung
further extends SEAndroid, and uses it as a foundation for their "KNOX" secure platform (currently in
v2.0). KNOX (referred to by some as "obKNOXious" :-) boasts a stronger security policy, enforcing
and confining all processes (except init and the kernel threads). In the following discussion,
"SELinux" refers to those features found in both Linux and Android, whereas "SEAndroid" refers only
to the latter.

The main principle of SELinux (and, in fact, most MAC frameworks) is that of labeling. A label
assigns a type to a resource (object), and a security domain for a process (subject). SELinux can
then enforce so as to allow only processes in the same domain (likewise labeled) to access the
resource (Some MAC Frameworks go as far as to make resources with different labels invisible,
somewhat akin to the Linux concept of namespaces, although SELinux does not go that far).
Depending on the policy, domains can also be made confined, so that processes cannot access any
resource but those allowed. The policy enforcement is performed independently of other layers of
permissions (e.g. file ACLs). The policy may also allow relabeling for some labels (relabelto and
relabelfrom, also called a domain transition) in some cases, which is a necessary requirement if a
trusted process (e.g. Zygote) spawns an untrusted one (virtually any user application).

An SELinux label is merely a 4-tuple, formatted as a string of the form
user role type level. All processes with the same label (i.e. in the same domain) are
equivalent. SEAndroid (presently) only defines the type - i.e. the label is always in the form

domain . As of KitKat, the SEAndroid policy defines individual domains for all daemons (i.e.
each daemon gets its own permissions and security profiles), along with the domains shown in table
8-5, for application classes.

���

&KDSWHU�9,,,��6HFXULW\

http://www.internetsociety.org/sites/default/files/02_4.pdf
http://www.internetsociety.org/sites/default/files/Presentation02_4.pdf
http://events.linuxfoundation.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf
http://source.android.com/devices/tech/security/se-linux.html
https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/


Table 8-5: The application class domains in Android 4.4

Label (domain) Apps Restrictions

Reserved for kernel
threads Unconfined (God Mode)

Isolated processes Previously connected anonymous UNIX sockets,
read/write

signed with media key

Allowed to access network
signed with platform key

signed with shared key

signed with release key

All other Access ASEC, SDCard, TCP/UDP sockets, PTYs

The keys referred to in table 8-5 are defined in /system/etc/security/mac_permissions.xml, which
is part of the middleware MAC (MMAC) implementation: The Package Manager recognizes the
keys used for signing apps, and labels the applications accordingly (using a call to

. This is done during package scanning (part of the package
installation, as described in Volume II). Note the term middleware here applies to labeling
performed strictly in user mode by the Android system components.

All the  domains inherit from the base , which allows the basic application
profile, including actions such as using the binder, communicating with zygote, sufraceflinger, etc.
You can find the type enforcement (.te) files, which contain the detailed definitions for all domains,
in the AOSP's external/sepolicy directory. The syntax used in those files is a mixture of keywords and
macros (from temacros), which allow or deny operations in the domain, as shown in Listing 8-3:

Listing 8-3: Sample te file (debuggerd.te)

The files in external/sepolicy form the baseline, which all devices are meant to automatically�
inherit from. Rather than modify them, vendors are encouraged to add four specific variables in
their BoardConfig.mk file, specifying , to override,
add or omit files from the policy, and  to provide the search path for the
directories containing their files. This mitigates the risk of an accidental policy change due to file
error, which may result in security holes. The directory also contains the mac_permissions.xml
template, which is populated with keys in keys.conf.

The stock type enforcement files are all concatenated and compiled into the resulting /sepolicy
file, which is a binary file placed on the root file system. Doing so offers further security, because
the root filesystem is mounted from the initramfs, which is itself part of the , that is
digitally signed (and therefore hopefully tamperproof). The compilation is performed merely as an
optimization, and the resulting file can be easily decompiled, as is shown in the experiment sec-
dispol. The binary policy file can be loaded through /sys/fs/selinux (though init most commonly does
so through ).

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



What remains, then, is to define the process of assigning the labels to resources, through
contexts. The resources recognized by SELinux are Linux file objects (including sockets, device
nodes, pipes, and other objects with a file representation), and SEAndroid extends this further to
allow for properties.

Experiment: Decompiling an Android /sepolicy file

If you have a Linux host, decompiling an /sepolicy can be performed with the  command,
which is part of the  package. Assuming Fedora or a similar derivative, this first involves
getting the package, if you don't already have it:

Output 8-4: Obtaining the  package

Once you have the command, all you need is to transfer the policy to the host, and start examining it
(the command is an interactive one). Though the policy is usually the one defined in /sepolicy, you can
get the actively loaded policy through sysfs, as well. The /sys/fs/selinux/ directory will contain many
interesting entries used for configuring (and potentially disabling) SELinux, of which one is the actively
loaded policy. This will require you to do something similar to the following:

Output 8-5: Decompiling/Disassembling the active policy

���

&KDSWHU�9,,,��6HFXULW\



Application Contexts

The /seapp_contexts file provides a mapping of applications (in the form of UIDs) to domains.
This is used to label processes based on the UID, and the seinfo field (as set by the package
manager, according to the package signature as it correlates with
/system/etc/security/mac_permissions.xml). You can see the labeling of processes with the toolbox's

:

Output 8-6: SELinux process contexts with 

File Contexts

SE-Linux can associates every file with a security context. The /file_contexts file provides all the
contexts for protected files, and the  switch of 's  can display them, as shown in the
following:

Output 8-7: SELinux file contexts with 

Property Contexts

As discussed in Chapter 4, init's property service restricts access to certain property
namespaces by a hard coded uid table. This is a very rigid mechanism, and hardly scalable as new
properties and namespaces are added in between Android releases.

Since SELinux already provides the notion of execution contexts, it is trivial to extend them to
properties, as well. As of JellyBean, /init protects access to properties by a 
boolean. The function loads the property contexts from two files - /data/security/property_contexts
(when present), and /property_contexts.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

/file_contexts

file:///Users/morpheus/Documents/Android/Book/Services.html#4-propn


Output 8-8: SELinux Property contexts

If you go back to Chapter 4, you'll see that the property contexts essentially mirror the
definitions in the table. The main difference, however, is that providing the contexts in an external
file provides a far more extensible way of changing and modifying properties - all without a need to
recompile /init.

init and toolbox commands

Recall from Chapter 4 that the Android /init has a rich variety of commands, which may be used
in its .rc files. With the introduction of SELinux, additional commands have been added to allow for
SELinux contexts. Toolbox has likewise been modified to allow SELinux modifications from the shell.
Table 8-6 shows these commands

Table 8-6: init and toolbox commands for SELinux

init Toolbox Usage

N/A Get SELinux Enforcement status

SEcontext N/A Set (change) SELinux context. Init uses

path Restore SELinux context for path

[0|1] Toggle SELinux enforcement on/off

name value name value Toggle boolean value (0/false/off or 1/true/on)

Note you can achieve most of the functionality of the SELinux commands by accessing files in
/sys/fs/selinux (which is, in fact, what some of these commands do), though this would require both
root access and an unconfined domain. /init, which remains unconfined, can also relabel processes
(as it does for services with the  option, and additionally provides the

 property trigger to reload the policy. Disabling SELinux altogether can
be accomplished through /sys/fs/selinux/disable, or through the kernel command line argument

.

���

&KDSWHU�9,,,��6HFXULW\

file:///Users/morpheus/Documents/Android/Book/Services.html#4-propn
file:///Users/morpheus/Documents/Android/Book/Services.html#4-initcs


Other noteworthy features

Linux has some additional settings which Android enables, which aim to improve security by
hardening otherwise insecure defaults. This section discusses them briefly.

AT_SECURE

The Linux Kernel's ELF loader uses an auxilliary vector to provide metadata for the images it
loads. This vector can be accessed through the /proc filesystem (as /proc/pid/auxv. One of its entries,

 is set to a non-zero value for set[ug]id binaries, programs with capabilities, and
programs which force an SELinux domain traversal. In those cases, Bionic's linker
(/system/bin/linker) is configured to drop "unsafe" environment variables (a hard coded list in the
__is_unsafe_environment_variable function, in bionic/linker/linker_environ.cpp. Chief amongst the
variables are  and , a favorite technique for library injection.

Address Space Layout Randomization

Code injection attacks use the target process' address space as their playing field, and their
success often depends on intimate knowledge of its details - addresses, regions and protections.
This is because injection attacks either directly add code into an existing program, or subvert its
execution so as to jump to already existing regions. In both cases, knowledge of the layout is vital,
because jumping to an incorrect address will lead to a crash. Normally, since process launch
deterministically into a private address space, a hacker can (to paraphrase an old java motto)
"debug once, hack everywhere".

Address Space Layout Randomization (ASLR) attempts to make injection attacks harder by
introducing randomness - shuffling the layout of memory regions, making their addresses less
predictable. This increases the chance a targetted piece of code will be "shifted" in memory, and
basically trade a crash in place of compromise by malicious code - a lesser evil, by all counts.

Linux offers randomization capabilities through /proc/sys/kernel/randomize_va_space (or 
). The value "0" specifies no randomization, "1" specifies stack

randomization, and "2" specifies both stack and heap, which is the default. Executables can also be
compiled with the PIE (Position-Independent-Executable) option (the -pie switch), which is
mandatory as of Android L (defined as APP_PIE in the Android.mk files).

Experiment: Testing ASLR

To see the effects of ASLR, you can use the following shell script over /proc. The script
iterates over all processes, finds the location of libc.so in it (only the text section, as filtered by the

), and displays it along with the PID if found:

Output 8-9: Showing the effects of ASLR

As the output shows, the library is often randomized, yet some processes still share the same
location for libc - those are the spawns of the zygote, which  to load a class, but does not
call  - and hence remains with the same address space layout.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Kernel-space ASLR has yet (at the time of writing) to make it into Android. Introduced for the
first time in iOS 6.0, it eventually made it into Linux with version 3.14 (which is actually the most
recent at the time these lines are being typed). It is quite likely to be introduced into Android with
the version to follow KitKat.

ASLR provides a layer of defense only against code injected through an input vector.
If an adversary already has execution privileges, s/he can invoke the powerful

 APIs to read the address space of other processes, and even inject remote
threads. Thankfully, one has to obtain root privileges first. SELinux can (and should!) be
used to prevent access to  altogether.

Kernel hardening

Unlike mainline Linux, Android kernels export no /proc/kcore by default, as this entry allows
kernel read-only memory access from user mode (by root). The /proc/kallsyms is still present in most
devices (and actually world readable by default), but protected by the kernel.kptr_restrict sysctl,
which is set by default to 2, to prevent any addresses from being displayed. Kernel ring-buffer
access (via the dmesg) is likewise protected by kernel.dmesg_restrict.

Stack protections

As sophisticated as attacks can get, they still (for the most part) rely on overwriting a function
pointer, which - when called - causes a subversion of the program flow. Not all programs use
function pointers, but all utilize the return address, which is stored on the stack during a function
call.

As a countermeasure to this, most modern compilers offer automatic stack protection, by
means of a canary. Like the proverbial canary in the coal mine, a stack canary is a random value
written to the stack upon function entry, and verified right before the function returns. If the value
cannot be verified, the stack is deemed corrupt, and the program voluntarily aborts, rather than
potential trigger malicious code.

This form of protection has been available in Android since its early days, with gcc's 
. Note that it does not provide a panacea, since code can still be injected via function

pointers aside from the return address (C++ methods make good candidates).

Data Execution Prevention

Code injection attacks rely on embedding malicious code inside input - whether direct from the
user or from other sources. Input, however, is data - and memory used for data (the heap and the
stack) can be flagged as non-executable. This complicates attacks somewhat, because just using the
classic trampoline technique (overwriting a pointer or the stack return address with the address of
the injected code) won't work if the injected code is in the data segment.

Unfortunately (for most), while making data non-executable complicates the simple attacks, 
attacks have considerably evolved. The current counterattack is Return-Oriented-Programming 
(ROP), a fairly old technique (introduced by Solar Designer in a '00 paper as return-to-libc), which 
strings together "gadgets" of calls back into existing portions of code in the program, simulating 
function calls on the stack. Because these are calls into code, there's nothing to make non-
executable, and thus the protection can be fairly reliably circumvented.

Compiler-level protections

All the above protections are, in a way, treating the symptoms, rather than the disease. At the
end of the day, the only proper ways to combat code injection attacks which exploit memory
corruption is to exercise defensive coding, which involves input validation and strict bounds checking
on memory operations. Newer versions of Android have taken that to heart, with the source
compiled with enhanced checks, most notably  and ,
which add additional checks on memory copying functions, and prevent format string attacks.

���

&KDSWHU�9,,,��6HFXULW\



Security at the Dalvik Level

Dalvik Level Permissions
Working at the level of a virtual machine, rather than native code, brings with it tremendous

advantages for monitoring operations and enforcing security. At the native level, one would have to
monitor system calls for any significant resource access. The problem with system calls, however, is
that their granularity is inaccurate. File access is straightforward (open/read/write/close), but other
operations, (e.g. a DNS lookup) are a lot harder to monitor, as they involve multiple system calls.
Therein lies the advantage of the Virtual Machine - most operations are carried out by means of pre-
supplied packages and classes, and those come built-in with permission checks.

Android actually takes this a step further: Whereas in a normal Java class a malicious developer
could ostensibly import other classes, implement functionality from scratch or use JNI (to break out
of the VM), in order to avoid permission checks, though this is next to impossible in Android: The
user application is entirely powerless, devoid of all capabilities and permissions at the Linux level, so
any access to the underlying system resources should be blocked right there. In order to carry out
any operation which has an effect outside the scope of the application, one has to involve

, by calling .

While any app can freely invoke a call to , none has access to its defined 
permissions - which  will check. This check is performed outside the application's 
process, so the application has no plausible avenue by means of which it may somehow obtain 
those permissions, unless they were a priori assigned to it. The assignment is performed when the 
application is loaded and installed - meaning that the user has been notified of the application's 
requested permissions,(has hopefully read through the very long list), and approved them (again, 
hopefully knowing the ramifications of hitting "OK") . If the permission requested during runtime
has been revoked (for example, through the AppOps service or through ), a security 
exception will be thrown (normally, this will crash the application, unless the developer braced for 
such an exception, in which case it may handle the exception, usually popping up an explanation on 
what permission was required, or at other times failing silently).

What follows is that the permissions themselves need no special data structures or complicated
metadata. A permission in Dalvik is nothing more than a simple constant value, which is granted to
an application in its manifest, as it declares it . An application can likewise�
define its own constants (as  tags in the Manifest). When the Package Manager�
installs an app, it adds the permissions of said app to the "permissions database", which is in effect�
part of the package database, /data/system/packages.xml. This database contains a lot more valuable�
information (including public keys) than just permissions (which is why it is discussed in detail in�
Volume II), but the pertinent portions of it are shown in Table 8-�:

Table 8-7: The elements pertaining to permissions in the package database

Element Contains

permission-trees An array of tree , specifying permission namespaces, and the packages wKich�
define them

permissions

An array of permission s, each of which defines:

 - The permission constant name, as defined in its original 
element

 - The package which defined this permission (with "android" for SDK
permissions)

 - which defines the permission protection level and flags from the
 class. Permissions levels are 0 ( ), 1

( ), 2 ( ) or 3 ( ), with flags
for  (0x10) and  (0x20). Note the value is printed as a
decimal integer, when in fact it should be hexadecimal.

���

* - Android M finally fixes this naive and broken model, followin  i S's desi n of enforcin  permissions durin  runtime,
promptin  the user durin  the action, with the help of an out-of-process entity (in i S this is handled by the TCC daemon).

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/base/core/java/android/content/pm/PermissionInfo.java


Table 8-7 (cont.): The elements pertaining to permissions in the package database

Element Contains
package Each installed application is identified by its  attribute (reverse DNS name of

package) and assigned an AID via the  attribute. Specific permissions granted to
the application are listed as items in the  child element.

shared-user AIDs shared between two or more applications are specified by the  attribute,�
and once more specific permissions are granted - this time to the AID (i.e. all�
applications sharing it) as items in the  child element.

If you inspect the package database (as root), you will find that the  element
contains both custom permissions (i.e. those declared by installed Apps) and system ones. The built-
in system permissions, along with protected broadcasts, are specified in the
/system/framework/framework-res.apk, which can be examined using , as shown in the following
output:

Output 8-10: Dumping the /system/framework/framework-res.apk from a Nexus 9

As the above shows, permission are bundled into groups, with flags* defined both at the group
level (through ) and at the individual level
(through ). This bundling and categorizing comes in
handy for the power user, who is expected to use the  upcall script to display or manage
permissions.

���

&KDSWHU�9,,,��6HFXULW\

* - Make that �flaG�, since at the present time only  (group) and  (permission)
are used. But this scheme does allow for future extension



Experiment: Using the  command

You can use  to display permissions, both of the Android
frameworks, and of third party applications. To do so, try:

Output 8-11: Listing permissions with 

Other useful switches include  (verbose human readable output in your locale), 
(permission groups). The  command can also be used to grant and revoke optional permissions 
( ) and even toggle permission enforcement (i.e. 

). The full syntax of this 
command, including some notable changes made for Android M, is explained in Volume II.

The AppOps service (detailed in Volume II) provided a powerful GUI by means of which users
could track and fine-grain tune application permission usage. The GUI has been removed as part
of KitKat's 4.4.2 "security update", but the service is alive and well. In fact, Lollipop introduces the

 upcall script, which can be used to allow, deny, ignore or reset an application's
permissions. Unfortunately, the command line only allows a small subset of operations (

 and  and
), but those could be extended to the full set of (presently) 48

operations by recompiling . Note, however, that  is
another layer on top of the permissions - and uses a separate database (/data/system/appops.xml).
This is shown in Output 8-12:

Output 8-12: Demonstrating the  upcall script in L

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Mapping permissions to Linux UIDs

The /system/etc/permissions/platform.xml file acts as a "glue" between Dalvik level permissions
and those of Linux. The file is included in the AOSP sources, and is well documented so that vendors
can (carefully) add any specific permissions or AIDs. The mapping works both ways - that is, a given

 can be set to grant membership to a , and vice versa by using 
 to a given named permission to a uid. Listing 8-4 shows a sample of this file:

Listing 8-4: An example /system/etc/permissions/platform.xml file

If you check the /system/etc/permissions/ directory on your device, you will likely find several
more XML files - android.hardware.* and android.software.*, copied during the build process from the
AOSP files, as well as possibly some vendor provided files.

���

&KDSWHU�9,,,��6HFXULW\



Dalvik Code Signing

Permissions by themselves are somewhat useless - after all, any app can declare whatever
permissions it requires in its AndroidManifest.xml, and the unwitting user will probably click "ok" when
prompted. To bolster security, Google requires digital signatures on applications uploaded to the
Play store, so as to identify the developer(s) behind them, and add accountability.

Thus, all Android applications must be signed (with the process explained in Volume II. What's
not so clear is - by whom. As Google was playing catch-up to Apple and opened the Play Store, it
wanted to offer an advantage to developers, in the form of a simpler process. As opposed to Apple's
lengthy validation process - all apps must be vetted by Apple, and digitally signed by them, Google
offered anyone the ability to just create a key pair, publish their public key, and use the private key
to sign their APK file. The rationale was that this achieves a similar level of identifying the APK's
source, while at the same time greatly simplifying the process of submitting applications to the
Store.

In practice, this led to an explosion of Malware in the Play Store. The Google approach was that
any malware found and reported would be removed from the Store, and the corresponding public
keys blacklisted. From the malware author's side, this was a case of "better to beg forgiveness than
ask permission" - as the malware by then would have likely propagated by the time it was detected,
thus achieving its purpose. This, coupled with the fact that a malware developer could always
generate a new key pair, hollowed out the entire security model. A recent study published in RSA
20144 found that "malicious apps have grown 388 percent from 2011 to 2013, while the number of
malicious apps removed annually by Google has dropped from 60% in 2011 to 23% in 2013", and
that effectively one out of every 8 apps in the store is, in fact, malicious.

The Android "Master Key" vulnerability

One of the most serious vulnerabilities discovered in Android (in 2013) is what came to be
known (somewhat erroneously) as the "Master Key Vulnerability". The vulnerability (discovered by
BlueBox security5a, and refined (among others) by Saurik5b, the noted creator of iOS Cydia) occurred
in of mishandling of APK files which contained files with duplicate names. APKs are ZIP files, and
normally most utilities - aapt included - would not allow duplicate file names in the same zip.
Technically, however, it is possible, and introduced a peculiar vulnerability: File signature verification
was performed on the first entry in the APK, whereas extraction was performed on the second! This
oddity was due to two different libraries - Java's and Dalvik's native implementation - being used for
the tasks. As a consequence, it followed that anyone could take a validly signed APK file, and just
add additional files with the same names as the original (including classes.dex, of course). This
effectively bypassed Android's signature validation on APKs. Though fixed, the bug is a great
example of oftentimes gaping vulnerabilities which need little to no technical knowledge in order to
exploit.

The Android "Fake ID" vulnerability

The 2014 counterpart of the "Master Key" vulnerability became known as the "Fake ID"
vulnerability. This time, a fault in Android's certificate validation allows the forgery of an application's
identity, by supplying a deliberately broken certificate chain: Packing a malicious app (with a fake
certificate) along with a real (though unrelated) one, or even several. As a consequnce, a malicious
app could inherit the permission sets given to trusted apps (the example commonly given was
impersonating Adobe's components and becoming a WebKit plugin).

The vulnerability (also discovered by BlueBox6) generated a big buzz at the Black Hat�
conference of that year, especially considering it was exploitable for almost four years - since�
Eclair(!) - at the time affecting all devices on the market - up to and including KitKat. Google�
eventually patched this, and it is no longer an issue with L - but �DORQJ�ZLWK�QXPHURXV�RWKHU�
H[DPSOHV��it just comes to show that security�vulnerabilities do abound*.

* - As an anecdote, Apple's iOS 6.x-7.0.4 all suffered a similarly embarassing bug - the so called SSL "goto fail" - which was
the result of code accidentally(?) left behind that effectively bypassed SSL certificate validation. Apple was ridiculed by
Andro-philes.. demonstrating that people in glass houses shouldn't throw stones.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Anatomy.html#SignApk
http://www.riskiq.com/company/press-releases/riskiq-reports-malicious-mobile-apps-google-play-have-spiked-nearly-400
https://bluebox.com/technical/uncovering-android-master-key-that-makes-99-of-devices-vulnerable/
http://www.saurik.com/id/17
http://bluebox.com/technical/android-fake-id-vulnerability/


User Level Security

So far, the discussion in this chapter focused on application level security. Android also needs to
offer security at the user-level, allowing only the legitimate device user access to it, and in particular
its sensitive data. Beginning with JellyBean, Android supports multiple users, which complicates
matters a little.

The Lock Screen

The lock screen is a device's first and only real line of defense against theft or physical
interception by malicious entities. It is also the screen most often seen by the user, when the device
awakens from its frequent slumber. As such, it must be made resilient, on the one hand, but also
natural and quick, on the other. As with most Android features, vendors may customize this screen,
though Android provides an implementation which is often used as is.

Passwords, PINs and Patterns

The default Android lock screen allows either passwords, PINs or "patterns". Patterns are, in�
effect, PINs, but instead of remembering actual digits, the user simply has to swipe a grid (usually�
3x3). The user can opt for an actual PIN instead, which is technically stronger than a pattern in that�
its length may be XS�WR����FKDUDFWHUV, and it may repeat digits. A password provides a further 
enhancement�over a PIN in that it allows a mix of different case letters and numbers.

The lock screen is, in effect, just an activity, implemented E\�the 
package. The package contains all the primitives for the system supplied lock screens and methods,�
and includes the following classes:

Table 8-8: The classes in 

Class provides

Interface used for biometric methods, e.g. FaceUnlock

Default views to prompt for PIN or password credentials

Implemented by keyguard views (emulates activity lifecycle)

Keyguard Service implementation

Interface implemented by KeyguardHostView

Mediates events to the Keyguard view

The lock screen invocation begins when the power manager wakes up the display, and notifies
the implementation of the . This calls the 's

, which waits for the keyGuard. From there, it falls on the keyGuard to draw
the lock screen (via some activity), and handle whatever lock credentials mechanism was chosen by
the user. The lock screen can also be invoked from the 's 
method, when the system policy enforces automatic locking.

The actual logic of handling the lock is performed by , which calls on the
, a thread of . The service, in turn, verifies the input

against  (gesture.key) or  (password.key, for PINs and
passwords alike). In both cases, neither pattern nor passwords are actually saved in the file, but
their hashes are. The service additionally uses the locksettings.db file, which is a SQLite database
which holds the various settings for the lock screen. Those are shown in table 8-9:

���

&KDSWHU�9,,,��6HFXULW\



Table 8-9: The locksettings.db database keys

LockPatternUtils constant Key name (lockscreen.*)

lockedoutpermanently

lockedoutattempteddeadline

patterneverchosen

password_type

password_type_alternate

password_salt

disabled

biometric_weak_fallback

biometricweakeverchosen

power_button_instantly_locks

widgets_enabled

passwordhistory

Putting these components together, Figure 8-3 demonstrates a slightly simplified flow through
which the device is unlocked:

Figure 8-3: Unlocking the device

The  is an L addition, which helps unlock the device without a pattern - but by
alternate lock methods, such as a paired BlueTooth dongle or device.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Viewing the locksettings.db

If your device is rooted and you have the SQLite3 binary installed, you can inspect the
locksettings.db file. You can also use adb to pull the locksettings.db to your host.

Output 8-13 Viewing the lock settings Database

The columns in the locksettings table includes "user" (to support Android Multi-User login, as
of JB). The values are usually boolean (0/1), but not always - there are some flag combinations,
and a salt for the .key file. You can use SQL statements to change the lock settings from within
SQLite3. though they will be cached by the lock settings service. You can also just rename the file
- if you do so and restart , it will be recreated with the defaults (and also have
the nice side effect of resetting your password or pattern).

Alternate lock methods

Ice Cream Sandwich introduced face recognition as an alternative to the traditional methods.�
This was touted to much fanfare, as a potential differentiator against iOS. Unfortunately, the�
recognition rates are far from perfect - figures range from as low as 60% to 90%. Face recognition�
can also easily be defeated - by holding up a picture to the phone. IQWHUHVWLQJly, people who have 
tried�this method found it works with greater accuracy than the user's actual face...

The Motorola Atrix 4G was the first Android device to implement fingerprint scanning as an
alternative method. This also suffered poor recognition rates. Apple's acquisition of Authentec in
2012 suggested fingerprint authentication was coming to iOS and, indeed, it made its debut in the
iPhone 5S. Samsung initially slammed this as a poor, uninnovative feature, but nonetheless (and
unsurprisingly) went on to introduce it to their "next big thing", the Galaxy S5. Other Android
vendors are quickly following, and it seems this will become a standard feature, with L offering built-
in support through its  service.

Another important addition in L is the notion of unlocking the device using another device - a
paired BlueTooth device such as Android Wear, which works by proximity alone - leaving the device
unlocked so long as the user is nearby. , , and the internals of

 are discussed in volume II.

���

&KDSWHU�9,,,��6HFXULW\



Multi-User Support

For the majority of its existence, Android has operated under the assumption that the device
only has one user. Unlike desktop systems, which have long allowed user login and switching, this
feature was only introduced into Android with JellyBean (4.2), and has been initially introduced only
into tablets.

Android already uses the user IDs for the individual applications, as explained previously. To
implement multi-user support, it builds on the same concept, by carving up the AID space into non-
overlapping regions, and allocating one of every human user. Application IDs are thus renamed from

### to ## ###, and users are created with separate directories in /data/user. Application
data directories are moved to /data/user/##/, with the primary user being user "0". The legacy
/data/data thus becomes the primary user's directory (symlinked from /data/user/0). The user profiles
themselves are stored in /data/system/users. This is shown in the following experiment:

Experiment: Enabling multi-user support on API 17 and later

On tablets, multi-user support will be enabled by default as of JellyBean (API 17). A little
known feature, however, is that you can enable it on phones as well. All it takes is setting a
system property -  to any value greater than 1. Doing so on the Android emulator
will bring up the "Users" option to settings, as shown in the following screenshot:

Screenshot 8-1: Before and After  property modification

Adding a user is straightforward, though the system will force you to set a lock screen, in
order to differentiate between the two users on login. The process should look something like
Output 8-14 (next page)

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Experiment: Enabling multi-user support on API 17 and later (cont)

Output 8-14: Listing multiple user profiles in /data/system/users

From the command line, the same effect can be achieved by using , which
connects to the user manager
( ) and
invokes its  method. The  likewise removes a user.

Depending on how you create the user (as a separate user or a restricted user, which shares
the original user's apps), the  element may be populated with the following
boolean attributes, all defined in the  class. The actual handling of
the files (above) and the restrictions is performed by

.

Table 8-10: User Restrictions

Restriction

���

&KDSWHU�9,,,��6HFXULW\



Key Management

Android relies extensively on cryptographic keys, for system internal use (validating installed
packages) and for application use. In both cases, the keystore service (discussed in Chapter 4) plays
an integral part in abstracting and hiding the implementation.

Certificate Management

Public Key Infrastructure is the de-facto fulcrum of all Internet security. Encryption rests on�
several key assumptions which relate to the algorithms and methods behind public keys, the most�
important of which is a trust . Simply put, this means that if you know a subject's public key, the key�
can be used not just for encrypting messages to it, but also authenticating messages from it. This,�
in turn, means that if this subject vouches for another public key by authenticating it (which is, in�
effect, what a certificate is)��WKHQ�WKDW�SXEOLF�NH\
V�RZQHUVKLS�FDQ�EH�HVWDEOLVKHG. In this way, a trust 
hierarchy can be formed.

This principle, while powerful, does lead to a chicken and egg problem - you can authenticate a
public key only if some other public key has been a priori used to authenticate it. The way around
this predicament is to hard code the initial public keys in the operating system. These keys are
encoded in the form of root certificates - public keys authenticating themselves. When passed over
the network, they are of no value (as they are trivial to spoof). When hard-coded, however, they
can be trusted and provide the basis for the trust hierarchy.

Android hard-codes root certificates in /system/etc/security/cacerts. The certificates are encoded
in their PEM (Privacy-Enhanced-Mail) form, which is a Base64 encoding of the certificate between
delimiters. Some devices will also have the plain ASCII form of the certificate before or after the
PEM encoding. If not, it's a simple matter to display it using the  command line utility,
which is built-in to Linux or Mac OS, shown in output 8-15:

Output 8-15: Using  to decode a PEM certificate

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services.html#keystore


Of special importance are the Over-The-Air (OTA) update certificates, stored in the
/system/etc/security/otacerts.zip archive. The archive usually contains one (rarely, more) certificates
which are used for validating OTA updates (described in Chapter 3). The  class
parses this file (hardcoded as ), in its  method using a

. Once again, any certificates would be encoded in PEM (usually, without
human readable text), but you can use the method shown in output 8-13 to decode them.
Removing this file is a good method to "combat" auto-updates in some Android distributions (such
as FireOS), which may cause you to lose root access post-update.

Certificate Pinning

JellyBean (API 17) introduces certificate pinning, which has become a common add-on to SSL
certificate validation. Pinning involves hard-coding the expected public key of a host (via its
certificate), so that if the host presents a certificate which does not match the pin (or one of the
pins in a pin set) it is rejected.

Unlike the certificates discussed previously, which are in /system/etc/security (and therefore
cannot be modified), pins are maintained in /data/misc/keychain/pins, which is a file that can be
replaced. The  class registers a broadcast receiver for the

 intent, and - when such an intent is received, its extras are expected to contain the
following:

: The file name containing the new pins.

: Which is expected to be greater than the current version.

: Of the current pins file.

: Signature of the file supplied, its version and hash of current pins file

The 's  (inherited from�
) gets the values from the broadcast intent, ensures the�

version number is indeed greater than the current version of the pins file (in
/data/misc/keychain/metadata/version), and that the current file's hash matches the hash specified in�
the intent. IW then verifies the signature, using the certificate stored in the system settings database
under  (the ). If everything is in
order, the filename from the intent is copied over the existing pins file, and the metadata/version is
updated to reflect the new version number.

Google pins all of its (many) certificates by default, and the vendor may pin additional ones. A
quick way of looking at pins is shown in Output 8-16:

Output 8-16: Displaying the pinned domains

The Android Explorations Blog7 contains a sample application demonstrating the creation of a
pins file and its update operation through the intent.

���

&KDSWHU�9,,,��6HFXULW\

file:///Users/morpheus/Documents/Android/Book/Boot.html#OTA
http://nelenkov.blogspot.com/2012/12/certificate-pinning-in-android-42.html


Certificate Blacklisting

Android provides the  class to handle black listing (effectively, revocation)
of certificates. The class (instantiated as a service of , as discussed in Chapter 5)
registers an observer for two content URIs:

content://settings/secure/pubkey_blacklist: Stores known compromised or revoked public keys
or certificates. Content written here ends up written to
/data/misc/keychain/pubkey_blacklist.txt.

content://settings/secure/serial_blacklist: Stores known compromised or revoked serial
numbers of certificates. Serial numbers written here are saved to
/data/misc/keychain/serial_blacklist.txt.

Both values are also in the system's secure settings, as can be seen in the following output:

Output 8-17: Viewing the serial and pubkey blacklists

Secret and Private Key Management

Storing secrets - symmetric keys or the private part of a public-key pair - poses serious
challenges for any security infrastructure. If one assumes that file permissions are a strong enough
layer of security, the secrets can be placed in a file and appropriately locked down. The underlying
file permissions of Linux, however, are inflexible, and configuration errors could lead to secret
leakage. Likewise, there is the problem of obtaining root access - which effectively voids all
permissions, leaving everything in the clear.

Android provides access to secrets via the  service. This service has already been
discussed in Chapter 4. Keystores for applications are maintained on a per-user basis, in the
/data/misc/keystore/user_## directory, but applications have no direct access to that directory, and
must go through the keystore service, which is the sole owner of the directory (permissions 0700).
The service also provides public key functions - ,  and  - without allowing
applications any access to the underlying private keys. This allows the key storage to be potentially
implemented in hardware.

Indeed, Android offers hardware backed secure storage, on those devices which support it, as
of JellyBean. As discussed in Chapter 11, the  HAL abstraction provides both a uniform
interface for encryption operations, and allows its implementation in both software and hardware.
Thus, supporting devices implement a hardware backed keymaster module, whereas those which do
not use a  instead.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

file:///Users/morpheus/Documents/Android/Book/Services-II.html#CertBlackLister
file:///Users/morpheus/Documents/Android/Book/Services.html#keystore
file:///Users/morpheus/Documents/Android/Book/Devices.html#keymaster


Storage Security

/data Encryption

While most users remain oblivious to the need for encryption on their devices, corporate users� 
certainly fear the compromising of data which would ensue should a device be lost or stolen. iOS� 
provided transparent encryption as of iOS 4, and coincidentally, so has Android as of Honeycomb.�By 
using the very same dm-crypt mechanism utilized by OBBs and ASEC, Honeycomb extends the�notion 
of encryption to the full filesystem layer. The term "full disk encryption" is therefore�somewhat 
inaccurate here, since it is only the /data partition which is normally encrypted. This�actually makes 
more sense, because /system contains no sensitive data (and would be impacted�from the latency 
incurred by crypto-operations. 

Android's documentation provides a detailed explanation of encryption, which has been revised
for Android L8 . As with ASECs and OBBs, the volume manager is responsible for performing both
the filesystem encryption and decryption. The former is performed when selected by the user, and is
a rather lengthy operation. The latter is performed transparently, when the encrypted filesystem is
mounted as a block device using the device mapper.

Note, that unlike obb and asec - the decryption keys for which are stashed somewhere on the
device in plaintext, albeit readable only by root - the key for the /data partition encryption does not
actually reside on the device, but requires the user to interact during boot, and supply it (or, more
accurately, the password from which this key is derived). This requires modifications to the Android
boot process, as well as an interaction between init and vold, which we describe in Chapter 4

Prior to the dm-crypt solution, there were several proposed alternatives for file system� 
encryption (most notably EncFS by Wang et Al.9), but the dm-crypt one is WKH�de�facto standard, 
QRZ�WKDW�/�KDV enabled LW�by default. The architecture is shown in Figure 8-4:

Figure 8-4: The DM-Crypt Architecture

Android M (PR1) further employs dm-crypt with a new feature called "adoptable storage", which 
enables the user to extend Android filesystem encryption to external storage (e.g. USB drivers). As usual, 
this is handled by vold, who maintains the encryption keys in /mnt/vold, and mounts the decrypted 
volumes under /mnt/expand.

���

&KDSWHU�9,,,��6HFXULW\

https://source.android.com/devices/tech/encryption/index.html
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#OBB
file:///Users/morpheus/Documents/Android/Book/FileSystems.html#asec
file:///Users/morpheus/Documents/Android/Book/Services.html#vold
http://cs.gmu.edu/~astavrou/research/Android_Encrypted_File_System_MDM_12.pdf


Access to the storage device is already inherently slow: While not as slow as hard
drives, flash devices run at significantly slower rates than the CPU. Adding the overhead of
an encryption or decryption routine adds several more microseconds per access, but when
viewed percentage-wise, this accounts for a fractional gain, at best.

The Linux kernel optimizes access with caching: As can be seen in figure 8-4, the
Linux kernel helps optimize data access by caching device data. Because dm-crypt appears as
a block device, it exists under the caches, and therefore can benefit from it: Data is
decrypted only once, and read/write operations can occur on the cached (decrypted) copy.
When the data is flushed back to the underlying device, it can be re-encrypted, and then find
its way to the underlying physical device.

To begin with, access to /data isn't as often as to /system: Unlike access to the
/system partition, which stores Android's vast frameworks and static configuration, access to
/data occurs only when an app is loaded, or some runtime configuration change occurs.

Secure Boot

KitKat introduced a new feature for securing the boot process, using the kernel's device
mapper. This feature, known as dm-verity originated in Chromium OS, and has been ported into
Linux (and thus Android), beginning with kernel version 3.4.

Recall from Chapter 3, that a chain of trust (also known as the verified boot path) has been
established from the ROM, via the boot loader, and onto the kernel and the root file system (i.e. the
boot partition). While the bootloader actually does verify /system, it does so only when flashing the
entire partition - which leaves open the avenue for a root owned process (be it "rooting" or
malware) to make persistent changes in /system, by remounting it as read-write, and modifying files
in it. Using dm-verity effectively extends the boot chain of trust one more level, onto /system.

Verifying the integrity of a partition is the simple matter of hashing all of its blocks (DM-Verity
uses SHA-256), and comparing that hash against a stored, digitally signed hash value. To do so
effectively, however, one has to avoid the lengthy process of reading the entire partition, which can
delay boot. To get around this limitation, dm-verity reads the entire partition only once,and records
the hash value of each 4k block in the leaf nodes of the tree. Multiple leaf nodes are rehashed in the
second level of the tree, and then onward to the third, until a single hash value is calculated for the
entire partition - this is known as the root hash. This hash is digitally signed with the vendor's
private key, and can be verified with its public key. Since disk operations are performed in full
blocks, it is a straightforward to add an additional hash verification on the block as it is placed into
the kernel's buffer/page cache, and before it is returned to the requester. If the hash check fails, an
I/O error occurs, and the block is known to be corrupted.

The dm-verity feature is touted for malware prevention, since it effectively prevents any
modification of /system, but does have the side effect of preventing unauthorized persistent rooting,
as well. Malware could definitely attempt to make modifications to /system, but Android would
detect them, potentially refusing to boot - yet the same would apply for any "persistent root" back
door, e.g. dropping a SetUID /system/xbin/su. From the vendor's perspective, this is fine - most
vendors would only provide root via bootloader unlocking, which breaks the chain of trust at its very
first link. Further, dm-verity requires only a subtle modification to the update process (discussed in
Chapter 3) - namely, that the vendor regenerate the signature when /system is modified during an
update. Otherwise, /system remains read only throughout the device's lifetime, and the signature
must therefore remain intact.

The kernel mode implementation of dm-verity is rather small - a 20k file of drivers/dm/dm-
verity.c, which plugs into the Linux Device Mapper (as discussed in Volume III). Google details the
verified boot process in the Android Documentation10. The Android Explorations Blog11 once more
provides further detail, including using the  during the building of the image.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

An oft asked question pertains to the potential performance impact of encryption. Encryption naturally 
requires more processing by the CPU (to decrypt and re-encrypt the data), which can impact performance 
and, to an extent, power consumption. While there have been differing accounts, the overall view is that 
the performance impact ranges from negligible to manageable. This is corroborated by the following:

Performance Impact

file:///Users/morpheus/Documents/Android/Book/Boot.html#locking
file:///Users/morpheus/Documents/Android/Book/Boot.html#OTA
https://source.android.com/devices/tech/security/dm-verity.html
http://nelenkov.blogspot.com/2014/05/using-kitkat-verified-boot.html


Rooting Android

Most vendors provide ADB functionality on their devices and leave the operating system
relatively open for developers, but few (if any) provide root access to the device. There is a strong
rationale not to do so, considering that obtaining root access to a UNIX system brings with it virtual
omnipotence - and Android is no different. Leaving behind open access to root would also potentially
provide an attack vector for malware (which Android knows no shortage of). With root access, any
file on the system could be read, or - worse - overwritten, which would give an attacker both access
to private data, as well as the ability to hijack control of the device.

The same can be said for Apple's iOS (also a UNIX system, based on Darwin), but herein lies
the significant difference between the two. Apple's developers have engineered the system from the
ground up, literally, from the very hardware to the uppermost layers of software, to be rock solid
and not to allow root access (in fact, not to allow any access aside from a sandboxed app model) at
all costs. Android is built on Linux, which itself is a mix of code strains from different contributors,
not all of which adhere to the strictest security standards. Additionally, several vendors leave an
avenue, which can be exploited (by a human user in possession of the device) to gain root access -
redirecting the system to boot an alternate configuration. Another way of looking at it is, Android
considers the application to be the enemy - whereas iOS considers the user itself to be one.

Boot-To-Root

When Android devices boot, they normally do so by the process described in Chapter 3. It is
possible, however, to divert the boot process to an alternate boot, for "safe" boot, system upgrade,
or recovery. This can usually be done by pressing a physical button combination (usually one or
both of the volume buttons, and the home button, if it exists), or by a fastboot command, when the
device is connected over USB. Once the boot flow is diverted, the boot loader can be directed to
load an alternate boot image - either the on-flash recovery image, an update supplied on the SD-
card, or (over USB) an image supplied through fastboot.

If a device's bootloader can be unlocked (as explained in Chapter 3) the device can be rooted.
It's that simple. As previously mentioned, unlocking the boot loader will cause /data to be effaced, in
an effort to prevent the user's sensitive data from falling into the wrong hands. Additionally, some
boot loaders will permanently set a flag indicating that the loader has been tampered with, even if it
is re-locked at some point. This is to note that the boot loader basically shirks all responsibility for
system security, as it will no longer enforce digital signatures on images flashed.

All it takes to "root" the device is really just one part of the device image - the init RAM disk
(initramfs). Because the kernel mounts the initrd as the root filesystem and starts its /init with root
privileges, supplying an alternate /init - or even just a different /init.rc file - suffices to obtain root
access. From that point onwards, it's a simple matter of convenience: It's straightforward to simply

have ADB maintain root privileges (by setting ) or replace adb to a version which�
doesn't drop privileges. Most rooting tools, however, usually drop a su binary into /system/bin or

/system/xbin, and use  to toggle the setuid bit, so when it is invoked from the shell, the
setuid effect will kick in, and automatically bestow root permissions. The code for such a binary (pre
Kit-Kat) is so simple it can be summarized in three functional lines:

Listing 8-5: A simple implementation of su, for non SE-Linux enforced devices

���

&KDSWHU�9,,,��6HFXULW\

* - ,Q�UHFHQW�EXLOGV��DGE�LV�FRQGLWLRQDOO\�FRPSLOHG���LIGHI�$//2:B$'%B5227��VR�DV�WR�LJQRUH�WKLV�SURSHUW\�

file:///Users/morpheus/Documents/Android/Book/Boot.html#b-bp
file:///Users/morpheus/Documents/Android/Book/Boot.html#locking


You can find a similar implementation (with command line options) in the AOSP's
/system/extras/su/su.c. As of KitKat, however, the introduction of SE-Linux in enforcing mode makes 
the binary less trivial, in that its parent (the shell) is already confined to a restricted execution context 
( ), which it cannot break out of. This requires the  binary to make an IPC call to a 
process in the init  (or u:r:kernel:s0) unrestricted context, to then spawn a shell (e.g. 
the WeakSauce exploit (with DaemonSu), as explained on the book's companion website12).

If you've rooted a KitKat (or later) device with SE-Linux in enforcing mode, you can likely see
this for yourself, as shown in the following output:

Output 8-18: viewing an  implementation, accommodating for SELinux

The practice of rooting is so popular that there are quite a few "SuperUser" applications, which
provide a GUI interface to administer root access, once the device is rooted. The applications
actually offer a programmatic API (via permissions and intents) to allow other applications access to
root. One noteable example is chainfire's SuperSU, which defines its own Dalvik level permissions
(  and

) and enables applications to broadcast intents in
order to obtain superuser privileges. This application also cleverly works around SE-Linux, as can be
seen from the output above.

Rooting via Exploiting

Whether or not a vendor has left the boot-root backdoor open, often there exist additional
backdoors. These, unlike the former, are quite unintentional, and all rely on some form of system
vulnerability exploitation. The ways to do so are myriad, and often unpredictable until discovered,
but they all share the same common denominator: Find some insecure configuration setting or
software component, and trigger some code path, by means of which root access can be obtained.
As mentioned in the threat modeling section of this chapter, the security jargon for these attack
types is privilege escalation, as it refers to the process wherein a lower privilege process (that is,
some app), can increase its privileges, usually first to those of the system user, and then root.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

6498

 
 

6503

init
# Use the toolbox specific -Z flag to ps, to show SELinux contexts

s -Z
6498  

, which gets the u:r:init 
# unrestricted SE-Linux context from daemonsu. eu.chainfire.supersu is the GUI app.  

u:r:shell:s0 shell     6498  601   /system/bin/sh
u:r:shell:s0 shell     6503  6498  su
u:r:init:s0 root 6506  5319  daemonsu:0:6503
u:r:init:s0 root 6510  6506  tmp-mksh
u:r:untrusted_app:s0 u0_a140   6528  575   eu.chainfire.supersu
u:r:init:s0 root 6578  6510  ps

http://newandroidbook.com/Articles/HTC.html?b1


There is a strong similarity between exploit-based rooting methods and "jailbreaking" for iOS. In
both cases, it takes the discovery and exploitation of software bugs, and both methods should not
be possible in a perfect world (at least, according to Google and Apple). Once these methods are
discovered, their days are numbered: The operating system is fairly quickly patched, and suggested
to the user for download and updated (or even auto-updated, as for example with the Amazon
Kindle). One prominent example was in Gingerbread, wherein Google itself pushed an update for a
vulnerability in the Linux kernel, known at the time to have been actively exploited by malware.

A thorough discussion of exploitation techniques is thus beyond the scope of this work, and
quite frankly is pointless, since all known exploits at this time have been patched. Exploits generally
obtain root by passing crafted input to a process already running as root (vold has been a perennial
favorite..), corrupting its memory (stack or heap) and usually overwriting a function pointer (or,
commonly, a return address) to subvert its execution, and direct it at the attacker-controlled input.
An additional trick - Return Oriented Programming (ROP) is often used to direct execution to
snippets of code which already exist in the program, but run in an attacker controlled manner. This
method, which is somewhat like biological DNA splicing and recombination, defeats data execution
prevention methods, such as ARM's XN bits. A lengthy discussion of past exploits and ROP methods
can be found in the Android Hacker's Handbook.

It should be noted that not all exploits necessarily involve code injection - some are much more
simple and elegant (for example, the "WeakSauce" exploit for HTC One phones, discssued in the
book's companion website12). Similarly, the latest vulnerability in Android at the time of writing was
not really due to Android - but to the Linux kernel. Geohot's clever "Towelroot" exploit14 used a well
known kernel bug in handling fast mutexes (CVE-2014-3153) to gain root. While TowelRoot itself is
not malware per se but a rooting utility, malware could use the exact same bug to surreptitiously
gain root access, without the user's knowledge or consent.

To paraphrase a quote attributed to Donald Rumsfeld - there are "known unknowns" - those
are essentially the 0-days which were unknown, but have been discovered - and patched - but there
are also "unknown unknowns". The latter are the 0-days which are likely to exist, but have not been
discovered yet, or - worse - have been discovered, but not publicized yet. Any hacker uncovering a
0-day in effect obtains a skeleton key to all Android devices vulnerable to that particular issue. A
malicious hacker can incorporate this into powerful malware, or not even bother, and directly sell it
on the open market. Though not as lucrative as iOS exploits, Android 0-days can fetch anywhere
between $50,000 and $500,000 dollars - depending on vector (local/remote) and impact.

Security Aspects of Rooting

Because a boot-based rooting method requires user intervention, and/or connecting the device
to a host, it is generally not considered to be an insecurity of the Android system. It does, however,
leave a clear attack vector for an adversary who gains possession of the device. This could be an
issue if the device is lost, stolen, or just left outside one's reach for a sufficient amount of time. It
would take a skilled attacker no more than 10-20 minutes to root a device, steal all the personal
data from it, and leave a backdoor or two. This is why most bootloaders are often locked, and while
an unlock of the bootloader is possible, it will force a factory reset and erasure of all personal data -
Once the bootloader is unlocked, however, the device is vulnerable (unless the bootloader is locked
again).

Exploitation attacks are even simpler in the sense that they do not require the user to manually
divert the system boot process. In fact, these attacks require no user intervention at all. Therein lies
their advantage (for those looking for a simple "1-click" root method), but also their great risk, as
they can be carried out without the user's knowledge, often when installing a seemingly innocuous
app, which like the proverbial Trojan horse compromises the entire system.

���

&KDSWHU�9,,,��6HFXULW\

http://www.amazon.com/gp/product/111860864X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111860864X&linkCode=as2&tag=newosxbookcom-20
http://newandroidbook.com/Articles/HTC.html?b
http://www.towelroot.com/


Explotation attacks are even more dangerous when they are HTTP-borne. When the
vulnerability exploited, or part thereof, involves the browser, it suffices to visit a malicious website -
or inadvertently access some content from it (for example, through an ad network), for malicious
payload to target the browser, and gain the initial foothold on the device. Indeed, sophisticated
malware consists of multiple payloads injected over several stages, initially obtaining remote
execution, then followed by obtaining remote root.

What follows is that rooting the device can, in fact, be dangerous, if not carried out through
trusted sources: When an eager user downloads a rooting utility, whether one-click or tethered, if
the download source is not a trusted one, it could be hard - virtually impossible - to detect additional
payloads or backdoors which may be injected by such utilities. Less than proper tools may jump on
the chance to also change system binaries or frameworks, for example disabling the Dalvik
permission mechanism for malware purposes. Malware could possibly inject a rootkit all the way
down to the Linux kernel, though most would probably not put that much effort when it's fairly
trivial to hack the higher layers. Somewhat ironically, some of the SuperUser applications themselves
had vulnerabilities in the past, which enabled rogue applications to detect a rooted device, and
escalate their own privileges through the applications (q.v. CVE-2013-6774).

The last, but hardly least impact of rooting a device one has to consider is that on applications -
Android's Application content protections disintegrate on a rooted device: OBBs can be read by root,
as can the keys to ASEC storage. Application encryption likewise fails, and though hardware backed
credential storage offers some resistance, its client processes' memory can easily be read (via

 methods and the like). DRM solutions also fail miserably. Unfortunately, there's no
foolproof way of detecting a rooted device from a running application, and refusing to execute on
one.

Arguably, the same can be said for Jailbroken iOS - after all, Apple's fairplay protections and
application encryptions, though stronger than Android's, are equally frangible. Yet one has to keep
in mind that iOS only has an exploitation vector (with an ever increasing level of difficulty in
between releases), whereas most Android devices do allow Boot-to-Root. Coupled with the ease of
Dalvik bytecode decompilation, this poses a serious concern for application developers.

Summary

This chapter attempted to provides an overview of Android's myriad security features, both
those inherited from Linux, and those which are specific to Android and mostly implemented in the
Dalvik level. Special attention has been given to the Android port of SELinux - which, though
currently not in full effect, is already adopted by Samsung in KNOX, and is likely to play a larger part
in upcoming releases of Android.

While trying to be as detailed as possible, this review is by no means comprehensive. The
interested reader is referred to Android Security specific books, such as Nikolay Elenkov's Android
Security Internals15, which devotes full chapters to what was covered here in sections.

���

$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�

http://www.amazon.com/gp/product/1593275811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275811&linkCode=as2&tag=newosxbookcom-20&linkId=LBF642ZJNLGA3FN2


References

1. a. SEAndroid - A Paper, Smalley/Craig:
http://www.internetsociety.org/sites/default/files/02_4.pdf
b. SEAndroid - A Presentation, Smalley/Craig:
http://www.internetsociety.org/sites/default/files/Presentation02_4.pdf
c. SEAndroid at ABS - Smalley/Craig:
http://events.linuxfoundation.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf

2. Android Developer, SELinux: http://source.android.com/devices/tech/security/se-linux.html

3. RedHat, RHEL6 and SELinux: https://access.redhat.com/site/documentation/en-
US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/

4. RiskIQ, Mobile Apps on Google Play: http://www.riskiq.com/company/press-releases/riskiq-
reports-malicious-mobile-apps-google-play-have-spiked-nearly-400

5. a. BlueBox, Android "Master Key Vulnerability": https://bluebox.com/technical/uncovering-
android-master-key-that-makes-99-of-devices-vulnerable/
b. Saurik, Android "Master Key Vulnerability": www.saurik.com/id/17

6. BlueBox, Android "Fake ID Vulnerability": http://bluebox.com/technical/android-fake-id-
vulnerability

7. Android Explorations, Certificate Pinning in 4.2:
http://nelenkov.blogspot.com/2012/12/certificate-pinning-in-android-42.html

8. Android Documentation, Device Encryption:
https://source.android.com/devices/tech/encryption/index.html

9. EncFS, by Wang et Al:
http://cs.gmu.edu/~astavrou/research/Android_Encrypted_File_System_MDM_12.pdf

10. Android Documentation, DM-Verity: https://source.android.com/devices/tech/security/dm-
verity.html

11. Android Explorations, KitKat Verified Boot: http://nelenkov.blogspot.com/2014/05/using-
kitkat-verified-boot.html

12. NewAndroidBook.com, Analyzing the WeakSauce Exploit:
http://newandroidbook.com/Articles/HTC.html">

13. Android Hacker's Handbook, Wiley 2014, by Joshua Drake and others

14. Towelroot.com, http://www.towelroot.com

15. Android Security Internals, No Starch 2014, by Nikolay Elenkov

���

&KDSWHU�9,,,��6HFXULW\

http://www.internetsociety.org/sites/default/files/02_4.pdf
http://www.internetsociety.org/sites/default/files/Presentation02_4.pdf
http://events.linuxfoundation.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf
http://source.android.com/devices/tech/security/se-linux.html
https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/
http://www.riskiq.com/company/press-releases/riskiq-reports-malicious-mobile-apps-google-play-have-spiked-nearly-400
https://bluebox.com/technical/uncovering-android-master-key-that-makes-99-of-devices-vulnerable/
http://www.saurik.com/id/17
http://bluebox.com/technical/android-fake-id-vulnerability
http://nelenkov.blogspot.com/2012/12/certificate-pinning-in-android-42.html
https://source.android.com/devices/tech/encryption/index.html
http://cs.gmu.edu/~astavrou/research/Android_Encrypted_File_System_MDM_12.pdf
https://source.android.com/devices/tech/security/dm-verity.html
http://nelenkov.blogspot.com/2014/05/using-kitkat-verified-boot.html
http://newandroidbook.com/Articles/HTC.html?b1
http://www.towelroot.com/


$QGURLG�,QWHUQDOV��$�&RQIHFWLRQHU
V�&RRNERRN��9ROXPH�,�



Had enough? If this has only begun to whet your appetite for more on Android - stay tuned for
Volume II - coming soon, which picks up where this leaves off, and discusses the true internals of
the system: The framework services, graphics, audio, and multimedia, and much more - from the
programmer's view!

Feel free to drop me a line and let me know what you liked, and what you hated! Also
remember to check out NewAndroidBook.com for more updates, and tons of bonus material! Hope
to see you next volume!

3RVW�6FULSWXP

http://www.newandroidbook.com/




Android may be an open source system, but how many people can actually sit down
and sift through millions lines of Java, C, C++ and XML, just to figure out how it works?

Android Internals::A Confectioner's Cookbook is the first time the inner workings of the 
world's most popular operating system have been documented! Without going into the lengthy code, it
presents the logic and flow of Android's various components using detailed illustrations, verbose
annotations and hands-on experiments!        

                

Volume I takes the power user's point of view - the utilities and functionality accessible through
. In particular, we explore:

Partitions and Filesystems
The Boot Process
Init and its configuration files
The native daemons in /system/bin
The framework service architecture and 
Monitoring through Linux interfaces
Security

All versions of Android - up to and including Lollipop - are covered, with examples taken from the
wide gamut of Android Devices - Nexi, Samsung Galaxy S series, NVidia Shield, Amazon Kindle, HTC
One M8, and the Android Emulator.

This is the first in a multi-volume series, aiming to explore Android down to its last class. Stay tuned
for Volume II - The Programmer's View - which picks up where the Power User's View ends, and dives
deeper still into the frameworks, input, audio, video and network architecture... wading through the
inevitable quagmire of code.

Jonathan Levin is a longtime trainer and consultant specializing in the system and kernel levels of the "Big
Three" - Windows, Linux and Mac OS X, as well as their mobile derivatives. He is the founder and CTO of
Technologeeks.com, a partnership of experts offering training and consulting on system/kernel programming,
debugging and more.

Fresh after his take on iOS in "Mac OS X and iOS Internals" (Wiley, 2012, with a 2nd edition coming in 2015),
Jonathan turns his attention to the "Other Operating System" - and brings an even greater level of detail to the
operating system that is to Mobile what Windows was to the Desktop. And this time, it's personal - this entire
work is self-published.

 


	Cover Material
	Table of Contents
	About ...
	About this Book

	I: Introduction
	Android Version History
	Android vs. Linux
	Android Derivatives
	Pondering the Way Ahead

	II: Partitions & FileSystems
	Partitioning Scheme
	Android Filesystem Contents
	Protected Filesystems
	The Linux Pseudo-Filesystems

	III: Boot, Backup & Recovery
	Android Images
	The Boot Process
	Shutdown & Reboot
	Application Backup & Restore
	System Recovery & Updates

	IV: Init
	Roles and Responsibilities
	Init and USB
	Other Roles of Init

	V: Daemons
	Core Services
	Network Services
	Graphics and Media Services
	Other Services

	VI: The Framework Service Architecture
	Revisiting servicemanager
	The Service Calling Pattern
	The Binder
	system_server

	VII: Through a Linux Lens
	
	User-mode Memory Management
	Tracing System Calls

	VIII: Security
	Threat Modeling Mobile Security
	Security at the Linux Level
	Security at the Dalvik Level
	User Level Security
	Key Management
	Storage Security
	Rooting Android






Extracted Metadata:
pdf:unmappedUnicodeCharsPerPage: 0
pdf:PDFVersion: 1.3
X-Parsed-By: org.apache.tika.parser.DefaultParser
pdf:hasXFA: false
access_permission:modify_annotations: true
access_permission:can_print_degraded: true
access_permission:extract_for_accessibility: true
access_permission:assemble_document: true
xmpTPg:NPages: 267
pdf:hasXMP: false
dc:format: application/pdf; version=1.3
pdf:charsPerPage: 2
access_permission:extract_content: true
access_permission:can_print: true
access_permission:fill_in_form: true
pdf:encrypted: false
access_permission:can_modify: true
pdf:hasMarkedContent: false
Content-Type: application/pdf

Starting analysis of parsed content:
Analyzed tokens:
rl
android
internals
a
confectioner's
cookbook
volume
i
the
power
user's
view
by
jonathan
levin
cambridge
ma
in
memoriam
frank
r
dye
i
missed
you
by
a
day
and
will
miss
you
for
a
lifetime
with
updates
for
android
m
preview
release
1
6
2015
android
internals
a
confectioner's
cookbook
volume
i
the
power
user's
view
©
2015
by
jonathan
levin
all
rights
reserved
no
part
of
this
work
may
be
reproduced
transmitted
in
any
form
or
any
means
electronic
or
mechanical
including
photocopying
recording
or
by
any
information
storage
or
retrieval
system
without
the
prior
written
permission
of
the
author
printed
in
cambridge
ma
usa
first
printing
y
5
mp1
as
isbn
10
9910555
2
4
isbn
13
978
0
9910555
2
4
publisher
technologeeks.com
production
editor
jonathan
levin
interior
design
jonathan
levin
technical
reviewers
moshe
kravchik
arie
haenel
cover
illustration
dino
tsiopanos
for
information
on
distribution
translations
or
bulk
sales
please
contact
jonathan
levin
at
jonathan
levin
phone
617
3000
667
email
j
newandroidbook.com
web
www.newandroidbook.com
company
and
product
names
mentioned
in
this
work
may
be
trademarked
by
their
respective
owners
any
and
every
such
name
is
used
solely
in
an
editorial
fashion
to
the
benefit
of
the
trademark
owner
with
no
intention
whatsoever
of
infringement
the
android
robot
is
reproduced
and
or
modified
from
work
created
and
shared
by
google
according
to
the
terms
of
the
creative
commons
3.0
attribution
license
limit
of
liability
disclaimer
of
warranty
the
author
neither
makes
or
implies
any
representations
or
warranties
with
respect
to
the
accuracy
or
completeness
of
the
contents
of
this
work
further
this
paragraph
explictly
and
specifically
serves
to
disclaim
all
warranties
including
without
limitation
warranties
of
fitness
for
a
particular
purpose
no
warranty
may
be
created
or
extended
by
sales
or
promotional
materials
the
advice
and
strategies
contained
herein
may
not
be
suitable
for
every
situation
this
work
is
sold
with
the
understanding
that
the
author
is
not
engaged
in
rendering
legal
accounting
or
other
professional
services
if
professional
assistance
is
required
the
services
of
a
competent
professional
person
should
be
sought
the
author
shall
not
be
liable
for
damages
arising
herefrom
the
fact
that
an
organization
or
web
site
is
referred
to
in
this
work
as
a
citation
and
or
a
potential
source
of
further
information
does
not
mean
that
the
author
endorses
the
information
the
organization
or
web
site
may
provide
or
recommendations
it
may
make
further
readers
should
be
aware
that
internet
web
sites
listed
in
this
work
may
have
changed
or
disappeared
between
when
this
work
was
written
and
when
it
is
read
information
in
this
book
is
distributed
on
an
as
is
basis
with
no
warranty
android
is
a
shifting
landscape
with
versions
being
released
faster
than
any
work
can
keep
up
with
every
effort
and
precaution
has
been
taken
to
update
this
work
to
reflect
up
to
and
including
android
lollipop
5.0.2
bear
in
mind
however
that
different
versions
of
android
may
add
modify
or
remove
apis
and
features
with
no
notice
the
author
hereby
disclaims
any
liability
to
any
and
every
person
or
entity
with
respect
to
any
loss
or
damage
whether
caused
or
alleged
to
be
caused
directly
or
indirectly
by
this
work
to
report
errors
or
omissions
please
contact
the
author
this
copy
is
specifically
licensed
for
redlattice
inc
ashburn
va
for
training
conducted
6
2015
and
not
meant
to
be
used
outside
the
purposes
of
said
specific
training
about
the
author
editor
formatter
publisher
i
started
in
my
teens
by
hacking
mostly
in
the
good
sense
of
the
word
and
trying
to
figure
out
how
things
worked
back
in
1993
from
an
xt
with
a
2400
baud
modem
onto
a
shell
i'm
not
even
sure
was
mine
with
no
help
per
se
i
had
to
and
then
a
lot
has
happened
in
the
two
decades
since
and
from
unix
to
linux
i
got
to
windows
and
os
x
over
the
years
i
took
up
consulting
and
training
initially
in
security
i
then
realized
security
is
largely
a
projection
of
internals
finally
i
gathered
a
few
good
men
and
started
technologeeks.com
which
is
where
i
presently
pass
my
time
and
function
as
cto
authoring
is
somewhat
new
i
first
took
on
apple's
oses
with
mac
os
x
and
ios
internals
wiley
2012
which
was
well
received
it
was
a
painful
process
but
the
dopamine
rush
was
awesome
now
an
addict
i
took
on
android
and
the
first
part
of
the
result
is
what
you
see
before
you
this
was
also
my
first
foray
into
the
world
of
self
publishing
with
this
done
i'm
turning
to
the
2nd
edition
of
moxii
exw
rx
fdq
h
shfw
9roxph
ri
wklv
vhulhv
7kh
hyhorshu
v
9lhz
vrrq
about
the
technical
reviewers
moshe
kravchik
of
cisco
helped
review
my
previous
book
and
immediately
volunteered
to
help
with
this
one
with
his
eye
for
detail
and
accuracy
he
helped
me
lay
out
the
contents
of
this
book
expanded
them
with
many
a
question
a
reader
would
pose
and
caught
my
oh
so
many
typos
or
areas
wherein
i
wasn't
clear
enough
for
that
my
thanks
arie
haenel
also
of
cisco
is
hands
down
the
most
gifted
reverse
engineer
i've
ever
known
and
certainly
one
of
the
outright
smartest
people
period
a
reviewer
of
my
previous
book
it
was
only
natural
i
would
seek
his
help
for
this
one
he's
already
got
the
dubious
pleasure
of
reviewing
the
2nd
edition
of
moxii
as
well
viii
1
table
of
contents
0
about
this
book
1
introduction
android
version
history
cupcake
donut
éclair
froyo
gingerbread
honeycomb
ice
cream
sandwich
jellybean
kitkat
lollipop
m
preview
android
vs
linux
not
just
another
linux
distribution
and
then
came
android
commonalities
and
divergences
from
linux
the
android
frameworks
the
dalvik
virtual
machine
jni
native
binaries
bionic
android
native
libraries
external
native
libraries
hardware
abstraction
layer
the
linux
kernel
2
android
derivatives
google
offshoots
non
google
ports
pondering
the
way
ahead
64
bit
compatibility
android
runtime
art
split
screen
android
as
a
desktop
os
android
and
project
ara
2
partitions
filesystems
partitions
the
need
for
separate
partitions
the
guid
partition
table
flash
storage
systems
file
systems
android
device
partitions
android
filesystem
contents
the
root
file
system
system
data
cache
vendor
the
sd
card
protected
filesystems
obb
opaque
binary
blobs
asec
android
secure
storage
the
linux
pseudo
filesystems
cgroupfs
debugfs
functionfs
dev
usb
ffs
adb
procfs
proc
pstore
sys
fs
pstore
selinuxfs
sys
fs
selinux
sysfs
sys
9
3
boot
backup
recovery
android
images
the
boot
loader
boot
images
the
kernel
the
ram
disk
system
and
data
partitions
the
boot
process
firmware
boot
kernel
boot
shutdown
reboot
application
backup
restore
command
line
tools
local
backups
monitoring
backup
operations
system
recovery
updates
over
the
air
ota
updates
customizing
images
resources
for
image
modding
4
init
the
roles
and
responsbilities
of
init
system
properties
the
rc
files
putting
it
all
together
the
flow
of
init
and
usb
the
other
roles
of
init
ueventd
watchdogd
11
1
5
daemons
core
services
adbd
servicemanager
healthd
lmkd
l
logd
l
vold
network
services
netd
mdnsd
mtpd
racooon
rild
graphics
and
media
services
surfaceflinger
bootanimation
mediaserver
drmserver
other
services
installd
keystore
debuggerd
sdcard
zygote
64
6
the
framework
service
architecture
revisiting
servicemanager
the
service
calling
pattern
advantages
and
disadvantages
serialization
and
aidl
the
binder
a
little
history
so
what
exactly
is
binder
using
binder
tracing
binder
17
system_server
startup
and
flow
modifying
startup
behavior
7
android
through
a
linux
lens
proc
revisited
the
symlinks
cwd
exe
root
fd
fdinfo
status
user
mode
memory
management
virtual
memory
classification
and
lifecycle
memory
statistics
out
of
memory
conditions
tracing
system
calls
the
tool
wchan
and
syscall
the
utility
8
security
threat
modeling
mobile
security
security
at
the
linux
level
linux
permissions
linux
capabilities
selinux
other
noteworthy
features
security
at
the
dalvik
level
dalvik
level
permissions
dalvik
code
signing
user
level
security
the
lock
screen
multi
user
support
key
management
certificate
management
secret
and
private
key
management
storage
security
data
encryption
secure
boot
rooting
android
boot
to
root
rooting
via
exploiting
security
aspects
of
rooting
about
this
book
overview
if
you
got
this
book
no
doubt
you
recognize
the
importance
of
android
from
a
start
up
started
back
in
2003
it
has
been
assimilated
by
google
and
morphed
into
one
of
its
largest
arms
taking
rq
apple's
ios
head
on
some
would
say
too
closely
it
has
not
only
achieved
hegemony
over
mobile
operating
systems
worldwide
with
a
staggering
82
of
the
market
as
this
book
goes
to
print
but
has
also
permeated
other
platforms
becoming
an
operating
system
for
wearable
devices
tvs
and
embedded
devices
android
is
open
source
and
freely
available
meaning
anyone
can
get
it
and
adopt
it
to
any
platform
indeed
it
owes
its
overwhelming
popularity
to
this
it's
surprising
however
that
some
seven
years
since
its
public
inception
no
book
to
date
has
taken
on
the
task
of
documenting
and
explicating
its
internals
a
previous
work
on
the
subject
embedded
android
porting
extending
and
customizing
by
karim
yaghmour
provides
a
good
deal
of
detail
about
the
general
structure
of
the
os
but
focuses
on
building
and
adapting
the
sources
to
new
platforms
and
stops
shy
of
describing
the
structure
of
the
operating
system
itself
in
fact
in
his
internals
primer
yaghmour
states
that
fully
understanding
the
internals
of
android's
system
services
is
like
trying
to
swallow
a
whale
the
analogy
is
very
much
an
understatement
which
is
why
this
work
requires
not
one
but
multiple
volumes
the
first
the
one
you
are
reading
focuses
on
android
from
the
perspective
of
the
power
user
or
administrator
in
it
i
try
to
tackle
various
aspects
of
the
operating
system
its
design
filesystem
structure
boot
sequence
and
native
services
along
with
the
linux
foundations
and
legacies
which
affect
the
operation
all
this
without
going
into
code
and
trying
to
provide
an
illustrated
conceptual
view
as
possible
this
book
can
be
considered
in
a
sense
a
successor
to
yaghmour's
work
which
remains
a
great
resource
and
a
recommended
read
the
second
volume
of
this
work
to
be
published
soon
dives
far
deeper
and
looks
at
the
structure
of
android's
frameworks
which
is
where
its
appeal
to
developers
lies
through
a
rich
set
of
java
level
frameworks
developers
obtain
powerful
abstractions
of
input
devices
sensors
graphics
and
what
not
all
these
abstractions
come
at
the
price
the
complexity
that
lies
under
the
hood
which
most
developers
are
quite
blissfully
ignorant
of
and
would
likely
prefer
to
stay
this
way
there
is
no
knowledge
that
is
not
power
however
and
so
deep
familiarity
with
the
frameworks
is
instrumental
for
anyone
dealing
with
the
low
level
implementations
and
customizations
for
performance
hardware
or
security
android
is
a
constantly
shifting
landscape
this
work
was
started
halfway
through
kitkat
and
was
postponed
several
times
as
android
mutated
further
to
become
lollipop
l
this
constant
evolution
is
still
ongoing
with
qgurlg
0
dqqrxqfhg
hyhq
dv
lv
battling
quite
a
few
bugs
nonetheless
it
was
about
time
to
publish
the
book
once
l
showed
signs
of
stabilization
and
so
i
can
proudly
say
this
book
is
updated
till
the
latest
and
greatest
at
least
at
the
time
of
publication
ruwxqdwho
wkdqnv
wr
wkh
zrqghuv
ri
vhoi
sxeolvklqj
fdq
nhhs
wkh
errn
dorqj
zlwk
wkh
zlqglqj
fxuyh
dqg
wkh
yhuvlrq
rx
uh
uhdglqj
kdv
ehhq
xsgdwhg
iru
0
3uhylhz
5hohdvh
xqh
http
www.amazon.com
gp
product
1449308295
ref
as_li_tl
ie
utf8
camp
1789
creative
9325
creativeasin
1449308295
linkcode
as2
tag
newosxbookcom
20
linkid
3j6jwrlxmyzuaweg
i
tried
to
learn
from
mistakes
of
my
previous
book
mac
os
x
and
ios
internals
moxii
one
of
the
main
criticisms
i
had
was
that
said
work
was
far
too
technical
and
riddled
with
source
code
which
made
it
hard
for
the
non
developer
type
to
get
by
my
own
personal
belief
is
of
read
the
source
luke
in
that
source
code
unlike
natural
language
contains
almost
no
ambiguities
and
is
thus
the
right
way
of
depicting
facts
nonetheless
in
this
book
i've
tried
to
provide
as
many
illustrations
as
possible
all
without
sacrificing
detail
i'm
also
adopting
this
book
to
the
2nd
edition
of
moxii
out
later
this
year
not
so
much
out
of
choice
but
because
the
book
dives
into
far
deeper
and
shadier
aspects
of
both
systems
for
which
there
is
no
open
source
the
book
is
also
a
lot
more
hands
on
taking
some
of
the
hands
on
exercises
from
our
android
training
and
recasting
them
in
the
form
of
experiments
these
are
invaluable
if
you
want
to
get
a
good
sense
of
the
topics
in
the
relevant
section
android
is
a
un
x
derivative
by
virtue
of
linux
and
the
only
way
one
learns
un
x
is
through
the
fingers
and
neither
eyes
nor
ears
the
experiments
demonstrate
many
useful
commands
from
the
android
command
line
interface
cli
and
also
techniques
for
looking
deeper
into
the
operating
system
furthermore
the
experiments
will
likely
produce
different
outputs
on
different
strains
of
android
which
makes
them
worthwhile
to
try
on
your
own
device
s
so
as
to
get
different
perspectives
or
implementations
which
may
vary
by
vendor
or
os
version
contents
at
a
glance
the
book
is
designed
to
be
read
either
cover
to
cover
or
as
random
quick
access
each
chapter
is
largely
self
contained
and
hyperlinks
on
topics
allow
quick
associative
navigation
when
reading
the
book
in
e
form
for
print
edition
relevant
chapter
numbers
for
internal
links
or
urls
for
external
links
are
provided
i
have
also
added
the
paths
to
the
aosp
files
referenced
where
relevant
albeit
in
abbreviated
form
so
as
to
conserve
space
in
the
tables
as
the
paths
can
be
a
mile
long
chapter
one
provides
an
introduction
to
the
operating
system
examining
the
evolution
of
the
os
over
its
versions
since
froyo
which
is
the
only
obsolete
version
which
you
might
still
encounter
in
the
wild
and
up
to
l
it
also
explains
the
architecture
at
a
high
level
view
and
the
linux
underpinnings
by
traversing
each
layer
of
the
android
stack
it
then
looks
at
android
derivatives
both
google's
and
other
vendors
e.g
amazon's
fireos
before
concluding
with
some
thoughts
and
ideas
for
future
directions
chapter
two
dives
right
into
the
technical
bits
specifically
android
partitions
and
filesystems
starting
with
an
examination
of
the
partitioning
scheme
used
by
android
which
unfortunately
is
far
from
standardized
across
vendors
and
filesystems
ext4
and
f2fs
what
follows
is
a
tour
of
filesystem
contents
which
should
prove
useful
if
you
ever
need
to
figure
out
what
a
specific
system
directory
or
file
contains
a
few
of
the
built
in
apps
data
directories
are
also
covered
which
is
handy
if
you're
doing
forensics
the
chapter
also
discusses
the
android
protected
filesystems
obb
and
asec
though
those
fail
miserably
on
rooted
devices
finally
the
role
of
the
linux
pseudo
filesystems
cgroupfs
debugfs
procfs
sysfs
and
others
is
described
chapter
three
builds
on
its
predecessor
which
covered
partitions
to
explain
the
role
of
partitions
in
the
android
boot
process
starting
with
a
discussion
of
the
android
boot
images
what
some
refer
to
albeit
incorrectly
as
roms
and
how
to
flash
them
onto
the
device's
boot
partitions
the
default
android
boot
loader
is
explained
with
the
more
heavily
technical
aspects
left
as
a
bonus
article
on
the
book's
companion
website
and
the
other
components
of
the
boot
image
the
kernel
device
tree
and
initramfs
are
described
in
detail
experiments
demonstrate
how
to
unpack
customize
and
repack
these
components
assuming
an
unlocked
bootloader
the
chapter
also
discusses
the
images
sent
as
over
the
air
ota
updates
as
well
as
the
processes
of
backup
restore
and
shutdown
chapter
four
is
dedicated
in
its
entirety
to
one
process
init
this
like
its
un
x
namesake
is
responsible
for
starting
up
the
system
in
user
mode
the
process
of
startup
is
explained
in
detail
through
examination
of
the
init.rc
file
syntax
other
roles
of
init
such
as
maintaining
system
properties
and
watching
for
hardware
changes
as
ueventd
are
detailed
as
well
http
newandroidbook.com
articles
aboot.html
book
chapter
five
discusses
the
native
services
i.e
those
listed
in
the
init.rc
and
loaded
as
linux
binaries
in
contrast
to
the
dalvik
level
framework
services
which
are
loaded
as
threads
in
system_server
and
covered
in
volume
ii
this
chapter
provides
a
detailed
reference
of
each
and
every
daemon
you're
likely
to
find
on
your
device
and
there
are
quite
a
few
of
them
chapter
six
provides
a
gentle
introduction
to
android's
framework
service
architecture
by
explaining
the
roles
of
the
and
processes
which
together
form
the
fulcrum
on
top
of
which
all
of
android's
frameworks
rest
binder
the
elephant
in
the
chapter
is
described
but
briefly
leaving
most
of
the
meticulous
detail
for
volume
ii
but
hopefully
explaining
just
enough
to
provide
more
insight
as
to
how
android
inter
process
communication
and
remote
procedure
calls
work
chapter
seven
is
a
view
of
android
through
a
linux
lens
that
is
looking
at
android
system
processes
and
apps
through
the
proc
filesystem
and
linux
level
tools
this
chapter
is
a
two
fer
in
the
sense
that
you
can
apply
most
if
not
all
of
the
techniques
shown
there
on
your
linux
system
for
native
level
debugging
chapter
eight
the
last
chapter
of
this
volume
concerns
itself
with
security
this
chapter
was
made
available
as
a
preview
originally
as
chapter
21
back
when
i
naively
thought
i
could
fit
everything
into
one
book
it
provides
a
detailed
walk
through
of
security
features
both
at
the
linux
level
and
that
of
the
frameworks
as
well
as
a
special
section
on
rooting
android
devices
both
in
the
approved
ways
as
well
as
some
unexpected
ones
conventions
used
in
this
book
keeping
this
simple
filenames
are
specified
like
this
or
framework
are
specified
thus
the
numbers
in
parentheses
refer
to
the
manual
section
describing
them
using
the
linux
man
additionally
this
book
is
full
of
figures
listings
and
outputs
figures
are
illustrations
of
components
or
message
flows
listings
are
generally
static
files
as
opposed
to
outputs
which
are
sequences
of
commands
often
included
as
part
of
an
experiment
in
outputs
the
idea
was
to
show
the
flow
as
well
as
usage
of
the
commands
so
the
outputs
are
fully
annotated
e.g
output
0
1
a
sample
output
attention
has
been
paid
to
detail
the
username
as
well
as
the
prompt
sign
or
will
tell
you
if
the
command
requires
shell
or
root
privileges
7he
hostname
shows
you
the
device
the
command
was
tried
on
with
generic
being
the
emulator
flounder
being
the
nexus
9
l
and
otherwise
the
device
name
s3
s4
kindle
nexus5
etc
dqg
rujh
ehlqj
wkh
lqx
krvw
wulhg
wr
dyrlg
vqlsshwv
ri
frgh
dw
ohdvw
lq
9roxph
dqg
lq
wkrvh
sodfhv
zkhuh
lw
suryhg
ylwdo
kdyh
dovr
surylghg
dqqrwdwlrqv
the
color
scheme
was
finally
adjusted
to
be
easy
on
the
eyes
in
both
color
if
you're
reading
the
pdf
or
black
white
for
the
print
edition
now
let's
get
to
it
finally
the
book
proved
to
be
a
massive
undertaking
sifting
through
android's
sources
is
akin
to
inspecting
an
organism
down
to
the
cellular
level
for
those
who
still
wish
to
examine
the
sources
themselves
i
have
pinpointed
the
relevant
files
pertaining
to
each
discussion
and
hyperlinked
them
or
put
them
as
a
table
for
the
print
edition
of
the
book
the
interested
reader
should
most
definitely
obtain
the
sources
of
the
latest
version
either
by
using
and
as
explained
in
http
source.android.com
or
by
looking
through
google's
android
source
website
the
book
has
also
been
a
one
man
project
with
the
exception
of
the
cover
art
provided
for
me
by
the
gifted
dino
tsiopanos
a
great
engineer
who's
an
even
greater
illustrator
everything
in
this
work
text
images
formatting
editing
has
been
done
by
myself
thankfully
i
enlisted
the
help
of
my
regular
reviewers
moshe
kravchik
and
arie
haenel
to
whom
i
am
both
indebted
nikolay
elenkov
who
wrote
the
excellent
android
security
internals
an
in
depth
guide
to
android's
security
architecture
contributed
very
helpful
insights
and
feedback
as
well
aviv
greenberg
who
at
the
last
moment
performed
a
binge
reading
and
review
helped
me
with
critical
comments
oprvw
oast
but
hardly
least
eddie
cornejo
who
not
only
caught
even
more
typos
which
somehow
eluded
other
eyes
but
also
made
sure
i
was
as
unbiased
as
i
should
given
the
other
os
qg
ilqdoo
wkdqn
1lnrod
9homnrylf
zkr
phwlfxorxvo
fdxjkw
ixuwkhu
w
srv
hyhu
rqh
hovh
plvvhg
a
special
personal
and
most
intimate
thanks
and
gratitude
goes
to
amy
the
yin
to
my
yang
who
provided
infinite
support
and
encouragement
as
with
my
previous
book
and
with
everything
else
this
is
one
thanks
i
will
forever
reiterate
and
never
forget
the
book
was
painstakingly
authored
with
hand
typing
standards
compliant
html5
yes
i'm
serious
and
no
i
probably
wouldn't
try
this
again
illustrations
are
either
svg
another
traumatic
ordeal
or
drawn
with
powerpoint
this
should
hopefully
help
explain
why
this
book
so
long
to
take
out
though
the
good
news
is
that
volume
ii
which
is
double
the
size
of
this
work
should
be
available
very
soon
pagination
is
a
non
standard
a4
meaning
less
pages
than
the
usual
tech
book
but
far
more
detail
per
page
crafting
an
index
for
the
book
would
have
proved
so
sisyphean
a
task
i
decided
to
not
even
go
there
you
can
just
search
the
pdf
please
keep
all
this
in
mind
if
you
spot
any
styling
errors
or
gasp
technical
ones
errare
est
humanum
for
technical
errors
only
i
offer
rewards
a
la
knuth
0x100
cents
will
come
your
way
if
you
report
any
i'm
hoping
for
rampant
inflation
when
qe
subsides
i
maintain
a
companion
web
site
with
bonus
material
and
quite
a
few
custom
tools
at
http
newandroidbook.com
updates
to
this
book
as
well
as
typos
and
or
errata
which
i
probably
have
will
be
published
through
that
site
for
those
of
you
more
into
tweeting
my
company
technologeeks
often
tweets
about
updates
and
bonus
material
to
both
my
works
technologeeks
also
provides
expert
consulting
and
training
services
on
android
os
x
ios
linux
and
more
so
i
encourage
you
to
check
out
http
technologeeks.com
the
training
on
both
android
and
osx
ios
specifically
is
based
on
my
books
the
company
also
heads
the
android
kernel
developers
group
on
linkedin
if
you
feel
like
dropping
by
and
saying
hi
or
asking
questions
i
do
hope
you
find
the
book
both
interesting
and
entertaining
well
as
entertaining
as
a
technical
book
can
get
i
guess
i'm
always
available
for
comments
feedback
through
the
companion
web
site
throu
h
a
dedicated
forum
i
have
set
up
there
2qfh
pruh
rzh
wkdqnv
wr
rdy
khuqlw
q
d
zd
doo
p
errnv
zloo
ehfdxvh
lw
zdv
klv
lqfhswlrq
zklfk
vwduwhg
p
fduhhu
dv
dq
dxwkru
0d
eh
ehfdxvh
wr
ph
wklv
jrhv
zlwkrxw
vd
lqj
it
actually
did
tkh
suhylrxv
hglwlrq
ehiruh
wkh
qgurlg
0
xsgdwh
glg
qrw
lqfoxgh
wklv
pxfk
qhhghg
wkdqnv
xw
lq
wklv
fdvh
rer
ghvhuyhv
extra
vshfldo
phqwlrq
iru
kdylqj
sxvkhg
ph
lqwr
qgurlg
it
was
he
who
surylged
7hfkqrorjhhnv
zlwk
uhtxluhphqwv
iru
lqx
wr
qgurlg
dqg
odwhu
qgurlg
qwhuqdov
7zr
frxuvhv
zklfk
ehfdph
ehvw
vhoohuv
dqg
xsrq
zklfk
wklv
zrun
v
wzr
yroxphv
duh
edvhg
http
source.android.com
source
index.html
http
android.googlesource.com
http
www.amazon.com
gp
product
1593275811
ref
as_li_tl
ie
utf8
camp
1789
creative
9325
creativeasin
1593275811
linkcode
as2
tag
newosxbookcom
20
linkid
hyqwzpuy2ius3bqr
http
newandroidbook.com
http
twitter.com
technologeeks
http
www.technologeeks.com
ab
i
the
evolution
of
android's
architecture
though
android
is
built
on
linux
and
relies
heavily
on
much
of
its
infrastructure
most
notably
the
kernel
android
has
become
an
operating
system
in
a
class
by
itself
unlike
os
x
and
ios
which
share
the
majority
of
their
code
base
with
the
exception
of
the
ui
and
several
frameworks
android
introduces
a
vast
collection
of
frameworks
as
well
as
a
runtime
to
support
them
dalvik
indeed
most
of
the
user
facing
features
and
enhancements
in
between
versions
have
to
do
with
additional
frameworks
and
apis
being
added
with
only
a
relatively
small
portion
of
them
at
the
system
level
this
chapter
explores
the
evolution
of
android
and
examines
its
architecture
beginning
with
the
android
version
history
from
cupcake
1.5
to
roolsrs
dqg
eh
rqg
we
cover
system
related
features
and
enhancements
in
each
we
then
turn
to
examine
the
android
architecture
comparing
and
contrasting
with
that
of
linux
each
layer
is
described
in
detail
laying
the
foundations
for
the
even
deeper
exploration
carried
out
in
the
next
chapters
and
next
volume
of
this
work
finally
we
consider
the
multitude
of
android
derivatives
as
well
as
future
enhancements
which
may
be
expected
in
the
next
versions
of
this
rapidly
evolving
os
as
this
book
zhqw
to
print
android
5.0
lollipop
zas
made
available
for
select
google
nexi
and
is
scheduled
for
rollout
by
vendor
android
is
moving
so
fast
in
fact
chances
are
that
no
matter
when
you
read
this
a
new
version
of
android
will
only
be
months
away
as
the
mobile
os
arms
race
ensues
this
book
kdv
qrz
ehhq
updated
to
reflect
changes
iwkurxjk
0
suhylhz
uhohdvh
exw
qgurlg
v
udpsdqw
dgydqfh
frqwlqxhv
rqzdugv
it's
wkhuhiruh
a
good
idea
to
check
the
companion
web
site
newandroidbook.com
for
updates
file
users
morpheus
documents
android
book
introduction.html
versions
file
users
morpheus
documents
android
book
introduction.html
vslinux
file
users
morpheus
documents
android
book
introduction.html
derivatives
file
users
morpheus
documents
android
book
introduction.html
wayahead
http
newandroidbook.com
android
version
history
over
its
seven
short
years
android
has
already
undergone
no
less
than
a
dozen
versions
when
one
considers
the
api
versions
which
map
the
internal
set
of
apis
to
the
catchier
condiment
type
this
number
increases
to
2
enumerating
the
many
framework
features
introduced
in
each
version
would
be
tedious
and
likely
miss
out
on
a
few
so
this
section
instead
aims
to
provide
a
more
technical
look
focusing
on
those
api
differences
at
the
system
rather
than
framework
level
as
well
as
other
noteworthy
observations
those
seeking
more
information
about
changes
are
suggested
to
read
the
comprehensive
wikipedia
entry1
or
check
the
android
documentation
for
the
respective
versions
table
1
1
shows
the
android
version
history
and
maps
the
official
release
version
to
that
of
the
api
and
the
kernel
note
that
the
kernel
versions
don't
necessarily
match
in
all
devices
as
some
vendors
compile
their
own
kernel
or
backport
newer
kernels
table
1
1
android
versions
to
date
date
code
name
release
api
kernel
3
2015
lollipop
5.1
22
3.4
armv7
3.10
arm64
11
2014
5.0
5.0.2
21
10
2013
kitkat
4.4
4.4.4
19
20
3.407
2013
jellybean
mr2
4.3
18
11
2012
jellybean
mr1
4.2
4.2.2
17
07
2012
jellybean
4.1
4.1.1
16
3.0.31
12
2011
ice
cream
sandwich
mr1
4.0.3
4.0.4
15
10
2011
ice
cream
sandwich
4.0
4.0.2
14
3.0.1
07
2011
honeycomb
mr2
3.2
3.2.6
13
2.6.3605
2011
honeycomb
mr1
3.1
12
02
2011
honeycomb
3.0
11
02
2011
gingerbread
mr1
2.3.3
2.3.7
10
2.6.35
12
2010
gingerbread
2.3
2.3.2
9
05
2010
froyo
2.2
2.2.3
8
2.6.32
10
2009
éclair
2.0
2.01
2.1
5
7
2.6.29
09
2009
donut
1.6
4
2.6.29
actual
usage
and
probably
some
behavioral
data
is
compiled
by
google
and
is
made
available
through
the
dashboards
on
the
android
developer
website2
since
there
are
virtually
no
devices
remaining
with
versions
older
than
froyo
this
work
does
not
make
any
attempt
to
discuss
them
froyo
froyo
frozen
yogurt
was
the
first
version
of
android
to
support
application
installation
on
external
media
i.e
sdcards
it
additionally
introduced
the
notion
of
android
secure
containers
asec
in
order
to
provide
security
for
files
on
external
media
which
by
its
nature
is
usually
fat
formatted
volumes
the
asec
meckdqlvp
lv
glvfxvvhg
lq
kdswhu
qrwkhu
xvhixo
ihdwxuh
lqwurgxfhg
lq
wklv
yhuvlrq
zdv
86
whwkhulqj
frqqhfwlqj
wkh
ghylfh
dqg
xvlqj
lwv
qwhuqhw
frqqhfwlrq
dv
glvfxvvhg
lq
9roxph
dvwo
ur
r
eurxjkw
vljqlilfdqw
vshhg
lpsuryhphqwv
wr
doyln
zlwk
wkh
lqwurgxfwlrq
ri
xvw
q
7lph
7
frpslodwlrq
e
d
ghglfdwhg
wkuhdg
2
late
2015
m
final
name
unknown
5.2
likely
22mrc
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
en.wikipedia.org
wiki
android_version_history
http
developer.android.com
about
dashboards
index.html
http
developer.android.com
about
versions
android
2.2
highlights.html
file
users
morpheus
documents
android
book
volume
20i
filesystems.html
asec
gingerbread
gingerbread
was
the
first
version
of
android
to
gain
widespread
adoption
and
with
good
reason
it
introduced
significant
enhancements
to
the
system
at
the
dalvik
layer
concurrent
garbage
collection
was
introduced
which
improved
application
response
time
by
running
gc
in
parallel
rather
than
pausing
the
application
during
the
process
likewise
the
jit
mechanism
improved
on
froyo's
the
sensor
apis
underwent
a
complete
revamp
extending
the
sensor
hal
to
support
more
sensor
types
and
making
them
more
accessible
to
native
code
support
for
native
code
was
bolstered
in
other
areas
as
well
providing
native
access
to
audio
graphics
storage
and
even
the
activity
manager
gingerbread
was
also
first
to
introduce
support
for
near
field
communications
nfc
though
it
was
only
till
later
with
ics
that
nfc
was
to
be
adopted
into
ubiquity
by
android
vendors
another
noteworthy
addition
is
support
for
obb
opaque
binary
blobs
referred
to
as
apk
expansion
files
as
a
workaround
to
the
size
limitation
of
application
package
sizes
and
to
provide
optional
encryption
obb
files
are
discussed
in
chapter
2
last
but
not
least
gingerbread
adopted
ext4
in
place
of
yaffs
as
the
default
filesystem
all
these
improvements
aside
gingerbread
is
actually
most
notorious
for
being
the
most
insecure
version
of
android
to
date
apart
from
glitches
with
the
stock
sms
app
which
routed
messages
to
the
wrong
recipients
it
was
riddled
with
quite
a
few
vulnerabilities
which
led
to
an
explosion
in
rootkit
grade
malware
honeycomb
honeycomb
brought
android
to
tablets
in
fact
it
was
a
tablet
only
release
in
that
the
source
tree
was
never
fully
released
nor
meant
to
be
used
for
phones
though
some
vendors
still
tried
to
use
it
nonetheless
the
main
change
was
the
introduction
of
fragments
which
like
windows
multiple
document
interface
mdi
allow
several
client
areas
to
coexist
simultaneously
rather
than
the
single
layout
architecture
which
was
previously
used
honeycomb
also
offered
significant
improvements
in
graphics
introducing
hardware
accelerated
opengl
rendering
for
2d
and
introduced
renderscript
which
is
android's
own
gl
like
language
another
feature
of
importance
was
the
advent
of
storage
encryption
honeycomb
was
the
first
version
of
android
to
offer
low
level
encryption
of
the
user
data
partition
bringing
it
in
line
with
ios
4
which
introduced
it
as
well
the
disk
encryption
in
android
is
carried
out
by
the
linux
device
mapper
and
can
be
thought
of
as
the
next
step
following
the
android
secure
storage
which
was
introduced
in
froyo
more
important
than
the
user
space
features
was
the
introduction
of
multi
core
support
into
android
primarily
this
involved
a
recompilation
of
the
linux
kernel
to
support
smp
as
can
be
seen
zlwk
wkh
xv
r
xqdph
wrro
ru
surf
yhuvlrq
7deohwv
zhuh
wkh
iluvw
ghylfhv
to
utilize
multi
core
architectures
which
have
since
proliferated
to
all
but
the
cheapest
devices
the
android
documentation6
details
the
changes
required
for
code
to
be
smp
safe
most
of
these
are
primarily
in
native
code
though
some
aspects
apply
to
java
as
well
honeycomb
was
the
only
version
of
android
whose
source
code
was
not
made
open
aside
from
select
portions
this
made
some
vendors
wary
and
brought
to
mind
the
fact
that
even
though
android
is
free
google
still
controls
the
system
and
its
licensing
may
change
at
any
point
in
the
future
if
google
so
sees
fit
kdswhu
qwurgxfwlrq
http
developer.android.com
about
versions
android
2.3
highlights.html
file
users
morpheus
documents
android
book
filesystems.html
obb
http
developer.android.com
about
versions
android
3.0
highlights.html
http
developer.android.com
training
articles
smp.html
ice
cream
sandwich
ice
cream
sandwich
ics
brought
many
changes
to
android
as
can
be
expected
from
a
4.0
release
aside
from
the
myriad
ui
enhancements
those
changes
which
were
noticeable
to
users
included
significant
connectivity
enhancements
the
android
vpn
framework
wifi
direct
and
android
beam
ics
adds
another
api
often
overlooked
by
developers
the
callback
which
is
called
at
times
of
memory
pressure
according
to
the
integer
code
specified
an
application
should
release
as
much
memory
as
possible
note
however
that
this
api
is
advisory
applications
can
just
choose
to
ignore
the
callback
which
all
too
many
in
fact
do
jellybean
jellybean's
most
prominent
user
facing
feature
is
in
its
support
for
multiple
users
on
the
same
device
this
feature
more
useful
on
tablets
than
phones
and
formally
only
enabled
on
the
former
allows
several
users
to
operate
the
device
though
only
one
user
can
be
actively
logged
on
each
user
has
a
different
ui
with
separate
widgets
and
applications
and
most
importantly
isolation
of
application
data
we
discuss
the
implementation
of
this
feature
in
detail
in
chapter
8
in
addition
to
this
and
alongside
the
slew
of
ui
features
jellybean
also
provided
application
encryption
and
forward
locking
building
on
froyo's
asec
containers
one
of
the
main
drawbacks
of
android's
open
nature
at
the
time
was
that
it
was
trivial
to
pirate
apps
by
moving
them
between
devices
via
the
sdcard
asec
provides
a
secure
container
for
data
which
can
be
encrypted
by
the
application
and
made
readable
only
by
the
application's
uid
but
still
fails
miserably
on
rooted
devices
this
will
as
mentioned
be
covered
in
chapter
2
jellybean
went
through
three
api
versions
which
introduced
many
changes
both
over
and
under
the
hood
api
17
also
brought
selinux
to
android
for
the
first
time
as
detailed
in
chapter
8
and
sealed
a
gaping
usb
debugging
hole
by
forcing
authentication
over
adb
notable
changes
in
api
18
were
support
for
opengl
es
3.0
bluetooth
audio
video
remote
control
profile
avrcp
1.3
and
bluetooth
low
energy
le
support
as
well
as
the
app
ops
service
whose
ui
was
later
removed
in
4.4.1
which
allows
tweaking
application
permissions
kitkat
version
4.4
of
android
was
codenamed
kitkat
and
was
actually
launched
in
partnership
with
hershey's
it
represents
a
genuine
attempt
by
google
to
combat
the
fragmentation
of
the
android
universe
though
jellybean
is
the
single
most
popular
version
a
large
percentage
of
devices
still
use
old
versions
notably
gingerbread
which
are
not
only
obsolete
but
hamper
apps
from
running
due
to
their
old
api
versions
additionally
middle
and
high
end
market
become
saturated
and
in
the
entry
level
category
android
faces
competition
from
firefox
os
and
others
kitkat's
pet
project
was
svelte
an
initiative
to
enable
a
smooth
experience
on
virtually
any
device
including
low
end
devices
with
512mb
of
ram
part
of
the
rationale
behind
it
is
that
a
smoother
os
with
less
resource
requirements
would
enable
all
vendors
even
those
with
entry
level
devices
to
offer
the
latest
os
version
thereby
ending
fragmentation
doing
so
involved
many
under
the
hood
changes
such
as
rewriting
framework
code
to
use
less
memory
and
starting
services
in
a
serial
manner
to
reduce
memory
pressure
a
new
api
was
added
to
detect
low
ram
ghylfhv
fwlylw
0dqdjhu
lv
rz5dp'hylfh
zklfk
uhwxuqv
wkh
ydoxh
ri
wkh
property
using
this
api
developers
can
detect
the
amount
of
ram
available
and
plan
resources
accordingly
kitkat
also
added
the
service
to
give
developers
as
much
information
as
possible
on
their
application's
footprint
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
developer.android.com
about
versions
android
4.0
highlights.html
http
developer.android.com
about
versions
jelly
bean.html
file
users
morpheus
documents
android
book
security.html
multiuser
file
users
morpheus
documents
android
book
filesystems.html
asec
file
users
morpheus
documents
android
book
security.html
selinux
http
developer.android.com
about
versions
kitkat.html
for
those
devices
which
do
have
ram
kitkat
utilizes
a
new
feature
of
the
linux
kernel
called
zram
this
feature
is
in
fact
newer
than
kitkat
itself
having
only
been
officially
stabilized
and
merged
in
version
3.14
kitkat
uses
3.4
but
google
was
an
early
adopter
in
both
chromeos
and
android
the
features
enables
swapping
to
ram
and
thus
overcomes
one
of
the
major
limitations
of
mobile
devices
the
lack
of
swap
on
flash
devices
while
swapping
to
ram
might
sound
somewhat
counterproductive
it
is
in
fact
a
dramatic
improvement
as
the
swapped
pages
are
compressed
thus
saving
overall
ram
usage
and
quite
fast
to
retrieve
devices
which
use
compressed
ram
will
have
a
special
block
device
e.g
dev
block
zram0
indicated
by
the
proc
swaps
file
compressed
memory
also
made
its
debut
in
ios
version
7.0
a
few
months
before
kitkat
was
announced
several
other
interesting
features
in
kitkat
may
have
borrowed
from
ios
7.0
include
a
vwhs
frxqwhu
vriwzduh
ghilqhg
vhqvru
dv
dq
dqvzhu
wr
ssoh
v
0
dv
zhoo
dv
wlphu
frdohvflqj
dqg
vhqvru
edwfklqj
7kh
odwwhu
wzr
duh
d
vljqlilfdqw
lpsuryhphqw
wkdw
khosv
pd
lpl
h
edwwhu
olih
7r
gr
vr
qgurlg
dfwxdoo
uhgxfhv
wkh
judqxodulw
ri
wlphuv
dqg
xsgdwhv
iurp
vhqvruv
pdnlqj
wkhp
pruh
frduvh
exw
dovr
pruh
olnho
wr
frlqflgh
7klv
fdq
juhdwo
lpsuryh
edwwhu
wlph
erwk
gluhfwo
orqjhu
shulrgv
ri
38
lgoh
wlph
dqg
lqgluhfwo
uhgxflqj
wkh
ryhudoo
qxpehu
ri
zdnhxsv
zklfk
duh
frvwo
erwk
lq
srzhu
dqg
shuirupdqfh
other
notable
features
in
kitkat
include
bluetooth
map
support
infrared
blaster
consumerir
apis
a
new
printing
framework
and
nfc
host
card
emulation
probably
the
most
far
reaching
change
however
was
unannounced
and
kept
under
the
scenes
introducing
the
android
runtime
art
as
an
optional
replacement
to
dalvik
at
the
time
of
writing
kitkat
has
undergone
four
minor
revisions
and
its
most
recent
version
is
4.4.4
those
revisions
are
mostly
bug
fixes
and
camera
enhancements
and
do
not
change
the
api
version
though
internal
apis
have
been
modified
lw.dw
uhpdlqv
wkh
prvw
frpprq
qgurlg
yhuvlrq
lqvwdoohg
rq
ri
ghylfhv
dv
ri
odwh
sulo
lollipop
the
latest
version
of
android
at
the
time
of
writing
is
android
lollipop
the
most
obvious
user
facing
change
in
this
version
is
the
introduction
of
material
design
a
flat
interface
which
aims
to
provide
realistic
lighting
and
motion
effects
and
print
based
design
which
is
strangely
reminiscent
of
ios
7
s
overhaul
another
emphasis
in
this
release
is
on
notifications
support
for
which
has
been
greatly
expanded
under
the
hood
are
far
more
significant
changes
first
and
foremost
is
the
adoption
of
the
android
runtime
art
which
brings
performance
improvements
by
compiling
dalvik
code
to
native
code
ahead
of
time
aot
rather
than
just
in
time
jit
aside
from
performance
art
also
allows
android
apps
to
exploit
the
benefits
of
64
bit
architecture
dv
glvfxvvhg
lq
ghswk
lq
9roxph
the
graphics
stack
has
been
updated
with
support
for
opengles
3.1
and
the
audio
frameworks
have
been
upgraded
particularly
for
better
audio
input
handling
likewise
camera
apis
have
been
revamped
sensor
support
via
the
hardware
abstraction
layer
has
been
upgraded
with
support
for
more
complicated
gestures
and
even
a
heart
rate
monitor
the
pet
project
of
this
release
is
project
volta
which
aims
to
both
improve
battery
life
through
the
new
mre
vfkhgxolqj
3
dqg
surylgh
ehwwhu
srzhu
prqlwrulqj
wrrov
qrwdeo
wkh
service
lollipop
also
serves
as
the
foundation
iru
wkh
qhz
qgurlg
79
kdswhu
qwurgxfwlrq
http
developer.android.com
about
versions
lollipop.html
android
m
final
name
as
yet
is
unknown
is
oo
le's
latest
version
of
android
it
was
announced
in
oo
le
i
on
5
2
2015
havin
learnt
from
the
mistakes
made
with
l
oo
le
has
committed
to
a
strict
timeline
consistin
of
three
developer
releases
each
a
month
apart
with
a
final
release
date
by
the
end
of
2015
oo
le
provided
both
mulator
and
factory
ima
es
for
the
oo
le
exi
includin
for
the
first
time
ima
es
for
arm64
which
the
m
emulator
in
the
android
sdk
now
supports
sources
are
also
available
throu
h
the
android
it
repository
rom
a
feature
perspective
m
seems
more
of
an
evolutionary
update
than
a
revolutionary
one
while
it
adds
several
noteworthy
features
these
are
mostly
in
response
to
i
s
and
include
support
for
payments
built
in
fin
erprint
authentication
which
was
introduced
in
lollipop
but
is
now
made
available
for
use
by
apps
and
floatin
toolbars
for
text
selection
an
important
improvement
comes
int
the
form
of
revampin
the
app
permission
model
which
finally
moves
the
permission
enforcement
to
runtime
rather
than
install
time
this
brin
s
android
in
line
with
the
i
s
model
by
promptin
the
user
to
allow
sensitive
operations
when
they
happen
rather
than
approve
a
mile
lon
list
of
permissions
in
bulk
upon
installation
discussed
more
in
chapter
and
reatly
miti
ates
the
potential
for
tro
an
apps
surreptitiously
tryin
to
access
your
personal
information
or
camera
while
entertainin
you
with
a
flappin
bird
m
also
aims
to
improve
on
two
drawbacks
of
its
predecessors
data
encryption
which
was
introduced
with
honeycomb
and
enabled
by
default
in
lollipop
is
now
extended
to
external
stora
e
by
means
of
adopted
devices
power
mana
ement
always
a
challen
in
issue
is
further
improved
with
do
e
mode
sleepin
for
lon
intervals
between
periodic
wakeups
for
app
syncin
and
pendin
work
m
also
introduces
app
idle
detection
somewhat
reminiscent
of
s
s
app
ap
feature
which
suspends
apps
which
are
not
in
use
ther
more
ori
inal
features
include
direct
share
app
linkin
improvements
to
audio
video
syncin
includin
fast
or
slow
motion
playback
midi
support
direct
flashli
ht
torch
support
camera
api
extensions
improved
notifications
and
si
nificant
enhancements
for
android
for
work
a
full
list
of
chan
es
can
be
found
on
the
android
developer
website
http
developer.android.com
preview
api
overview.html
if
oo
le
is
true
to
their
own
advertised
schedule
m
may
overtake
lollipop
whose
adoption
rate
is
still
dwindlin
in
the
low
teens
as
best
endors
may
choose
to
wait
a
bit
rather
than
have
to
o
throu
h
the
lon
process
of
up
radin
to
lollipop
only
to
be
forced
to
up
rade
a
ain
when
m
comes
out
shortly
after
m
lollipop
v
release
was
quite
lengthy
and
somewhat
painful
it
took
google
about
six
months
from
announcement
to
official
launch
and
even
at
the
time
of
writing
it
is
supported
mainly
on
the
google
nexi
zlwk
d
shqhwudwlrq
udwh
ri
derxw
dqg
wkdw
wrr
iru
yhuvlrqv
ehiruh
major
bugs
ironically
relating
to
power
management
and
performance
have
been
discovered
in
the
earlier
releases
and
pxfk
wr
wkh
fkdjulq
ri
yhqgruv
zkr
duh
vwloo
sod
lqj
fdwfk
xs
sxvkhg
rrjoh
wr
xsgdwh
lollipop
dv
ri
to
5.1
with
3
ohyho
dqg
numerous
bugfixes
5.1
adds
p
uldg
8
wzhdnv
and
more
lpsruwdqwo
qrwdeoh
ihdwxuhv
vxfk
dv
9rlfh
fdoolqj
xdo
6,0
vxssruw
dqg
device
3urwhfwlrq
wkh
pxfk
qhhghg
nloo
vzlwfk
wr
orfn
vwrohq
ghylfhv
uhprwho
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
developer.android.com
preview
http
developer.android.com
preview
api
overview.html
experiment
figuring
out
your
device's
android
version
though
vendors
customize
android
in
a
variety
of
ways
the
basic
underlying
system
is
the
same
most
android
users
are
familiar
with
the
settings
system
about
phone
gui
which
provides
details
about
the
android
version
used
the
relevant
class
is
found
under
the
aosp's
packages
apps
settings
which
uses
the
android.os.build
class
the
values
however
are
obtained
from
system
properties
so
an
often
simpler
way
of
getting
to
those
values
is
directly
using
the
jhwsurs
wrro
7klv
lv
vkrzq
lq
ljxuh
figure
1
1
mappings
between
the
settings
app
and
system
properties
the
property
settings
which
are
generated
from
the
aosp
and
placed
into
system
build.prop
hold
true
on
modified
builds
as
well
even
those
as
heavily
customized
as
amazon's
fireos
the
most
useful
properties
are
api
version
and
which
is
itself
an
amalgam
of
several
other
properties
for
example
property
describes
ro.product.manufacturer
vendor
id
ro.product.name
device
code
name
for
google
fish
names
ro.build.product:version.release
product
name
and
android
base
version
ro.build.id
first
letter
version
rest
described
in
the
documentation11
ro.build.version.incremental
internal
build
number
auto
incremented
by
aosp
build
system
ro.build.type
user
user
facing
eng
engineers
internal
ro.build.tags
release
keys
production
system
actual
certificates
test
keys
development
as
of
jellybean
the
build
version
provides
the
backdoor
functionality
to
the
developer
settings
which
include
adb
by
clicking
seven
times
on
the
view
chapter
i
introduction
https
source.android.com
source
build
numbers.html
platform
code
names
versions
api
levels
and
ndk
releases
android
vs
linux
not
just
another
linux
distribution
linux
the
core
of
android
has
been
around
for
well
over
a
decade
before
android
was
even
conceived
linux
is
a
fully
open
source
operating
system
whose
kernel
started
as
a
master's
thesis
of
one
linus
torvalds
and
has
since
gained
worldwide
fame
and
adoption
a
kernel
alone
however
does
not
a
full
operating
system
make
torvalds
decided
to
release
his
work
as
open
source
and
attracted
developers
who
extended
it
further
by
providing
components
for
it
binaries
both
ported
from
other
un
x
systems
as
well
as
original
ones
linux
exploded
in
popularity
as
a
free
alternative
to
the
expensive
un
x
systems
of
the
time
effectively
undercutting
them
and
leading
to
the
demise
of
most
along
its
rapid
evolution
linux
attracted
commercial
interest
companies
whose
sole
purpose
was
to
package
the
kernel
along
with
additional
binaries
sprouted
and
provided
distributions
of
linux
these
companies
often
provided
linux
for
free
basing
their
entire
business
model
on
support
at
times
professional
or
enterprise
grade
distributions
containing
custom
tweaks
or
specialized
tools
were
provided
costing
money
to
license
linux
quickly
became
the
de
facto
operating
system
of
the
embedded
space
contrary
to
other
players
in
the
field
such
as
windows
ce
which
required
too
many
resources
and
real
time
operating
systems
such
as
psos
or
vxworks
both
of
which
involved
heavy
licensing
fees
linux
offered
a
platform
that
was
not
only
free
but
fully
customizable
and
light
weight
one
company
montavista
based
its
entire
business
model
on
porting
linux
to
the
embedded
space
notably
the
arm
mips
and
powerpc
architectures
the
port
provided
for
embedded
platforms
the
same
functionality
as
that
which
was
provided
on
the
desktop
a
fully
featured
shell
environment
all
for
a
generous
licensing
fee
but
developers
needed
more
long
gone
are
the
days
of
shell
interfaces
and
all
users
save
for
battle
hardened
veterans
expect
a
graphical
user
interface
from
their
operating
system
linux
relied
on
x
windows
the
traditional
un
x
windows
architecture
for
its
gui
setting
up
a
gui
on
an
embedded
platform
was
far
from
straightforward
graphics
programming
using
x
windows
api
was
also
quite
cumbersome
additionally
vendors
such
as
montavista
provided
just
the
basic
platform
developers
still
had
to
port
additional
components
and
create
their
own
often
having
to
start
from
scratch
and
then
came
android
google
spotted
the
promise
in
a
mobile
operating
system
back
in
2005
when
they
acquired
android
then
a
small
startup
by
andy
rubin
android
disappeared
off
the
map
till
its
resurgence
some
years
later
shortly
after
apple's
iphoneos
mobile
vendors
trying
to
adapt
to
the
revolutionary
device
quickly
wanted
to
provide
a
similar
experience
and
needed
to
catch
up
quickly
android's
novelty
arises
from
what
it
aims
to
provide
not
just
another
linux
distribution
but
a
full
software
stack
the
term
stack
implies
several
layers
android
provides
not
just
the
basic
kernel
and
shell
binaries
but
also
a
self
contained
gui
environment
and
a
rich
set
of
frameworks
coupled
with
a
simple
to
use
development
language
java
android
gives
developers
a
true
rapid
application
development
rad
environment
as
they
can
draw
on
pre
written
well
tested
code
in
the
frameworks
to
access
advanced
functionality
such
as
cameras
motion
sensors
gui
widgets
and
more
in
a
few
lines
of
code
with
features
that
at
first
borrowed
heavily
from
ios
and
later
improved
on
them
android
became
the
de
facto
os
for
mobile
much
as
windows
is
for
the
desktop
or
linux
was
elsewhere
android
internals
a
confectioner's
cookbook
volume
i
android
has
since
had
its
hegemony
constantly
reinforced
by
the
feedback
loop
of
its
ecosystem
android's
app
marketplace
which
quickly
followed
apple's
app
store
adopted
that
model
to
allow
developers
to
quickly
distribute
their
apps
in
a
manner
far
more
and
some
would
say
too
relaxed
with
virtually
no
hurdles
the
result
is
that
google
play
as
the
marketplace
is
now
known
has
surpassed
the
app
store
and
offers
millions
of
apps
adopting
android
provides
a
mobile
vendor
with
instant
access
and
compatibility
with
those
apps
but
only
if
they
comply
with
google's
mobile
application
distribution
agreement
mada
which
mandates
full
integration
of
google's
apps
and
services
in
a
sense
android
has
done
to
montavista
and
other
embedded
linux
firms
what
linux
has
done
to
un
x
and
other
competitors
undercutting
by
providing
a
totally
free
alternative
google
pushes
android
for
free
with
no
licensing
fees
at
least
for
now
and
fairly
relaxed
terms
of
use
wkrxjk
wkrvh
duh
jhwwlqj
wljkwhu
vorzo
exw
vxuho
w
v
qr
zrqghu
wkhq
wkdw
android
has
risen
in
only
a
few
years
to
achieve
almost
total
hegemony
of
about
80
of
the
global
mobile
market
leaving
only
a
persistent
bastion
of
ios
presently
at
about
20
along
with
nigh
insignificant
dregs
of
windows
mobile
and
blackberry
a
mobile
vendor
basically
has
only
very
limited
options
in
a
choice
of
operating
system
develop
a
homegrown
one
or
go
with
a
ready
made
one
nearly
all
opt
for
the
latter
and
then
the
choice
boils
down
to
android
or
windows
mobile
microsoft
has
tried
to
follow
the
android
model
and
offer
its
system
for
free
but
the
effort
was
too
little
and
far
too
late
as
it
lacks
the
ecosystem
blackberry
on
its
own
part
has
ported
the
android
runtime
to
its
own
os
hoping
to
win
back
market
share
by
providing
runtime
compatibility
with
the
multitude
of
android
apps
commonalities
and
divergences
from
linux
android
is
built
on
top
of
linux
but
modifies
it
in
substantial
ways
including
some
which
break
compatibility
with
the
mainstream
the
android
kernel
source
tree
diverged
from
the
mainline
kernel
around
version
2.6.27
but
has
been
converging
since
version
3.3
in
user
mode
google
maintains
the
frameworks
and
runtime
of
the
aosp
android
open
source
project
in
an
entirely
separate
repository
from
a
high
level
perspective
though
it's
hard
to
quantify
exactly
how
much
the
two
oses
differ
a
safe
estimate
would
be
that
android
and
linux
are
about
95
alike
at
the
kernel
level
and
about
65
or
so
at
the
user
mode
this
guesstimate
is
drawn
by
taking
into
consideration
that
at
the
kernel
level
aside
from
a
few
differences
arm
platform
and
drivers
not
withstanding
the
rest
of
the
kernel
source
is
unmodified
those
differences
which
include
ipc
memory
and
logging
enhancements
are
collectively
referred
to
as
androidisms
and
most
have
in
fact
by
now
been
merged
into
the
mainline
either
replaced
with
similar
kernel
functionality
or
included
in
the
drivers
staging
android
directory
at
the
user
mode
level
there
is
more
of
a
divergence
introducing
two
entirely
new
components
the
dalvik
runtime
and
the
hardware
abstraction
layer
as
well
as
replacing
glibc
with
bionic
and
providing
a
custom
version
of
init
the
system
startup
daemon
the
underlying
os
however
still
remains
for
the
most
part
unmodified
with
native
binaries
processes
and
threads
behaving
as
they
do
on
linux
this
enables
the
approach
taken
in
this
book
of
discussing
low
level
linux
based
approaches
for
debugging
and
tracing
as
is
discussed
in
chapter
7
android
also
makes
more
clever
use
of
features
present
in
linux
though
left
unused
in
most
desktop
distributions
these
include
control
groups
low
memory
conditions
linux
oom
which
android
expands
on
with
its
low
memory
killer
and
security
features
capabilities
and
selinux
as
discussed
in
chapter
8
android
also
uses
quite
a
few
open
source
projects
which
were
of
limited
popularity
in
linux
but
form
the
backbone
of
its
feature
set
these
projects
in
the
external
folder
of
the
aosp
are
odujho
uhvsrqvleoh
iru
lpsohphqwlqj
qgurlg
v
qhwzrun
fdsdelolwlhv
dqg
lqfoxgh
vpn
service
discovery
and
wi
fi
direct
and
tethering
and
wi
fi
direct
and
wi
fi
other
open
source
projects
provide
library
level
support
discussed
and
shown
later
in
table
1
3
mobile
device
vendors
are
becoming
increasingly
uneasy
with
several
shortcomings
of
android
the
first
is
the
common
feature
base
which
makes
it
hard
to
differentiate
their
product
from
others
the
second
is
increased
dependency
on
google
which
actually
strives
to
enforce
the
android
look
and
feel
across
devices
lastly
google's
mobile
application
distribution
agreement
mada
which
forces
the
inclusion
of
all
google
apps
in
order
to
gain
access
to
the
play
market
this
has
led
some
vendors
notably
samsung
to
look
at
alternatives
e.g
tizen
at
present
android
seems
to
be
fully
entrenched
and
not
likely
to
lose
dominance
any
time
soon
chapter
i
introduction
file
users
morpheus
documents
android
book
linuxlens.html
file
users
morpheus
documents
android
book
security.html
figure
1
2
compares
and
contrasts
the
software
stacks
provided
by
linux
and
android
we
then
move
to
explore
the
notable
differences
in
turn
figure
1
2
the
android
architecture
compared
with
that
of
mainstream
linux
most
developers
are
probably
familiar
with
the
google
provided
architectural
diagram
returned
by
searching
for
android
architecture
ad
nauseam
virtually
all
other
books
on
android
include
it
in
their
introduction
often
with
the
exact
same
colors
that
diagram
in
this
author's
opinion
is
simplified
and
not
at
all
accurate
in
its
representation
of
layers
for
example
jni
is
entirely
overlooked
as
the
layers
unfold
this
slightly
different
rendition
of
the
architecture
will
hopefully
make
sense
just
as
much
as
if
not
more
than
the
traditional
diagram
only
as
this
book
goes
to
print
has
google
finally
provided
a
more
accurate
and
visually
appealing
diagram
at
the
android
source
website12
the
android
frameworks
android
owes
a
key
part
of
its
success
to
its
rich
set
of
frameworks
without
them
android
would
have
likely
ended
up
as
just
another
embedded
linux
distribution
and
would
have
in
fact
gone
the
way
of
montavista
which
was
highly
popular
before
android
made
its
debut
by
providing
the
frameworks
android
facilitates
the
application
creation
process
allowing
developers
to
use
the
higher
level
java
language
rather
than
low
level
c
c
the
addition
of
the
frameworks
further
expedites
the
process
as
developers
can
draw
on
the
plentiful
apis
which
handle
graphics
audio
and
hardware
access
unlike
x
windows
and
gnome
kde
these
are
far
simpler
and
operate
in
a
much
more
straightforward
manner
through
the
use
of
java
package
naming
android
frameworks
are
divided
into
separate
namespaces
according
to
their
functionality
packages
in
the
android
namespace
are
available
for
use
by
developers
packages
in
com.android
are
internal
android
also
supports
most
of
the
standard
java
runtime
packages
in
the
java
namespace
table
1
2
shows
the
breakdown
of
the
commonly
used
frameworks
by
package
sorted
by
the
api
version
they
were
introduced
in
so
as
to
give
an
idea
as
to
the
evolution
of
the
operating
system
features
note
that
the
table
only
shows
when
frameworks
made
their
debut
and
does
not
show
their
expansion
which
does
occur
in
between
api
versions
as
more
classes
are
added
android
internals
a
confectioner's
cookbook
volume
i
http
source.android.com
images
android_framework_details.png
table
1
2
the
android
frameworks
package
name
api
contents
android.app
1
application
support
android.content
content
providers
android.database
database
support
mostly
sqlite
android.graphics
graphics
support
android.opengl
opengl
graphics
support
android.hardware
camera
input
and
sensor
support
android.location
location
support
android.media
media
support
android.net
network
support
built
over
java.net
apis
android.os
core
os
service
and
ipc
support
android.provider
built
in
android
content
providers
android.sax
sax
xml
parsers
android.telephony
core
telephony
support
android.text
text
rendering
android.view
ui
components
similar
to
ios's
uiview
android.webkit
webkit
browser
controls
android.widget
application
widgets
android.speech
3
speech
recognition
and
speech
to
text
android.accounts
4
support
for
account
management
and
authentication
android.gesture
custom
gesture
support
android.accounts
5
user
account
support
android.bluetooth
bluetooth
support
android.media.audiofx
9
audio
effects
support
android.net.sip
support
for
voip
using
the
session
initiation
protocol
rfc3261
android.os.storage
support
for
opaque
binary
blobs
obb
android.nfc
support
for
near
field
communication
android.animation
11
animation
of
views
and
objects
android.drm
digital
rights
management
and
copy
protection
android.renderscript
renderscript
opencl
like
computation
language
android.hardware.usb
12
usb
peripheral
support
android.mtp
mtp
ptp
support
for
connected
cameras
etc
android.net.rtp
support
for
the
real
time
protocol
rfc3501
android.media.effect
14
image
and
video
effects
support
android.net.wifi.p2p
support
for
wi
fi
direct
peer
to
peer
android.security
support
for
keychains
and
keystores
android.net.nsd
16
neighbor
service
discovery
through
multicast
dns
bonjour
android.hardware.input
input
device
listeners
this
table
while
detailed
is
not
comprehensive
and
only
reflects
the
more
important
classes
a
full
list
can
be
found
at
http
developer.android.com
sdk
api_diff
changes.html
replacing
with
the
api
level
chapter
i
introduction
figure
1
3
dalvik
iceland
photo
by
author
table
1
2
cont
the
android
frameworks
package
name
api
contents
android.hardware.display
17
external
and
virtual
display
support
android.service.dreams
dream
screensaver
support
android.graphics.pdf
19
pdf
rendering
android.print
pdf
support
for
external
printing
android.app.job
21
job
scheduler
android.bluetooth.le
bluetooth
low
energy
le
support
android.hardware.camera2
the
new
camera
apis
android.media
browse
projection
session
tv
media
browsing
and
tv
support
android.service.voice
activation
by
hot
words
e.g
ok
google
android.system
and
in
practice
the
entire
set
of
frameworks
is
bundled
into
several
java
archive
jar
files
on
the
device
in
system
framework
and
in
l
precompiled
into
the
boot.art
file
although
the
aosp
is
open
source
it
can
come
in
quite
handy
to
locate
a
package
directly
in
the
jar
itself
which
you
can
gr
e
lqyrnlqj
gh
gxps
ru
wkh
gh
wud
wrro
rq
wkh
fodvvhv
gh
ilohv
lqvlgh
wkh
5v
the
dalvik
virtual
machine
android's
other
notable
addition
is
the
introduction
of
the
dalvik
virtual
machine
this
vm
became
key
to
making
android
workable
on
mobile
devices
back
when
256m
of
memory
was
considered
plenty
dalvik
was
not
the
first
type
of
virtual
machine
to
be
attempted
on
mobile
devices
sun
microsystems
hoped
to
push
java
2
mobile
edition
j2me
but
with
very
little
success
dalvik
is
largely
the
brainchild
of
dan
bornstein
whose
google
i
o
2008
presentation
serves
as
a
great
reference
as
to
its
design
the
qdph
doyln
was
fkrvhq
lq
krqru
ri
d
fishing
village
in
northern
iceland
the
dalvik
vm
though
seemingly
java
esque
is
actually
not
a
java
virtual
machine
though
not
too
far
removed
from
one
it
runs
a
different
form
of
bytecode
called
dex
for
dalvik
executable
and
is
more
optimized
for
efficiency
and
sharing
memory
than
the
jvm
designed
by
sun
oracle
those
very
optimizations
enabled
it
to
prevail
despite
the
strict
constraints
of
mobile
platforms
which
have
felled
java
specifically
j2me
from
gaining
ground
outside
limited
implementations
android
used
a
subset
of
the
apache
harmony
files
as
basis
for
its
core
classes
harmony
was
chosen
as
a
free
apache
license
open
source
clone
of
then
sun's
now
oracle's
jvm
oracle
actually
sued
google
in
2010
for
never
properly
acquiring
a
license
for
the
java
class
libraries
and
the
saga
is
far
from
conclusion
even
in
early
2015
as
this
book
goes
to
print
dalvik
is
being
superseded
by
the
android
runtime
art
as
described
later
in
this
chapter
contrary
to
popular
belief
however
this
does
not
mean
dalvik
is
going
away
only
the
just
in
time
jit
compilation
aspect
of
it
has
been
replaced
but
the
file
format
dex
is
still
very
much
alive
as
are
the
key
architectural
concepts
we
therefore
discuss
both
dalvik
dng
art
in
great
detail
in
volume
ii
android.shuylfh
fduulhu
606
006
vxssruw
duulhu0hvvdjlqj6huylfh
2
android
internals
a
confectioner's
cookbook
volume
i
https
www.youtube.com
watch
v
ptjedozexpm
file
users
morpheus
documents
android
book
introduction.html
art
jni
android
applications
run
in
the
virtual
machine
but
at
times
need
to
escape
it
usually
to
access
hardware
or
other
device
or
chipset
specific
features
dalvik
therefore
allows
the
inclusion
of
native
libraries
elf
shared
objects
in
application
code
through
the
java
native
interface
jni
android
has
somewhat
of
a
love
hate
relationship
with
jni
no
doubt
vendors
would
be
happier
with
pure
dalvik
applications
as
those
are
confined
in
the
vm
and
thus
remain
agnostic
to
the
underlying
architecture
in
this
way
android
applications
would
run
universally
on
intel
arm
mips
and
other
architectures
with
no
modification
on
the
other
hand
the
vm
environment
is
not
without
its
limits
especially
when
it
concerns
graphics
and
drawbacks
notably
decompilation
it
is
therefore
not
at
all
uncommon
to
see
jni
used
in
applications
optimizing
for
performance
or
seeking
resistance
to
reverse
engineering
google
therefore
provides
the
native
development
kit
ndk
grzqordgdeoh
dw
android
developer14
which
developers
can
use
to
build
native
libraries
and
binaries
not
all
applications
use
jni
but
in
those
that
do
jni
libraries
can
be
easily
seen
in
the
package
apk
since
they
are
in
a
separate
folder
lib
architecture
a
good
example
of
this
can
be
found
in
the
dropbox
app
here
in
an
output
from
a
galaxy
tab
3
10.1
providing
jni
support
for
no
less
than
four
different
architectures
output
1
1
demonstrating
jni
libraries
in
an
apk
jni
normally
works
seamlessly
across
arm
devices
which
comprise
the
vast
majority
though
processor
version
differences
e.g
armv6
armv7
do
require
different
libraries
hence
armeabi
and
armeabi
v7a
in
the
output
when
it
comes
to
x86
architectures
jni
is
a
major
headache
for
intel
who
would
like
to
see
more
vendors
use
its
chipsets
for
android
rather
than
depend
on
the
app
developers
to
compile
an
x86
specific
version
most
don't
intel
provides
a
closed
source
arm
emulation
called
houdini
extending
dalvik
art
as
discussed
later
in
volume
ii
as
part
of
their
android
distribution
this
emulator
along
with
a
few
minor
modifications
in
dalvik
enables
arm
native
libraries
to
work
on
intel
architectures
native
binaries
from
the
linux
perspective
all
executables
are
elf
binaries
android's
critical
system
component
are
implemented
in
c
c
and
are
compiled
into
native
binaries
user
applications
are
compiled
into
dalvik
bytecode
but
the
bytecode
runs
or
in
art
is
compiled
ahead
of
time
in
the
context
of
a
dalvik
virtual
machine
which
is
in
and
of
itself
an
elf
binary
thus
while
most
developers
remain
oblivious
to
binaries
they
nonetheless
play
an
important
role
in
android
binaries
are
usually
located
in
system
bin
and
system
xbin
with
a
few
critical
binaries
located
in
sbin
most
binaries
are
usually
the
same
across
all
devices
being
part
of
the
aosp
but
it
is
not
xqfrpprq
wr
ilqg
dgglwlrqdo
elqdulhv
iurp
wkh
yhqgru
ru
fklsvhw
manufacturer
e.g
on
qualcomm
msm
multi
core
devices
you
can
see
a
list
of
processes
loaded
from
native
binaries
dw
dq
wlph
e
ilowhulqj
wkh
sv
frppdqg
7klv
lv
shown
in
output
1
2
from
an
htc
one
m8
with
the
aosp
binaries
highlighted
1rw
wr
eh
frqixvhg
zlwk
wkh
frpphufldo
dss
ri
wkh
vdph
qdph
xvhg
wr
iru
forxg
vwrudjh
chapter
i
introduction
http
developer.android.com
tools
sdk
ndk
index.html
output
1
2
native
binaries
executing
on
an
an
htc
one
m8
because
elf
is
a
standard
file
format
you
can
use
any
of
the
linux
elf
parsing
tools
such
as
or
other
tools
in
the
set
of
to
handle
the
android
binaries
the
android
ndk
provides
the
full
toolset
cross
compiled
so
it
can
run
on
the
host
in
the
toolchains
directory
supporting
x86
mips
arm
and
as
of
r10d
arm64
as
shown
in
output
1
3
output
1
3
locating
the
android
ndk's
binutils
android
internals
a
confectioner's
cookbook
volume
i
bionic
contrary
to
linux
distributions
which
use
gnu's
libc
glibc
as
their
core
runtime
the
familiar
libc.so
android
elects
to
use
its
own
c
runtime
library
which
is
called
bionic
this
is
touted
as
being
motivated
chiefly
by
simplicity15
though
in
practice
there
is
a
legal
consideration
as
well
the
gnu
public
license
gpl
places
limitations
on
code
which
can
use
glibc
similar
iq
some
respects
to
gpl
portions
in
the
kernel
and
google
sought
to
avoid
that
bionic
is
open
source
but
uses
a
hybrid
of
the
bsd
license
which
is
far
more
permissive
for
third
party
linkage
as
well
as
android's
own
license
omissions
legal
issues
aside
bionic
is
more
lightweight
than
glibc
and
more
efficient
for
android's
purposes
leaving
out
features
deemed
unnecessary
or
too
complicated
notable
omissions
are
streamlined
system
call
support
since
system
calls
are
called
frequently
bionic
aims
to
optimize
them
by
providing
the
thinnest
wrappers
possible
the
system
call
stubs
are
generated
with
the
help
of
bionic
libc
syscalls.txt
some
system
calls
are
not
at
all
exported
no
support
for
system
v
ipc
among
the
system
calls
not
exported
by
bionic
are
those
dealing
with
un
x
system
v
inter
process
communication
and
shared
memory
this
was
a
design
decision
in
android
deprecating
these
forms
of
ipc
in
favor
of
android's
own
ashmem
and
binder
described
in
volume
ii
limited
pthread
functionality
on
the
one
hand
pthread
support
is
built
in
to
bionic
i.e
not
a
separate
libpthread.so
on
the
other
the
pthread
support
is
not
full
with
the
most
qrwdeoh
ihdwxuh
plvvlqj
lv
vxssruw
iru
wkuhdg
fdqfhoodwlrq
yld
swkuhdgbfdqfho
mutex
support
is
also
stripped
down
made
more
efficient
by
relying
on
the
kernel's
fast
mutex
the
ixwh
v
vwhp
fdoo
exw
kljkhu
ohyho
3
remhfwv
h
j
uzorfnv
kdyh
ehhq
ohiw
rxw
limited
c
support
though
c
is
supported
indeed
most
of
android's
code
is
written
in
c
exceptions
are
not
likewise
the
standard
template
library
stl
is
not
included
though
there
is
no
restriction
for
linking
against
it
manually
a
port
can
be
found
in
external
stlport
project
no
support
for
locales
and
or
wide
characters
bionic
natively
needs
only
ascii
though
unicode
is
also
supported
via
libutils.so
the
omissions
make
sense
considering
that
most
code
is
meant
to
be
done
in
the
virtual
machine
and
the
vm
itself
is
written
to
avoid
needing
these
functions
for
example
the
vm
has
its
own
thread
management
and
unicode
support
via
icu
these
omissions
do
however
pose
challenges
to
native
code
developers
especially
those
who
seek
to
port
libraries
and
executables
from
linux
to
android
as
we
discuss
later
additions
bionic
also
adds
quite
a
few
features
to
the
standard
libc
which
are
optimized
for
android
these
include
system
properties
properties
are
a
unique
feature
of
android
which
allow
both
the
system
as
well
as
applications
to
supply
various
configuration
and
operational
parameters
in
a
simple
key
value
store
this
is
similar
to
the
notion
of
java
properties
and
in
fact
is
accessible
through
java's
system.properties
android
relies
heavily
on
this
mechanism
which
is
supplied
through
a
shared
memory
region
accessible
and
read
only
to
all
processes
on
the
system
but
settable
only
through
init
we
discuss
the
implementation
of
properties
in
chapter
4
google
is
avoiding
gpl
and
licensing
issues
not
just
in
bionic
but
in
other
components
e.g
udevd
gpl
has
strict
legal
restrictions
requiring
linkage
with
likewise
gpl
open
source
components
avoiding
gpl
maintains
an
option
for
them
to
close
the
source
at
any
time
in
the
future
as
they
did
once
with
parts
of
honeycomb
chapter
i
introduction
http
android
platform.googlegroups.com
attach
0f8eba5ecb95c6f4
overview.txt
view
1
part
4
file
users
morpheus
documents
android
book
services.html
systemproperties
hard
coded
uid
gid
implementation
rather
than
rely
on
the
passwd
and
group
files
as
traditional
un
x
does
android
opts
instead
to
hard
code
the
ids
and
emulate
getpwnam
3
and
friends
the
reasoning
for
this
becomes
clear
when
android's
security
model
is
considered
every
application
is
assigned
its
own
uid
and
gid
beginning
with
10000
and
those
ids
are
then
mapped
to
the
human
readable
app_uxxx
or
as
of
jellybean
uxx_ayyy
format
additionally
android
reserves
the
lower
uid
gid
range
1000
9999
for
its
own
subsystems
the
aids
defined
along
with
directory
permissions
in
android_filesystem_config.h
are
described
in
more
detail
in
chapter
8
which
deals
with
vhfxulw
built
in
dns
resolution
bionic
integrates
the
dns
name
to
ip
resolution
code
traditionally
in
libresolv.so
the
code
used
in
bionic
is
more
secure
randomizes
both
source
port
and
query
id
to
mitigate
birthday
attacks
and
introduces
a
novel
feature
per
process
dns
resolution
this
allows
capturing
and
redirecting
dns
requests
by
specific
applications
through
the
definition
of
net.dns.pid
system
properties
the
dns
configuration
itself
is
also
stored
in
properties
net.dns
the
nsswitch.conf
which
on
linux
allows
name
resolution
through
alternate
protocols
e.g
nis
ldap
is
understandably
not
supported
though
resolv.conf
is
still
supported
in
system
etc
hard
coded
services
and
protocols
doing
away
with
libresolv.so
entirely
android
removes
support
for
the
protocols
and
services
files
commonly
found
in
etc
on
un
x
and
emulates
through
its
internal
__res_get_static
other
apis
such
as
are
not
supported
porting
challenges
as
with
the
omissions
the
additions
pose
a
challenge
when
trying
to
port
code
the
other
way
around
that
is
from
android
to
linux
if
these
could
be
overcome
one
could
ostensibly
port
dalvik
to
linux
or
other
oses
as
indeed
some
developers
have
discussed
in
volume
ii
and
have
android
apps
working
on
desktops
as
well
bionic
presents
the
main
hurdle
for
porting
code
to
and
from
android
while
to
some
extent
compatible
with
gnu
libc
the
additions
and
omissions
described
above
do
mean
that
some
more
advanced
features
notably
multithreading
will
not
port
for
some
source
packages
however
all
it
takes
is
recompilation
with
the
ndk
in
this
way
many
tar
ball
packages
can
be
ported
for
android
dv
zhoo
wzhdnlqj
wkh
frqiljxuh
vfulsw
dqg
0dnhiloh
keeping
in
mind
both
android
and
linux
export
the
same
system
calls
it
should
come
as
no
surprise
that
statically
linked
binaries
are
often
fully
compatible
keeping
in
mind
the
same
underlying
cpu
architecture
static
linking
imports
the
specific
dependencies
from
the
various
libraries
into
the
core
of
the
executable
a
noteworthy
example
is
intel's
houdini
discussed
in
volume
ii
which
is
provided
on
x86
64
versions
of
android
a
more
common
example
still
is
busybox
which
is
an
all
in
one
binary
supplying
various
shell
command
functionality
an
arm
compiled
static
binary
of
busybox
taken
from
embedded
linux
is
mostly
compatible
although
minor
aspects
such
as
displaying
android
aids
don't
always
work
well
it's
worth
noting
that
there
are
open
issues
in
bionic
specified
in
bionic
abi
bugs.txt
which
affect
some
esoteric
but
nonetheless
potentially
important
datatypes
such
as
at
the
time
ri
writing
32
bit
time
which
will
blow
up
in
2038
and
32
bit
file
offsets
also
bionic
itself
is
optimized
for
32
bit
and
apple's
move
to
64
bit
will
force
bionic
and
indeed
all
of
android
to
be
ported
to
64
bit
as
is
already
the
case
with
l
and
discussed
later
in
this
chapter
android
internals
a
confectioner's
cookbook
volume
i
http
newandroidbook.com
src
android
system
core
include
private
android_filesystem_config.h
file
users
morpheus
documents
android
book
security.html
uids
file
users
morpheus
documents
android
book
introduction.html
64bit
android
native
libraries
in
addition
to
bionic
android
contains
quite
a
few
other
important
libraries
which
provide
runtime
support
for
dalvik
the
frameworks
and
the
system
processes
those
are
strewn
around
the
source
tree
so
the
following
classifies
them
by
the
directories
they
are
in
core
libraries
the
libraries
in
system
core
mostly
provide
wrappers
over
kernel
androidisms
or
implement
additional
functionality
in
user
mode
and
include
libcutils
provides
convenient
support
functions
for
kernel
exported
data
e.g
proc
cpuinfo
socket
support
and
androidisms
such
as
ashmem
liblog
which
wraps
the
android
dev
log
mechanism
to
provide
a
fast
and
efficient
ring
buffer
based
mechanism
for
logging
libion
wrapping
the
ion
memory
allocator
which
was
introduced
in
ics
libnl_2
which
wraps
the
linux
netlink
socket
mechanism
libpixelflinger
used
primarily
by
the
surfaceflinger
the
core
of
android's
graphics
stack
described
in
volume
ii
flinging
refers
to
the
act
of
composing
two
or
more
inputs
so
that
in
the
case
of
graphics
for
example
the
resulting
pixel
is
a
potentially
alpha
blended
color
combination
of
the
ones
merged
libsuspend
which
abstracts
some
aspects
of
power
management
particulary
those
relating
to
sleep
and
suspension
of
the
operating
system
lesser
libraries
include
libdiskconfig
abstracting
disk
flash
configuration
and
partition
management
libcorkscrew
used
by
the
debuggerd
to
unwind
stacks
and
symbolicate
application
crashes
tombstones
libmemtrack
providing
process
memory
tracing
services
with
the
help
of
hardware
modules
if
any
libmincrypt
providing
basic
implementations
of
rsa
and
sha
1
256
required
for
digital
signature
processing
libnetutils
simplifying
interface
configuration
and
dhcp
support
libsync
which
wraps
the
kernel's
androidism
libsysutils
provides
primitives
used
by
system
utilities
includes
framework
client
listener
command
netlink
event
listener
socket
client
listener
and
servicemanager
libzipfile
providing
wrappers
over
zlib
to
handle
zip
files
android
uses
zip
extensively
with
application
packages
apk
files
being
a
special
case
of
zip
chapter
i
introduction
framework
support
libraries
libraries
in
frameworks
provide
native
support
services
for
the
android
frameworks
despite
not
being
part
of
the
core
they
are
nonetheless
important
and
further
classified
by
subdirectories
the
frameworks
base
core
jni
directory
contains
the
very
important
libandroid_runtime.so
which
provides
the
low
level
jni
support
for
the
dalvik
vm
the
directory
contains
the
jni
components
of
over
85
framework
dalvik
level
classes
the
frameworks
base
services
jni
directory
contains
the
equally
important
libandroid_servers.so
which
provides
the
low
level
jni
support
the
android
services
the
frameworks
base
native
android
directory
contains
libandroid.so
which
provides
a
native
interface
to
assets
storage
manager
and
more
libraries
in
base
libs
include
libandroidfw.so
and
libhwui.so
the
former
provides
miscellaneous
support
services
such
as
zip
file
parsing
and
asset
managements
the
latter
provides
hardware
accelerated
ui
rendering
via
opengl
and
skia
libraries
in
av
handle
media
audio
and
video
these
include
camera
hal
libraries
libcamera_client.so
and
libcamera_metadata.so
q.v
volume
ii
drm
framework
support
libdrmframework.so
supporting
android's
digital
rights
management
mechanism
media
support
libraries
including
libeffects.so
libmedia.so
libnbaio.so
libmediaplayerservice.so
and
libstagefright.so
the
subdirectory
av
services
contains
further
support
libs
for
services
libcameraservice.so
libaudioflinger.so
and
libmedialog.so
libraries
in
native
libs
include
libbinder
binder
support
functions
discussed
in
depth
in
volume
ii
libdiskusage
a
tiny
library
providing
directory
sizing
functions
libgui
provides
gui
abstractions
such
as
the
surface
built
on
top
of
libui.so
libinput
provides
basic
primitives
used
by
android's
input
stack
as
described
in
volume
ii
libui
provides
the
native
apis
for
windows
and
buffers
used
by
surfaceflinger
not
user
events
the
native
subdirectory
also
contains
the
opengl
directory
which
hold
egl
and
opengles
discussed
in
volume
ii
external
native
libraries
android
relies
on
quite
a
few
external
libraries
the
name
refers
to
their
location
in
the
android
source
tree
and
the
fact
that
they
are
not
formally
a
part
of
android
rather
they
are
open
source
projects
which
lend
powerful
capabilities
to
the
operating
system
there
are
well
over
150
such
external
projects
in
the
android
source
tree
so
this
work
does
not
make
an
attempt
to
cover
them
all
table
1
3
nonetheless
attempts
to
touch
on
the
important
ones
providing
library
support
android
internals
a
confectioner's
cookbook
volume
i
chapter
i
introduction
table
1
3
external
library
projects
in
the
android
source
tree
directory
contents
bluetooth
bluedroid
library
libbluedroid.so
which
supports
user
mode
bluetooth
capabilities
icu4c
libicuuc
and
libicui18n
handling
unicode
support
and
internationalization
mdnsresponder
apple's
multicast
dns
bonjour
contains
daemon
mdnsd
and
library
libmdssd.so
libselinux
libsepol
selinux
support
jellybean
and
later
skia
the
skia
2d
graphics
library
discussed
in
volume
ii
sqlite
the
sqlite3
db
support
providing
the
core
for
many
android
databases
svox
libttspico
and
libttscompat
for
svox
pico
text
to
speech
engine
tinyalsa
minimal
version
of
the
linux
advanced
sound
architecture
alsa
library
webkit
the
webkit
browser
core
used
by
controls
zlib
zlib
a
library
providing
compression
support
for
gzip
and
the
like
note
that
once
deployed
on
the
device
external
libraries
are
largely
indistinguishable
from
those
of
the
aosp
since
all
libraries
end
up
alongside
one
another
in
similarly
it
is
possible
your
device
has
additional
vendor
specific
libraries
in
though
by
convention
those
should
be
placed
in
hardware
abstraction
layer
android
is
meant
to
run
on
so
many
types
of
different
devices
tablet
phones
stbs
treadmills
and
what
not
that
the
underlying
hardware
may
greatly
differ
in
its
scope
and
support
in
an
effort
to
combat
this
android
defines
a
hardware
abstraction
layer
hal
which
aims
to
promote
standardization
by
defining
an
adapter
hardware
vendors
are
free
to
implement
their
own
drivers
in
kernel
mode
but
must
supply
a
shim
to
conform
to
the
interface
android
and
particularly
dalvik
expects
the
hardware
abstraction
layer
defines
what
an
abstract
camera
gps
sensor
and
other
components
look
like
to
android
this
does
not
preclude
vendors
from
extending
or
modifying
functions
it
only
requires
the
vendor
to
drop
the
shim
into
system
lib
hw
and
the
hal
libhardware.so
will
automatically
load
them
output
1
4
shows
the
hal
libraries
used
in
the
s5
output
1
4
hardware
abstraction
layer
libraries
in
the
galaxy
s5
the
hardware
abstraction
layer
is
naturally
a
very
important
aspect
of
android
both
because
it
represents
a
divergence
from
linux
and
because
it
is
instrumental
in
supporting
the
slew
of
android
devices
it
is
thus
deserving
of
its
own
chapter
in
olume
ii
file
users
morpheus
documents
android
book
devices.html
the
linux
kernel
the
linux
kernel
due
to
its
open
source
and
free
license
nature
provides
an
excellent
substrate
for
android
now
parsecs
away
from
linus
torvalds
initial
version
the
kernel
keeps
evolving
at
remarkable
speeds
with
new
features
added
every
weeks
or
months
android's
own
capabilities
are
significantly
affected
by
the
kernel's
with
notable
examples
being
compressed
ram
and
64
bit
support
the
latter
helps
explain
table
1
1
which
pits
kernel
version
3.10
as
the
minimum
version
for
lollipop
the
kernel
officially
supports
arm64
aarch64
as
of
3.7
android
kernels
are
compiled
slightly
differently
than
those
of
linux
with
the
config
files
being
generated
by
merging
android's
base
and
recommended
configuration
templates
with
those
of
the
default
kernel
distribution
as
shown
in
the
source.android.com
website's
kernel
section
16
as
previously
mentioned
android
introduces
its
own
idiosyncrasies
or
androidisms
into
the
kernel
a
few
of
these
are
in
the
kernel
core
guarded
by
statements
for
conditional
compilation
with
the
rest
being
in
drivers
staging
android
directory
these
androidisms
as
of
3.10
and
later
include
anonymous
shared
memory
ashmem
a
mechanism
to
allow
shared
memory
applications
can
open
a
character
device
dev
ashmem
and
create
a
memory
region
which
can
then
be
mapped
into
memory
this
is
requireg
to
work
around
the
restriction
of
no
world
writable
directories
and
system
v
ipc
binder
the
crux
of
all
ipc
in
android
a
legacy
of
beos
binder
presents
a
character
device
dev
binder
which
all
applications
can
open
android
services
register
with
binder
and
clients
can
connect
to
them
with
the
help
of
binder
provides
efficient
advanced
ipc
as
discussed
in
chapter
6
and
explained
in
depth
in
volume
ii
logger
providing
kernel
based
ring
buffers
for
fast
file
less
logging
android
logs
are
maintained
by
character
devices
in
dev
log
android
l
augments
this
with
a
user
mode
daemon
discussed
in
chapter
5
the
ion
memory
allocator
introduced
in
ics
and
offers
efficient
memory
allocation
to
kernel
drivers
and
user
mode
alike
through
dev
ion
ion
replaces
an
older
androidism
pmem
and
aims
to
standardize
memory
management
in
the
various
soc
architectures
low
memory
killer
a
layer
on
top
of
linux's
own
out
of
memory
oom
killer
which
terminates
processes
in
case
of
memory
exhaustion
while
the
latter
is
heuristic
driven
the
former
provides
a
more
deterministic
way
of
controlling
process
termination
and
allows
defining
memory
pressure
levels
android
l
augments
this
with
a
user
mode
daemon
discussed
in
chapter
5
ram
console
a
mechanism
for
preserving
kernel
panic
output
thread
dump
and
last
log
this
has
been
deprecated
in
newer
releases
in
favor
of
the
linux
kernel's
own
described
in
chapter
2
sync
driver
the
latest
androidism
introduced
to
allow
fast
synchronization
primitives
used
primarily
by
android's
graphics
stack
in
particular
timed
output
and
gpio
allowing
user
mode
programs
to
access
gpio
registers
from
user
space
and
automatically
reset
their
values
after
a
timeout
the
main
client
of
this
is
the
device
vibrator
functionality
the
framework
via
the
hal
can
write
a
millisecond
value
into
sys
classtimed_output
vibrator
enable
to
start
the
device
vibration
which
automatically
quiets
down
after
the
timeout
specified
wakelocks
originally
a
separate
androidism
to
control
power
management
and
prohibit
the
kernel's
sleep
functionality
wakelocks
have
gradually
been
merged
with
the
kernel's
own
wakeup
source
mechanisms
power
management
is
detailed
in
volume
ii
with
a
relevant
excerpt
on
the
book's
companion
website
the
kernel
in
fact
provides
a
substrate
for
myriad
linux
offshoots
including
samsung's
tizen
jolia's
sailfish
firefox
os
and
ubuntu
on
smartphones
all
of
these
are
seen
as
potential
competitors
to
android
though
their
market
share
at
least
as
of
early
2015
is
infinitessimal
android
internals
a
confectioner's
cookbook
volume
i
https
source.android.com
devices
tech
kernel.html
file
users
morpheus
documents
android
book
systemserver.html
binder
file
users
morpheus
documents
android
book
services.html
logd
file
users
morpheus
documents
android
book
services.html
lmkd
file
users
morpheus
documents
android
book
filesystems.html
pstore
figure
1
4
android
wear
launcher
ui
android
derivatives
google
offshoots
google
has
made
it
clear
that
it
wants
to
make
android
ubiquitous
in
all
kinds
of
devices
not
just
phones
and
tablets
true
to
their
vision
they
announced
three
new
offshoots
of
android
android
wear
with
rumors
of
apple
supposedly
working
on
an
iwatch
it's
no
surprise
google
quickly
rushed
to
announce
android
wear
back
around
kitkat
android
wear
is
a
version
of
android
optimized
for
wearable
devices
which
at
the
time
of
writing
are
a
single
category
domain
watches
though
could
ostensibly
be
extended
to
other
wearable
devices
at
the
core
android
wear
is
the
same
android
used
in
phones
and
tablets
but
the
home
activity
main
screen
has
been
replaced
by
a
simpler
interface
owing
to
a
watch's
diminutive
display
this
includes
an
emphasis
on
voice
commands
by
tapping
on
the
google
icon
notifications
and
cue
cards
some
wear
devices
also
support
round
screens
as
well
android
wear
identified
by
clockwork
in
the
ur
exlog
ilqjhusulqw
surshuw
can
be
thought
of
as
a
slimmed
down
version
of
android
unnecessary
frameworks
and
services
have
been
removed
both
to
conserve
memory
as
well
as
cpu
battery
life
being
a
major
limiting
factor
of
wearable
devices
a
comparison
between
the
phone
and
wear
flavor
of
kitkat
reveals
that
all
telephony
services
phone
iphonesubinfo
simponebook
isms
as
well
as
print
appwidget
backup
usb
wallpaper
device_policy
and
the
drmmanager
have
been
removed
in
wear
applications
have
likewise
been
slashed
from
over
180mb
in
about
60
packages
to
a
mere
12mb
in
only
16
packages
leaving
only
watch
specific
applications
orfnzrun6hwxs
dsn
orfnzrun6hwwlqjv
dsn
dqg
wkh
3uhexlow
orfnzrun
rph
dsn
launcher
or
those
that
can
operate
on
a
small
screen
in
other
words
the
default
sdfndjhv
ri
from
kk
are
not
present
or
loaded
in
wear
the
sdk
for
wear
has
been
released
with
documentation
available
in
the
android
developer
website17
android
wear
devices
are
at
present
designed
to
serve
as
satellites
for
more
capable
devices
such
as
a
smartphone
or
tablet
their
only
connectivity
is
via
bluetooth
and
most
of
their
frameworks
are
stubs
which
connect
to
the
full
featured
ones
on
a
phone
samsung
an
early
adopter
for
its
galaxy
gear
watch
is
migrating
away
from
wear
in
favor
of
its
homegrown
tizen
citing
issues
with
battery
life
and
limited
functionality
as
being
the
key
drivers
android
auto
shortly
after
apple
announced
carplay
integrating
ios
7
with
cars
google
happened
to
announce
android
auto
which
aims
to
do
surprisingly
similar
things
provide
a
convenient
interface
to
use
mobile
devices
in
cars
with
access
to
useful
apps
such
as
navigation
the
music
player
and
of
course
the
phone
as
with
android
wear
there's
an
emphasis
on
voice
commands
and
notifications
this
time
not
because
of
screen
limitations
so
much
as
the
requirement
for
hands
free
operation
figure
1
5
android
auto
ui
source
google
chapter
i
introduction
http
developer.android.com
training
building
wearables.html
from
the
developer
perspective
the
important
difference
is
that
there
is
no
need
for
a
separate
car
specific
ui
in
fact
there's
no
need
for
any
ui
in
android
auto
because
the
built
in
system
ui
communicates
with
specific
aspects
of
app
functionality
and
presents
them
as
the
drawers
which
are
list
driven
menus
this
enables
the
driver
to
select
functions
with
the
navigation
buttons
found
on
most
steering
wheels
apps
can
still
customize
the
built
in
ui
by
specifying
icons
and
background
images
but
don't
need
to
display
any
custom
ui
views
as
they
would
normally
hyhorshuv
qhhg
to
declare
an
additional
xml
file
with
an
element
and
specify
which
features
they
use
with
media
and
notification
presently
being
the
supported
features
the
xml
file
is
connected
to
the
app
via
a
element
in
the
app's
specifying
the
reserved
value
for
the
name
attribute
google
has
detailed
the
interface
changes
such
as
the
launcher
and
the
drawer
based
ui
at
the
android
auto
website
android
tv
tv
makers
have
long
been
using
proprietary
oses
to
run
their
device
samsung's
tizen
and
lg's
webos
formerly
palm
hp's
being
the
two
most
prominent
examples
google
wishes
to
extend
android's
hegemony
into
this
space
as
well
gaining
the
fringe
benefits
in
the
trove
of
user
viewing
habits
this
is
google's
second
attempt
at
entering
television
with
their
google
tv
being
less
of
a
niche
product
than
apple
tv
is
android
tv
has
been
announced
and
released
alongside
android
l
with
ample
documentation
on
the
android
tv
website19
from
the
emulator
images
one
can
discern
the
main
difference
is
in
the
launcher
in
system
app
leanbacklauncher.apk
the
built
in
tv
app
in
system
priv
app
tv.apk
and
the
tv
content
provider
in
system
priv
app
tvprovider.apk
the
content
provider
exports
uris
in
android.media.tv
for
the
remote
control
and
the
latter
three
are
stored
in
the
provider
database
data
user
0
com.android.providers.tv
databases
other
features
have
also
been
adapted
for
tvs
notably
remote
control
based
navigation
and
huge
screen
sizes
android
tv
will
likely
evolve
considerably
in
the
future
perhaps
evolving
to
compete
with
apple's
plans
for
extending
apple
tv
and
ios
future
enhancements
would
likely
involve
better
streaming
support
enhanced
epg
electronic
programming
guide
functionality
integration
with
chromecast
and
gaming
platform
support
but
there
is
another
foe
to
consider
in
the
tv
space
amazon
non
google
ports
because
of
its
open
nature
vendors
are
free
to
customize
android
in
oh
so
many
ways
most
enhance
or
detract
from
the
standard
ui
in
an
effort
to
differentiate
their
device
from
yet
another
android
notable
examples
include
htc
and
samsung
with
their
sense
and
touchwiz
uis
repectively
others
pack
android
into
new
types
of
devices
for
example
nvidia
with
their
shield
console
in
all
the
above
cases
however
the
base
system
is
still
very
much
the
same
android
further
google
provides
the
compatibility
test
suite
cts
subtree
of
aosp
which
vendors
must
pass
in
order
to
get
the
official
blessing
and
be
assured
that
apps
will
function
correctly
additionally
google
makes
the
play
market
inseparable
from
its
other
services
as
an
price
to
enter
the
ecosystem
vendors
must
bundle
the
entire
set
of
google
utilities
maps
mail
etc
making
it
more
likely
the
device
will
be
tied
to
a
google
account
and
thus
an
identity
other
vendors
however
only
take
android
as
a
substrate
and
make
vast
modifications
they
willingly
give
up
the
ecosystem
because
they
often
create
their
own
one
such
example
is
chinese
smartphone
maker
xiaomi
whose
top
of
the
line
devices
at
rock
bottom
prices
has
propelled
it
to
be
one
of
china's
and
possibly
the
world's
largest
xiaomi
built
an
entire
business
by
investing
in
its
own
ecosystem
and
has
willingly
abandoned
google's
services
most
of
which
are
blocked
in
china
anyway
one
can
imagine
google
can't
be
too
happy
with
it
missing
out
on
order
of
100
million
or
more
users
but
this
is
just
a
consequence
of
android's
open
source
nature
and
it
could
be
worse
nokia
for
example
experimented
with
versions
of
android
that
have
been
converted
to
microsoft's
cloud
services
and
on
this
side
of
the
ocean
there's
amazon
android
internals
a
confectioner's
cookbook
volume
i
http
developer.android.com
training
auto
index.html
http
developer.android.com
training
tv
index.html
fireos
amazon
is
one
of
the
vendors
that
has
no
doubt
benefitted
the
most
from
android
the
giant
retailer
made
its
foray
into
the
tablet
market
with
its
kindle
line
which
was
based
on
a
proprietary
embedded
linux
distribution
and
an
e
ink
display
with
the
kindle
fire
amazon
modernized
their
tablet
using
android
as
the
core
operating
system
much
to
google's
chagrin
however
amazon
fully
customized
their
version
of
android
and
rebranded
it
as
fireos
the
interface
was
entirely
revamped
sporting
a
carousel
like
selection
of
apps
the
devices
are
locked
and
keyed
to
amazon
only
effectively
useless
without
an
amazon
id
and
any
trace
of
google
search
play
store
accounts
or
otherwise
has
been
eradicated
from
a
technical
perspective
fireos's
core
is
still
very
much
android
changes
in
it
however
are
quite
radical
and
include
removal
of
all
things
google
and
replacement
with
amazon
specifically
carousel
as
the
home
activity
the
familiar
android
launcher
has
been
replaced
by
amazon's
custom
launcher
com.amazon.kindle.otter
default
browser
is
silk
or
by
its
other
name
com.amazon.cloud9
this
is
a
webkit
based
browser
heavily
modified
and
optimized
to
use
amazon's
elastic
compute
cloud
ec2
to
optimize
web
browsing
google
play
replaced
by
amazon
app
store
internally
referred
to
as
com.amazon.windowshop
and
com.amazon.venezia
amazon
offers
as
screen
saver
utilizing
android's
dreams
functionality
to
install
a
screen
saver
filled
with
ads
internally
this
is
done
by
several
components
in
the
com.amazon.dcp
package
and
ads
stored
in
data
securedstoragelocation
dtcp
incidentally
revoking
permissions
on
this
folder
effectively
disables
ads
aggressive
ota
updates
the
com.amazon.dcp
package
contains
a
host
of
services
meant
to
ensure
the
device
is
constantly
up
to
date
unlike
other
android
versions
fireos
doesn't
ask
to
update
it
just
goes
ahead
and
does
so
automatic
updates
are
explained
in
chapter
3
amazon
has
taken
several
pages
from
apple's
playbook
most
notably
locking
down
the
system
to
resist
rooting
or
at
least
try
as
well
as
prevent
downgrading
of
the
operating
system
once
an
update
has
been
installed
which
it
often
is
automatically
with
fireos
as
a
whole
amazon
steps
further
away
from
the
google
vision
of
android
launching
its
own
fire
phone
and
its
fire
tv
each
with
proprietary
interfaces
and
apis
headless
android
take
android
and
remove
dalvik
and
its
accompanying
frameworks
and
you
are
left
with
a
operating
system
that
has
no
gui
support
nor
any
use
for
an
ecosystem
such
an
os
however
is
still
valuable
in
its
own
right
as
a
base
embedded
linux
distribution
which
has
already
been
adapted
to
work
with
arm
and
mips
processors
before
the
advent
of
android
embedded
linux
was
a
complicated
and
highly
difficult
environment
owing
in
large
part
to
the
complexity
of
building
the
cross
compiler
toolchain
and
the
user
mode
libraries
companies
which
provided
this
toolchain
and
environment
along
with
support
were
highly
sought
after
android
however
completely
disrupted
the
realm
turning
the
tables
on
the
major
embedded
linux
players
rather
than
acquire
a
license
for
tens
of
thousand
of
dollars
embedded
linux
now
became
entirely
free
by
simply
downloading
the
android
sources
and
ndk
anyone
can
build
and
customize
the
system
to
their
own
needs
android
in
its
headless
deployment
now
forms
the
basis
for
many
systems
which
don't
need
gui
sensors
appliances
and
others
and
is
likely
to
be
a
major
player
in
the
internet
of
things
revolution
which
promises
to
embed
arm
and
mips
and
maybe
intel
processors
in
everything
but
the
kitchen
sink
it's
possible
in
android
to
enjoy
the
best
of
both
worlds
that
is
both
the
rich
frameworks
and
a
system
with
no
ui
the
system
can
be
made
to
operate
with
no
ui
by
setting
the
system
property
this
allows
developers
to
use
the
frameworks
for
various
non
ui
related
tasks
such
as
interfacing
with
sensors
as
well
as
benefit
from
the
object
orientation
and
other
advanced
aspects
of
the
dalvik
and
art
environments
chapter
i
introduction
file
users
morpheus
documents
android
book
boot.html
ota
pondering
the
way
ahead
prophecy
is
the
gift
of
fools
but
it's
interesting
to
contemplate
the
next
direction
to
be
taken
by
android
the
war
between
ios
and
android
rages
on
with
android
quickly
adopting
and
by
some
claims
blatantly
copying
features
from
ios
and
in
some
cases
vice
versa
still
it
seems
rather
clear
from
the
present
landscape
as
to
some
features
will
very
likely
be
included
in
the
next
android
macaroon
meringue
or
whatever
condiment
name
google
will
choose
for
it
64
bit
compatibility
with
the
introduction
of
the
iphone
5s
apple
caught
the
entire
mobile
industry
by
surprise
with
the
first
64
bit
mobile
architecture
this
perplexed
many
which
were
quick
to
dismiss
it
as
useless
marketing
64
bit
support
was
initially
discounted
because
its
chief
advantage
address
spaces
larger
than
4gb
is
in
fact
questionable
in
a
mobile
environment
though
some
tablets
already
ship
with
ram
of
2gb
4gb
are
still
beyond
the
needs
of
most
devices
64
bit
memory
access
is
also
slightly
less
efficient
than
32
bit
involving
more
page
table
lookups
so
many
were
quick
to
mock
apple
for
such
a
feeble
attempt
at
innovating
and
a
useless
gimmick
in
practice
however
there's
more
to
64
bit
than
meets
the
eye
though
arm
64
bit
processors
still
support
32
bit
code
the
native
64
bit
armv8
instruction
set
has
been
completely
rewritten
to
be
more
efficient
add
to
that
the
width
of
64
bit
registers
and
the
larger
register
set
and
the
advantage
quickly
becomes
apparent
the
64
bit
architecture
along
with
some
remarkable
designs
in
apple's
custom
a7
chip
blew
past
the
performance
of
all
other
mobile
processors
while
maintaining
an
impresively
low
power
footprint
in
fact
this
proved
that
the
boasting
quad
and
octo
cores
was
the
useless
gimmick
as
apple's
flagship
processor
was
still
a
dual
core
further
adding
more
cores
directly
impacts
power
performance
so
most
cores
are
actually
powered
off
the
overwhelming
majority
of
a
device's
life
time
the
move
a
vertical
rather
than
a
horizontal
expansion
thus
proved
to
be
a
brilliant
one
and
an
especially
efficacious
stratagem
though
requiring
virtually
no
work
in
ios
other
than
a
recompilation
of
the
app
porting
android
to
64
bit
is
a
lengthy
process
android's
core
components
notably
dalvik
and
bionic
are
32
bit
optimized
and
therefore
need
to
be
completely
rewritten
of
all
vendors
intel
has
been
quickest
to
jump
on
the
64
bit
wagon
since
its
mobile
processors
are
already
fully
64
bit
native
the
various
arm
vendors
however
need
to
adapt
to
the
move
though
samsung
was
quick
to
announce
their
next
big
thing
will
naturally
be
64
bit
htc's
nexus
9
zdv
dprqj
wkh
iluvw
64
bit
arm
processorv
nvidia's
tegra
k1
and
qualcomm
vrrq
followhg
with
the
snapdragon
810
7
2qh
0
dqg
6dpvxqj
zlwk
wkhlu
qrv
lq
wkh
6
qemu
which
powers
the
android
emulator
kdv
finally
been
updated
to
support
arm64
emulation
with
the
m
preview
release
1
sdk
android
runtime
art
android
still
proves
inferior
to
ios
in
several
aspects
not
the
least
of
which
is
power
management
this
can
be
traced
back
to
its
linux
foundations
which
are
geared
towards
an
immobile
desktop
or
server
where
power
is
rarely
a
concern
but
also
due
to
its
many
layers
while
layers
provide
for
elegant
abstrations
portability
and
other
aspects
of
fine
design
they
are
often
dismal
in
terms
of
performance
and
power
management
as
they
require
more
processing
the
main
layer
in
android
dalvik
involves
significant
processing
and
even
its
many
enhancements
e.g
jit
compilation
still
require
much
more
work
than
native
code
would
by
comparison
ios's
runtime
and
frameworks
are
implemented
in
objective
c
which
is
an
extension
of
standard
c
and
still
very
much
native
one
of
the
strongest
rebukes
of
this
move
was
made
by
none
other
than
qualcomm's
senior
vp
and
cmo
who
claimed
they
are
doing
a
marketing
gimmick
there's
zero
benefit
a
consumer
gets
from
that
a
week
later
qualcomm
retracted
his
comment
and
he
was
shortly
after
reassigned
20
in
ios
8
apple
has
made
the
first
moves
to
break
away
from
objective
c
with
the
introduction
of
swift
a
featureful
yet
lightweight
programming
language
which
boasts
impressive
runtime
performance
when
compiled
but
also
when
interpreted
android
internals
a
confectioner's
cookbook
volume
i
http
www.cnet.com
news
after
apple
64
bit
a7
criticism
qualcomm
exec
reassigned
the
android
runtime
art
provides
an
alternative
silently
introduced
in
kitkat
and
dubbed
experimental
art
aims
to
use
ahead
of
time
aot
compilation
to
llvm
and
even
native
code
thus
bring
it
on
par
with
ios
performance
art
presently
offers
only
small
advantages
in
power
and
performance
over
dalvik
on
order
of
10
20
and
in
some
tests
also
falls
behind
it
nonetheless
as
of
lollipop
art
is
the
chosen
runtime
and
is
vital
in
order
for
android
to
provide
64
bit
support
as
alluded
to
earlier
in
this
chapter
however
dalvik
is
far
from
dead
applications
will
still
be
packaged
with
dalvik
bytecode
classes.dex
with
art
taking
over
and
compiling
to
native
code
only
when
deployed
on
the
device
replacing
the
on
device
optimization
stage
usually
carried
out
by
gh
rsw
rwk
doyln
dqg
57
duh
glvfxvvhg
lq
ghswk
lq
9roxph
split
screen
android
already
has
the
necessary
foundations
to
allow
different
activities
to
run
in
parallel
to
one
another
on
a
split
screen
samsung
has
extended
the
gui
for
this
capability
which
is
also
supported
in
windows
8
and
with
rumors
abuzz
for
this
feature
to
be
added
to
the
ipad
in
ios
8.1
it
makes
sense
to
see
it
mainstream
on
android
this
is
a
purely
framework
level
feature
since
from
the
native
perspective
there's
no
real
change
the
activities
as
processes
run
concurrently
anyway
this
could
be
a
major
step
on
the
road
to
making
android
a
full
desktop
os
replacement
as
well
android
as
a
desktop
os
with
so
many
tablets
vying
to
become
a
desktop
replacement
why
not
make
android
a
desktop
os
microsoft
introduced
windows
8
which
took
desktop
windows
and
improved
it
to
support
mobile
devices
tablets
and
phones
android
would
need
to
make
the
reverse
transition
bringing
its
mobile
support
to
desktops
which
could
then
run
android
apps
doing
so
is
not
necessarily
that
hard
as
we
discuss
in
volume
ii
dalvik's
open
source
nature
makes
it
quite
portable
and
implementations
for
other
oses
naturally
linux
but
also
windows
os
x
and
even
ios
exist
none
of
those
are
sponsored
nor
supported
by
google
but
with
ios
and
os
x
edging
closer
and
closer
still
to
one
another
some
have
postulated
that
os
x
will
soon
run
ios
apps
some
have
even
go
so
far
as
to
suggest
apple
will
make
the
transition
to
arm
on
its
macs
if
that
were
the
case
the
binding
between
the
ecosystems
would
become
a
strong
differentiator
in
ios's
favor
which
google
will
surely
not
ignore
for
long
there
are
a
few
obstacles
however
for
one
it's
not
trivial
to
support
full
desktop
applications
the
linux
openoffice
and
most
other
apps
are
already
built
on
top
of
x
windows
and
gnome
or
kde
and
thus
would
have
to
be
adapted
to
android
in
addition
android
would
have
to
be
extended
to
support
mice
though
arguably
its
inputmanager
already
supports
cursor
devices
and
multiple
windows
again
technically
supported
to
an
extent
by
the
windowmanager
last
but
not
least
is
chromeos
which
google
is
developing
as
its
answer
to
windows
in
the
hopes
of
ousting
the
latter
the
same
way
chrome
usurped
the
lead
to
become
the
world's
most
popular
browser
android
and
project
ara
ara21
is
the
code
name
for
a
project
developed
by
google
with
the
goal
of
producing
a
fully
modular
smartphone
the
idea
is
to
make
all
system
components
swappable
the
cpu
display
storage
are
all
replaceable
much
in
the
same
way
in
the
pc
world
it's
a
farily
simple
matter
to
install
a
new
hard
drive
or
graphics
adapter
ara
is
a
vestige
of
google's
motorola
mobility
acquisition
since
sold
off
to
lenovo
developered
by
the
former's
advanced
technology
and
projects
atap
division
which
was
retained
by
google
it's
important
to
note
that
dalvik
code
is
still
32
bit
rather
than
64
bit
optimized
while
dalvik
does
support
wide
data
types
most
operations
are
32
bit
this
means
that
while
compiling
to
native
code
does
offer
some
benefits
of
the
64
bit
architecture
the
code
is
still
not
as
efficient
as
pure
64
bit
chapter
i
introduction
http
www.projectara.com
figure
1
6
modular
smartphones
from
the
motorola
blog
ara
makes
the
device
in
effect
a
chassis
more
accurately
an
endo
skeleton
and
components
are
separate
modules
not
unlike
a
pc
electro
permanent
magnets
that
can
be
turned
on
off
electronically
but
do
not
require
power
for
everyday
use
hold
modules
in
place
in
theory
all
components
save
for
the
cpu
and
possibly
the
display
are
hot
swappable
i.e
they
can
be
replaced
while
the
device
is
working
coupled
with
3d
printing
this
could
lead
to
printable
phone
designs
which
could
be
downloaded
and
an
array
of
upgradeable
modules
which
would
render
the
annual
full
upgrades
of
mobile
devices
extinct
as
ara
is
developed
by
google
it's
only
natural
that
android
be
the
os
of
choice
for
it
supporting
ara
however
will
require
heavy
modifications
in
android
at
the
framework
level
but
even
more
so
at
the
underlying
linux
layers
all
the
way
down
to
the
kernel
google
has
partnered
with
linaro
for
these
purposes
and
is
investing
ridiculous
sums
of
money
at
developing
both
the
software
and
hardware
necessary
to
standardize
all
the
modules
ara
is
still
in
its
infancy
as
this
book
goes
to
print
with
an
estimated
release
initially
in
puerto
rico
later
in
2015
if
successful
however
a
truly
modular
mobile
device
would
amount
to
nothing
less
than
a
second
coming
of
the
mobile
revolution
and
this
time
google
wants
to
be
there
first
summary
this
chapter
explored
the
evolution
of
the
android
architecture
to
the
present
day
kitkat
with
an
emphasis
on
its
low
level
features
it
compared
and
constrasted
the
android
architecture
with
that
of
its
parent
linux
to
show
the
two
are
in
many
cases
not
at
all
that
far
apart
though
at
present
not
interchangeable
next
the
many
derivatives
of
android
were
introduced
and
though
of
different
skins
and
appearance
they
all
at
their
core
function
as
android
does
so
you
should
find
this
work
applicable
to
them
just
the
same
the
chapter
concluded
with
pondering
future
directions
for
android
l
and
beyond
and
the
features
it
is
likely
or
not
to
support
the
next
chapters
explore
the
various
aspects
of
android
each
in
as
much
detail
as
possible
we
begin
with
the
android
filesystem
naturally
based
on
that
of
linux
but
using
defined
partitions
and
filesystems
some
more
clearly
defined
than
others
android
internals
a
confectioner's
cookbook
volume
i
http
motorola
blog.blogspot.com
2013
10
goodbye
sticky
hello
ara.html
references
1
android
version
history
wikipedia
http
en.wikipedia.org
wiki
android_version_history
2
android
dashboards
usage
statistics
http
developer.android.com
about
dashboards
index.html
3
froyo
feature
summary
developer.android.com
about
versions
android
2.2
highlights.html
4
gingerbread
feature
summary
developer.android.com
about
versions
android
2.3
highlights.html
5
honeycomb
feature
summary
developer.android.com
about
versions
android
3.0
highlights.html
6
smp
primer
for
android
http
developer.android.com
training
articles
smp.html
7
ice
cream
sandwich
feature
summary
developer.android.com
about
versions
android
4.0
highlights.html
8
jellybean
feature
summary
developer.android.com
about
versions
jelly
bean.html
9
kitkat
feature
summary
developer.android.com
about
versions
kitkat.htmlkitkat
feature
summary
10
lollipop
feature
summary
developer.android.com
about
versions
lollipop.html
11
android
version
numbering
convention
https
source.android.com
source
build
numbers.html
platform
code
names
versions
api
levels
and
ndk
releases
12
a
much
better
android
architecural
diagram
http
source.android.com
images
android_framework_details.png
13
dan
bornstein
presenting
dalvik
google
i
o
2008
https
www.youtube.com
watch
v
ptjedozexpm
14
android
ndk
http
developer.android.com
tools
sdk
ndk
index.html
15
google
groups
bionic
discussion
http
android
platform.googlegroups.com
attach
0f8eba5ecb95c6f4
overview.txt
view
1
part
4
16
android
kernel
configuration
https
source.android.com
devices
tech
kernel.html
17
android
wear
developer
website
http
developer.android.com
training
building
wearables.html
18
android
auto
developer
website
http
developer.android.com
training
auto
index.html
19
android
tv
developer
website
http
developer.android.com
training
tv
index.html
20
qualcomm
reassigns
exec
after
64
bit
criticism
http
www.cnet.com
news
after
apple
64
bit
a7
criticism
qualcomm
exec
reassigned
21
project
ara
official
website
http
www.projectara.com
chapter
i
introduction
http
en.wikipedia.org
wiki
android_version_history
http
developer.android.com
about
dashboards
index.html
http
developer.android.com
about
versions
android
2.2
highlights.html
http
developer.android.com
about
versions
android
2.3
highlights.html
http
developer.android.com
about
versions
android
3.0
highlights.html
http
developer.android.com
training
articles
smp.html
http
developer.android.com
about
versions
android
4.0
highlights.html
http
developer.android.com
about
versions
jelly
bean.html
http
developer.android.com
about
versions
kitkat.html
http
developer.android.com
about
versions
lollipop.html
https
source.android.com
source
build
numbers.html
platform
code
names
versions
api
levels
and
ndk
releases
http
source.android.com
images
android_framework_details.png
https
www.youtube.com
watch
v
ptjedozexpm
http
developer.android.com
tools
sdk
ndk
index.html
http
developer.android.com
tools
sdk
ndk
index.html
http
android
platform.googlegroups.com
attach
0f8eba5ecb95c6f4
overview.txt
view
1
part
4
https
source.android.com
devices
tech
kernel.html
http
developer.android.com
training
building
wearables.html
http
developer.android.com
training
auto
index.html
http
developer.android.com
training
tv
index.html
http
www.cnet.com
news
after
apple
64
bit
a7
criticism
qualcomm
exec
reassigned
http
www.projectara.com
android
internals
a
confectioner's
cookbook
volume
i
ii
android
partitions
and
filesystems
this
chapter
begins
with
a
discussion
of
the
substrate
for
filesystems
the
partitions
themselves
the
device's
storage
is
broken
up
into
disjoint
chunks
each
of
them
individually
formatted
and
purposed
we
discuss
how
you
can
analyze
the
partition
layout
and
investigate
many
of
the
partitions
which
are
otherwise
reserved
and
inaccessible
we
then
turn
our
attention
to
the
android
filesystems
which
the
system
does
regularly
use
system
where
the
os
itself
is
installed
data
where
user
data
is
stored
and
others
the
directory
structure
of
these
filesystems
is
discussed
with
important
files
and
folders
pointed
out
finally
we
consider
the
linux
pseudo
filesystems
which
although
not
a
part
of
android
per
se
but
of
the
linux
kernel
nonetheless
serve
important
functions
during
system
operation
primarily
for
diagnostics
and
hardware
access
partitioning
scheme
android
users
are
often
surprised
to
find
that
their
device
stated
as
coming
with
x
gb
of
flash
in
practice
has
less
than
the
advertised
space
power
users
who
go
into
adb
and
type
df
to
add
the
numbers
find
that
not
only
does
the
android
os
take
up
a
sizeable
chunk
the
amounts
reported
under
used
and
free
simply
don't
add
up
to
the
stated
device
capacity
some
of
the
difference
can
be
explained
by
the
fine
print
which
usually
states
that
the
definition
of
gb
is
a
loose
one
rather
than
follow
the
210
convention
wherein
1kb
1024
bytes
1mb
1024kb
and
1gb
1024mb
on
device
use
chmod
as
root
to
allow
adb
to
read
drive
sectorswhich
would
define
1
gb
to
be
1,073,741,824
bytes
marketing
pits
1gb
at
1,000,000,000
bytes
already
a
noticeable
7
evaporated
by
false
advertising
but
the
difference
still
leaves
tens
and
sometimes
hundreds
of
mb
or
more
unaccounted
for
the
missing
megabytes
stem
from
the
device
partitioning
most
of
the
flash
is
used
for
android
but
some
space
is
left
for
other
purposes
android
flash
storage
is
often
partitioned
into
dozens
of
partitions
of
which
android
uses
about
5
it's
not
uncommon
to
see
25
or
more
partitions
on
some
devices
such
as
the
kindle
fire
or
the
nexus
5
or
even
70
in
the
case
of
the
htc
one
m9
of
those
the
user
can
only
write
to
one
partition
data
and
no
other
in
fact
most
are
not
even
mounted
during
regular
use
this
section
discusses
the
partitioning
scheme
used
and
how
you
can
use
tools
to
uncover
those
otherwise
hidden
partitions
which
often
may
contain
interesting
content
the
exact
partitioning
scheme
of
android
may
vary
significantly
in
between
vendors
and
even
individual
devices
for
the
most
part
however
the
partitions
use
the
same
semantics
those
size
and
number
will
surely
vary
most
of
the
examples
in
this
chapter
are
from
qualcomm
chipset
msm
devices
which
make
up
the
vast
majority
of
android
devices
anyway
the
need
for
separate
partitions
most
desktop
users
especially
in
the
windows
world
are
probably
used
to
having
one
or
in
some
cases
two
partitions
the
classic
desktop
view
has
always
been
that
fewer
partitions
suffice
a
view
no
doubt
linked
to
the
legacy
mbr
partitioning
scheme
which
by
design
allowed
only
four
partitions
in
unix
however
using
multiple
partitions
has
been
much
more
of
a
norm
as
it
allows
for
greater
flexibility
during
system
upgrades
and
other
administrative
operations
multiple
partitions
do
have
one
notable
disadvantage
which
is
imposing
artificial
limitations
on
available
space
as
it
is
subdivided
by
partitioning
un
x
administrators
have
always
found
clever
ways
around
that
however
by
using
symbolic
links
or
when
more
space
is
needed
adding
new
disk
space
and
redirecting
to
it
by
means
of
mounting
in
the
mobile
domain
using
multiple
partitions
makes
sense
as
well
albeit
for
somewhat
different
reasons
one
of
the
chief
concerns
of
mobile
devices
is
that
they
must
always
be
repairable
and
so
some
type
of
recovery
mode
must
be
enabled
on
them
to
allow
for
system
recovery
or
upgrades
there
must
be
some
way
to
boot
the
system
from
a
known
safe
copy
of
an
operating
system
in
fact
it
is
not
uncommon
on
some
devices
to
find
multiple
copies
of
the
boot
loader
components
identical
copies
to
ensure
bootability
just
in
case
additionally
some
components
such
as
the
modem
or
other
firmware
components
and
the
bootloader
itself
need
their
own
storage
space
for
storing
configuration
files
or
images
note
that
not
all
partitions
are
actually
mounted
by
android
in
fact
only
a
scant
few
often
are
with
the
remainder
either
meant
for
use
during
recovery
or
exclusively
by
system
components
the
latter
are
also
unmountable
by
definition
because
they
often
contain
proprietary
formatting
which
the
linux
kernel
does
not
recognize
the
guid
partition
table
taking
all
the
above
considerations
into
account
the
need
for
multiple
partitions
becomes
clear
as
does
the
realization
that
quite
a
few
of
them
would
be
necessary
the
mbr
partition
scheme
is
therefore
ruled
out
leaving
the
guid
partition
table
gpt
as
the
viable
option
mbr
is
still
technically
used
in
the
sense
that
the
first
sector
of
the
device
often
contains
a
dummy
mbr
record
with
one
partition
spanning
the
entire
drive
the
second
sector
contains
the
gpt
header
which
in
turn
maps
out
all
the
partitions
this
is
demonstrated
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
a
full
discussion
of
gpt
is
beyond
the
scope
of
this
book
and
is
also
quite
unncessary
the
linux
kernel
can
figure
out
the
partition
map
and
export
it
to
user
space
via
proc
commonly
proc
partitions
this
is
discussed
next
experiment
obtaining
the
partition
table
from
a
device
the
gpt
table
is
normally
inaccessible
from
user
mode
as
it
resides
outside
the
partitions
themselves
and
therefore
requires
raw
access
to
the
disk
device
if
your
device
is
rooted
however
you
can
examine
it
if
you
copy
the
first
sectors
and
use
on
your
host
to
analyze
output
2
1
reading
and
identifying
the
gpt
because
normally
runs
as
uid:shell
there
are
several
ways
to
obtain
raw
disk
access
1
re
run
adb
as
root
this
requires
setting
the
and
properties
during
startup
or
use
a
modified
version
of
adbd
which
doesn't
drop
privileges
2
use
as
root
to
copy
data
from
the
block
device
node
to
a
file
which
you
can
then
place
in
data
local
tmp
and
to
be
readable
by
uid
shell
or
anyone
3
use
directly
on
the
block
device
node
so
it
is
readable
by
uid
shell
and
in
fact
everyone
note
this
might
fail
in
some
cases
on
kitkat
and
later
depending
on
selinux
all
methods
carry
with
them
a
certain
amount
of
risk
running
as
root
would
compromise
your
phone
if
it
falls
into
the
wrong
hands
using
incorrectly
e.g
confusing
and
can
wipe
entire
partitions
in
a
heartbeat
using
to
make
a
device
readable
to
anyone
could
ostensibly
enable
dormant
malicious
applications
on
your
device
to
access
data
which
would
otherwise
be
well
protected
though
commonly
the
second
method
is
used
for
handling
raw
devices
the
last
approach
is
the
one
employed
in
this
book
of
the
three
the
author
believes
it
carries
with
it
the
least
risk
for
one
it
is
perfectly
reversible
and
will
not
persist
across
a
reboot
additionally
it
only
provides
read
access
and
therefore
does
not
risk
data
corruption
kdswhu
3duwlwlrqv
loh6
vwhpv
flash
storage
systems
the
storage
used
on
android
devices
is
not
entirely
standardized
some
devices
use
mtd
memory
technology
devices
whereas
others
e.g
htc
one
use
emmc
embedded
multimedia
card
and
others
still
use
mmc
multimedia
card
depending
on
the
system
used
the
partition
map
is
made
available
to
user
mode
via
proc
mtd
proc
emmc
respectively
or
the
linux
standard
proc
partitions
often
in
addition
to
one
of
the
former
two
for
the
most
part
whatever
system
is
actually
used
is
largely
transparent
to
most
at
a
high
level
the
chief
difference
between
the
systems
is
that
mtd
is
an
abstraction
layer
over
raw
flash
whereas
the
mmc
and
emmc
have
their
own
flash
translation
layer
ftl
and
appear
to
the
kernel
as
block
devices
most
modern
devices
therefore
use
one
of
the
latter
two
as
this
makes
them
far
more
suitable
for
use
with
block
based
filesystems
such
as
ext4
which
has
inherited
yaffs
as
the
filesystem
of
choice
in
modern
android
versions
file
systems
android
enforces
no
constraints
as
to
the
filesystem
types
but
emmc
and
mmc
devices
presently
use
the
linux
ext4
filesystem
as
of
gingerbread
in
place
of
the
older
yaffs
system
since
the
storage
layer
exports
a
block
device
ext4
has
become
the
default
filesystem
in
linux
as
of
2.6.27
and
is
a
well
tested
filesystem
albeit
not
a
necessarily
flash
optimized
one
some
devices
notably
the
moto
x
have
begun
adopting
the
flash
friendly
file
system
f2fs
as
the
filesystem
of
choice
for
the
data
partition
as
of
l
this
is
also
the
default
data
filesystem
of
choice
for
google's
nexi
the
filesystem
designed
by
samsung
is
a
log
structured
one
optimized
for
nand
flash
it
boasts
performance
improvements
over
ext4
especially
in
random
write
requests
indeed
extensive
benchmarking
tests
posted
to
xda
developers1
show
f2fs
has
clear
advantages
over
ext4
a
good
discussion
of
f2fs's
features
can
be
found
in
a
samsung
presentation2
and
an
article
by
neil
brown
on
lwn.net3
it
has
been
integrated
into
the
mainline
linux
kernel
as
of
3.8
and
as
android
upgrades
to
a
newer
kernel
it
is
likely
to
be
used
on
more
devices
android
also
supports
vfat
an
ms
dos
compatible
filesystem
which
it
uses
for
sd
cards
because
it
originated
in
the
dos
and
windows
9x
world
vfat
doesn't
support
the
notion
of
permissions
android
therefore
resorts
to
mounting
the
sdcard
in
a
secondary
mount
using
a
specialized
mechanism
discussed
later
in
this
chapter
the
kernel
maintains
a
list
of
all
supported
filesystems
in
proc
filesystems
this
pseudo
file
lists
which
filesystems
are
supported
either
natively
i.e
compiled
into
the
kernel
or
as
a
loaded
module
in
android
kernels
vendors
often
compile
support
for
filesystems
directly
into
the
kernel
although
it's
quite
possible
to
leave
support
for
a
filesystem
in
a
module
and
bundle
the
module
as
part
of
the
root
filesystem
the
good
news
about
filesystems
is
that
so
long
as
they
work
the
user
can
remain
blissfully
oblivious
to
which
filesystem
is
in
use
the
bad
news
however
hits
when
the
filesystems
don't
work
specifically
when
filesystem
corruption
occurs
corruption
is
thankfully
a
rare
event
and
usually
occurs
when
the
device
is
improperly
shut
down
for
example
due
to
power
loss
or
an
unexpected
crash
or
underlying
hardware
failure
android
provides
default
binaries
to
check
and
repair
filesystems
and
for
the
respective
filesystems
the
binaries
are
run
automatically
when
mounting
a
file
system
by
or
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
forum.xda
developers.com
showthread.php
t
2697069
http
elinux.org
images
1
12
elc2013_hwang.pdf
http
lwn.net
articles
518988
file
users
morpheus
documents
android
book
filesystems.html
sdcard
experiment
examining
partitions
on
an
android
device
you
can
view
the
partition
map
of
your
android
device
by
examining
the
proc
partitions
file
this
is
a
standard
kernel
proc
entry
which
provides
a
listing
of
all
block
devices
the
flash
storage
layer
in
mmc
and
emmc
devices
is
displayed
in
the
mmcblk
p
form
where
numbering
for
devices
starts
with
zero
and
for
partitions
with
one
block
are
512
byte
k
blocks
the
major
and
minor
refer
to
the
device
driver
with
major
being
in
effect
the
index
used
by
the
driver
in
the
kernel's
block
device
table
and
minor
being
the
index
of
the
logical
device
in
this
case
used
to
disambiguate
the
partitions
from
one
another
output
2
3
proc
partitions
from
a
nexus
5
telling
apart
the
partitions
just
by
their
cryptic
name
is
hard
but
thankfully
most
devices
have
symbolic
links
by
num
and
by
name
in
the
dev
block
platform
name
directory
the
platform
name
refers
to
the
controller
in
qualcomm's
case
msm_sdcc
1
for
the
main
storage
output
2
4
dev
block
platform
by
name
from
a
nexus
5
note
that
your
local
android
device
partition
names
can
and
likely
will
vary
while
most
msm
devices
generally
adhere
to
the
above
conventions
nvidia
based
devices
deviate
from
it
with
nigh
incomprehensible
three
letter
abbreviations
for
partition
names
as
do
omap
based
ones
kdswhu
3duwlwlrqv
loh6
vwhpv
system
data
android
device
partitions
as
the
previous
experiment
has
shown
partitions
on
android
devices
have
set
names
but
most
of
them
are
quick
cryptic
to
complicate
matters
different
device
chipsets
and
vendors
use
different
partitions
as
well
as
different
names
for
the
same
functional
partitions
to
explicate
we
break
the
partitions
into
the
following
classes
standard
android
partitions
all
devices
find
a
common
denominator
in
those
partitions
which
are
hard
coded
into
android
itself
in
various
locations
around
the
source
tree
these
partitions
comprise
the
core
of
the
os
the
standard
partitions
are
mostly
mountable
with
the
exception
of
the
boot
and
recovery
partitions
which
are
commonly
formatted
with
android's
proprietary
bootimg
format
explained
in
the
next
chapter
table
2
1
shows
these
partitions
table
2
1
android
standard
partitions
name
format
notes
boot
bootimg
kernel
initramfs
contains
kernel
and
ramdisk
to
boot
by
default
cache
ext4
android's
cache
used
for
updates
and
recovery
recovery
bootimg
boot
to
recovery
kernel
alternate
initramfs
to
start
system
recovery
system
ext4
android's
system
partition
os
binaries
and
frameworks
userdata
ext4
f2fs
android's
data
partition
user
data
and
configuration
android
devices
contain
a
file
system
mounting
table
this
table
in
system
etc
vold.fstab
or
in
more
recent
versions
of
android
fstab.hardware
is
loaded
by
the
volume
daemon
during
system
startup
and
provides
the
partitions
which
are
to
be
mounted
automatically
much
like
the
classic
un
x
etc
fstab
chipset
specific
partitions
chipset
vendors
often
require
dedicated
partitions
for
their
components
the
most
notable
example
is
qualcomm
whose
msm
chipset
arguably
the
most
popular
uses
the
partitions
shown
in
table
2
2
the
bootldr
format
is
discussed
in
the
next
chapter
table
2
2
partitions
found
on
qualcomm
msm
devices
name
format
notes
aboot
bootldr
application
processor
boot:this
contains
the
android
boot
loader
note
some
devices
may
use
custom
boot
loaders
instead
e.g
htc's
hboot
modem
msdos
contains
various
elf
binaries
and
data
files
to
support
device
modem
modemst
1
2
proprietary
non
volatile
data
for
modem
rpm
elf
32
bit
resource
power
management
this
provides
the
first
stage
bootloader
sbl
123
proprietary
secondary
boot
loader
optionally
split
into
up
to
three
stages
tz
elf
32
bit
arm
trustzone
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
boot.html
bootimg
file
users
morpheus
documents
android
book
boot.html
bootldr
vendor
specific
partitions
the
rest
of
the
partitions
found
on
an
android
device
are
specific
to
vendors
who
use
custom
partitions
for
their
own
purposes
mostly
device
configuration
maintenance
or
upgrade
operations
the
formatting
used
is
often
proprietary
a
partial
list
of
such
partitions
is
shown
in
table
2
3
table
2
3
vendor
custom
partitions
name
vendor
notes
hboot
htc
htc's
proprietary
boot
loader
replaces
aboot
on
htc
devices
efs
samsung
encrypted
file
system
contains
various
configuration
files
ssd
samsung
secure
software
download
ota
fota
samsung
firmware
over
the
air
used
in
the
process
of
phone
updates
grow
samsung
lg
empty
partition
to
allow
partition
growth
laf
lg
g2
nexus5
contains
an
alternate
bootimg
which
loads
lafd
lg
advanced
flash
daemon
used
for
device
re
flashing
the
laf
partition
is
a
recovery
image
format
imgdata
lg
g
pad
g2
nexus5
rle
images
in
imgdata
format
similar
to
bootldr
the
xda
developers
forum
maintains
an
on
going
list
of
partition
maps
from
various
devices
similar
to
the
one
in
the
previous
experiment
in
its
el
grande
partition
table
reference4
experiment
viewing
mounted
partitions
on
a
device
you
can
examine
the
mount
points
by
using
or
the
former
provides
disk
usage
statistics
for
the
mounted
partitions
this
is
shown
in
listing
2
dfmount
which
shows
the
output
of
the
command
on
a
nexus
9
with
l
output
2
5
demonstrating
on
a
nexus
9
note
that
the
output
differs
from
the
traditional
linux
since
the
command
is
implemented
as
a
tool
only
filesystems
mounted
over
actual
storage
that
is
real
devices
are
shown
by
comparison
using
provides
far
more
verbose
information
as
it
provides
information
on
pseudo
file
systems
implemented
in
memory
as
well
as
mount
options
though
at
the
cost
of
reporting
space
the
mount
options
displayed
may
either
be
generic
or
filesystem
specific
table
2
4
provides
an
explanation
on
the
options
you
are
likely
to
encounter
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
filesystems.html
f
ep
http
forum.xda
developers.com
showthread.php
t
1959445
experiment
viewing
mounted
partitions
on
a
device
cont
table
2
4
commonly
encountered
mount
options
option
kind
specifies
ro
rw
generic
read
only
allows
only
read
operations
and
cannot
be
modified
read
write
allows
both
read
and
write
operations
acl
generic
allow
extended
access
control
lists
for
finer
control
than
user
group
other
seclabel
generic
selinux
labels
are
enabled
on
the
filesystem
nosuid
generic
the
filesystem
does
not
allow
setuid
binaries
noatime
generic
file
operations
do
not
record
access
time
only
modification
or
creation
this
makes
file
access
faster
and
reduces
write
activity
relatime
generic
update
access
time
relative
to
creation
modification
time
data
ext3
4
ordered
commit
data
to
filesystem
before
writing
journal
journal
commit
data
to
journal
before
filesystems
errors
ext3
4
continue
silently
ignore
errors
remount
ro
remount
filesystem
as
read
only
if
errors
are
encountered
panic
crash
the
system
background_gc
f2fs
reclaim
space
freed
by
deleted
files
in
a
kernel
thread
the
command
is
shown
in
the
following
output
the
psexgo
filesystems
are
in
italics
and
can
be
recognized
by
the
fact
they
are
not
mounted
on
a
device
that
is
the
first
column
does
not
start
with
a
dev
path
output
2
6
demonstrating
on
a
nexus
9
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
android
filesystem
contents
irrespective
of
vendor
the
android
standard
partitions
have
a
well
defined
filesystem
layout
device
vendors
use
the
android
filesystem
images
provided
by
google
for
the
android
emulator
as
a
point
of
departure
but
the
journey
is
often
a
very
short
one
we
next
describe
the
contents
of
the
various
filesystems
starting
at
the
root
and
progressing
by
mount
point
note
that
while
the
filesystems
are
largely
the
same
across
devices
your
device's
contents
can
and
will
vary
many
vendors
including
google
drop
additional
device
specific
binaries
these
are
referred
to
as
proprietary
blobs
and
you
can
see
those
dropped
into
system
in
the
device
subdirectory
of
the
aosp
in
files
called
proprietary
blobs.txt
per
device
the
root
file
system
android's
root
file
system
is
mounted
from
a
ram
disk
the
initramfs
upon
every
boot
the
boot
loader
fastboot
loads
the
filesystem
image
from
the
boot
partition
onto
ram
and
provides
it
for
the
kernel
the
process
is
detailed
in
the
next
chapter
but
for
the
purpose
of
the
present
discussion
the
salient
point
is
that
the
root
filesystem
image
cannot
be
easily
modified
unless
the
device
is
flashed
this
is
important
because
the
root
filesystem
contains
the
most
important
component
of
the
system
init
which
runs
unfettered
as
root
and
controls
the
system
startup
vanilla
linux
normally
uses
the
initramfs
to
supply
drivers
in
the
form
of
kernel
modules
to
the
kernel
during
the
initial
boot
and
eventually
discards
it
in
favor
of
the
real
filesystem
android
however
does
not
android's
initramfs
remains
resident
and
provides
the
root
filesystem
functionality
which
is
in
practice
limited
to
housing
init
and
several
other
configuration
files
and
binaries
these
are
shown
in
table
2
6
table
2
6
the
contents
of
the
android
root
filesystem
excluding
mount
points
directory
notes
default.prop
additional
default
property
file
sourced
by
init
to
load
system
wide
properties
loads
read
only
properties
which
help
enforce
security
init
the
binary
launched
by
the
kernel
on
startup
as
pid
1
described
in
chapter
4
init
rc
the
configuration
file
s
for
init
the
main
configuration
file
is
always
init.rc
with
optional
additional
files
which
are
device
and
vendor
dependent
likewise
described
in
chapter
4
property_contexts
kitkat
property
contexts
for
se
linux
restrict
access
to
system
properties
described
in
chapter
8
seapp_contexts
kitkat
application
contexts
for
se
linux
restrict
application
operational
scope
described
in
chapter
8
sepolicy
kitkat
the
compiled
selinux
policy
q.v
chapter
8
sbin
contains
critical
binaries
such
as
adbd
healthd
and
most
importantly
recovery
which
the
system
needs
even
if
system
cannot
be
mounted
may
also
contain
vendor
binaries
verity_key
l
contains
the
dm
verity
rsa
key
required
to
authenticate
the
system
partition
kdswhu
3duwlwlrqv
loh6
vwhpv
file_contexts
kitkat
file
contexts
for
se
linux
restrict
access
to
system
files
and
directories
described
in
chapter
8
fstab.hardware
the
filesystem
mount
table
used
by
fs_mgr
and
vold
described
in
chapters
4
and
5
file
users
morpheus
documents
android
book
boot.html
initramfs
file
users
morpheus
documents
android
book
security.html
selinux
file
users
morpheus
documents
android
book
init.html
file
users
morpheus
documents
android
book
init.html
file
users
morpheus
documents
android
book
security.html
selinux
file
users
morpheus
documents
android
book
security.html
selinux
file
users
morpheus
documents
android
book
security.html
selinux
system
the
system
partition
is
the
home
of
all
android
components
as
provided
by
google
and
or
the
vendor
the
directory
and
its
contents
are
owned
by
root:root
and
all
have
permissions
of
0755
rwxr
xr
x
but
the
filesystem
is
mounted
read
only
a
read
only
mount
makes
sense
for
two
reasons
stability
because
the
filesystem
is
mounted
read
only
there
is
virtually
no
chance
of
it
being
corrupted
even
if
the
device
is
powered
off
abruptly
this
reduces
the
chance
of
an
error
which
might
brick
the
device
by
preventing
android
from
booting
security
a
read
only
mount
is
another
layer
of
defence
to
protect
the
android
system
components
from
being
tampered
with
in
practice
though
it
is
trivial
to
remount
the
partition
as
read
write
some
vendors
notably
htc
also
ensure
system
is
read
only
using
flash
partition
protections
htc
calls
this
s
off
this
means
that
even
if
system
is
mounted
read
write
any
changes
to
it
will
not
be
made
persistent
as
of
kitkat
google
offers
integrity
checking
for
system
using
the
linux
kernel's
dm
verity
feature
discussed
in
chapter
8
the
system
partition
is
for
the
most
part
the
same
on
most
devices
in
a
perfect
world
it
would
be
exactly
identical
though
in
practice
vendors
and
carriers
sometimes
add
their
own
apps
and
rarely
directories
rather
than
in
vendor
which
is
the
location
designed
for
that
table
2
7
shows
the
contents
of
the
the
system
partition
you
can
expect
on
any
android
device
table
2
7
the
contents
of
the
system
partition
directory
notes
app
system
applications
these
include
the
prebundled
apps
from
google
as
well
as
any
vendor
or
carrier
installed
apps
though
these
should
technically
reside
in
vendor
app
instead
bin
binaries
these
include
the
various
daemons
as
well
as
shell
commands
mostly
links
to
toolbox
or
as
of
m
toybox
build.prop
properties
generated
as
part
of
the
build
process
this
file
is
sourced
by
init
to
load
properties
on
boot
etc
miscellaneous
configuration
files
symlinked
from
etc
q.v
table
fs
etc
for
contents
fonts
true
type
font
ttf
files
framework
the
android
frameworks
frameworks
are
contained
in
jar
files
with
their
executable
dex
files
optimized
alongside
them
in
odex
lib
runtime
libraries
native
elf
shared
object
so
files
this
directory
serves
the
same
role
as
lib
in
vanilla
linux
lost
found
automatically
generated
directory
for
fsck
operations
on
system
empty
unless
the
filesystem
crashed
in
which
case
it
may
contain
unlinked
inodes
media
alarm
notification
ringtone
and
ui
effect
audio
files
in
ogg
format
and
the
system
boot
animation
discussed
in
chapter
5
priv
app
privileged
applications
usr
support
files
such
as
unicode
mappings
icudt511
dat
key
layout
files
for
keyboards
and
devices
etc
vendor
vendor
specific
files
if
any
usually
placed
into
subdirectories
mirroring
system
itself
e.g
bin
lib
and
media
xbin
special
purpose
binaries
not
needed
for
normal
operation
unlike
those
in
bin
on
the
emulator
this
is
populated
with
various
tools
from
the
aosps
system
extras
on
devices
this
directory
is
normally
empty
or
contains
only
dexdump
various
rooting
utilities
drop
su
there
as
well
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
diskver
system
bin
the
system
bin
directory
contains
the
native
executables
used
by
the
android
as
well
as
a
host
of
debugging
tools
specifically
these
binaries
can
be
classified
into
the
five
categories
service
binaries
invoked
by
init
throughout
the
lifetime
of
the
system
these
binaries
are
referenced
in
the
rc
files
used
by
init
and
are
required
for
system
operation
not
all
of
these
are
directly
from
the
aosp
those
marked
in
yellow
are
external
projects
table
2
8
service
binaries
in
system
bin
binary
function
app_process
32
64
host
process
for
apps
zygote
and
all
user
apps
are
instances
of
this
binary
which
initializes
the
dalvikvm
art
on
64
bit
devices
both
32
64
are
present
applypatch
_static
used
during
ota
updates
applies
patches
according
to
scripts
as
discussed
in
chapter
3
the
_static
binary
is
a
statically
linked
version
used
for
updates
that
would
modify
the
dependencies
of
the
normal
dynamically
linked
binary
bootanimation
plays
android
boot
animation
while
graphics
subsystem
surfaceflinger
is
loading
often
customized
by
vendor
clatd
ipv4
to
ipv6
address
translation
dalvikvm
starts
an
instance
of
the
dalvik
virtual
machine
debuggerd
generates
tombstones
from
process
crashes
optionally
connects
to
a
remote
gdb
drmserver
host
process
for
3rd
party
digital
rights
management
drm
modules
dnsmasq
dns
masquerade
provides
dns
proxying
services
when
device
is
providing
tethering
over
wi
fi
hostapd
host
access
point
daemon
provides
access
point
emulation
when
device
is
providing
tethering
over
wi
fi
keystore
android's
key
storage
and
management
service
linker
android's
runtime
linker
not
a
service
per
se
but
required
for
binary
loading
messing
with
this
is
a
surefire
way
to
brick
your
device
mdnsd
multicast
dns
daemon
used
for
neighbor
discovery
over
wi
fi
direct
mediaserver
audio
video
recording
playback
mtpd
ppp
l2tp
support
netd
manages
network
interfaces
firewalling
and
more
pppd
point
to
point
protocol
daemon
required
for
vpns
racoon
provides
vpn
support
rild
radio
interface
layer
daemon
in
charge
of
all
telephony
services
sdcard
sdcard
daemon
manages
sd
cards
so
as
to
emulate
multiple
users
via
fuse
discussed
later
in
this
chapter
sensorservice
sensor
hub
coordiates
reading
from
various
sensors
servicemanager
service
locator
and
fulcrum
for
all
binder
related
services
surfaceflinger
composes
graphics
surfaces
and
loads
them
onto
the
framebuffer
vold
volume
daemon
mounts
unmounts
filesystems
and
optionally
decrypts
uncrypt
decrypts
filesystem
for
use
before
recovery
wpa_supplicant
wireless
protected
access
supplicant
provides
client
support
for
wi
fi
and
wi
fi
p2p
services
are
described
in
reat
detail
in
chapter
5
in
the
context
of
their
startup
by
init
kdswhu
3duwlwlrqv
loh6
vwhpv
ate
ee
er
m
ew
daemon
to
handle
authentication
file
users
morpheus
documents
android
book
services.html
debugging
tools
these
are
native
binaries
left
for
debugging
the
following
list
shows
those
found
in
the
emulator
though
vendors
at
their
discretion
may
decide
to
omit
them
from
production
devices
table
2
9
debugging
tools
in
system
bin
binary
function
adb
android
debugger
bridge
client
this
is
essentially
the
same
binary
as
the
host
the
server
portion
is
in
sbin
adbd
asanwrapper
address
sanitizer
memory
corruption
detecting
tool
3rd
party
debugging
tool
atrace
android
tracing
tool
uses
linux
ftrace
to
debug
and
trace
execution
bdt
bluedroid
bluetooth
for
android
test
app
blkid
displays
guids
of
partitions
cjpeg
jpg
processing
tool
dex2oat
dex
to
art
conversion
tool
compiles
the
dex
file
to
device
executable
format
supersedes
dexopt
dexopt
dex
optimization
tool
creates
device
optimized
dex
files
deprecated
when
using
art
dumpstate
meta
tool
combining
several
useful
utilities
ps
dumpsys
etc
for
capturing
a
debug
snapshot
of
system
state
dumpsys
service
dump
utility
connects
to
android
services
and
requests
their
dump
method
providing
a
plethora
of
debugging
information
e2fsck
fsck_msdos
fsck.f2fs
ext2
3
4
vfat
and
f2fs
filesystem
checkers
run
automatically
by
the
system
before
mounting
filesystems
gdbserver
gdb
server
tool
used
to
connect
gdb
over
tcp
ip
from
host
in
order
to
debug
processes
omitted
from
most
devices
ip
6
tables
manage
the
kernel
iptables
firewall
and
network
quota
from
the
command
line
keystore_cli
command
line
utility
for
interfacing
with
the
keystore
service
logcat
print
the
system
logs
dev
log
to
stdout
with
optional
filters
this
command
is
so
useful
that
it
can
be
used
directly
as
ndc
command
line
utility
for
interfacing
with
the
network
management
daemon
netd
perf
extremely
powerful
profiling
tool
which
uses
the
kernel's
profiling
support
ping
6
packet
internet
grouper
icmp
echo
request
reply
radiooptions
test
utility
for
simulating
radio
interface
layer
ril
events
run
as
run
an
application
under
specific
aid
screencap
capture
framebuffer
to
stdout
or
to
a
png
file
used
by
adb
screenrecord
record
movie
as
mp4
of
device
display
screenshot
as
screencap
with
optional
sound
to
play
on
screen
shot
service
command
line
utility
for
interfacing
with
the
servicemanager
toolbox
android's
multi
call
binary
as
discussed
above
vdc
command
line
utility
for
interfacing
with
the
volume
daemon
vold
wpa_cli
command
line
utility
for
interfacing
with
wpa_supplicant
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
un
x
commands
left
as
a
convenience
for
the
shell
user
the
un
x
commands
are
packaged
into
a
single
binary
system
bin
toolbox
or
as
of
m
toybox
ither
box
is
an
android
specific
version
of
the
busybox
binary
which
is
an
all
in
one
tool
common
in
embedded
systems
rather
than
providing
every
single
un
x
command
the
commands
contain
basic
implementations
of
those
commands
and
can
emulate
the
commands
based
on
their
ar
ument
e
toolbox
ls
or
when
invoked
via
a
symbolic
link
i.e
ln
s
system
bin
toolbox
system
bin
ls
the
and
provide
a
reduced
subset
of
the
commands
including
several
android
specific
commands
e.g
dqg
dalvik
upcall
scripts
allow
the
shell
user
to
interact
with
the
dalvik
runtime
frameworks
mostly
for
debugging
all
these
scripts
with
the
exception
of
uiautomator
are
cut
paste
from
the
same
template
which
calls
on
system
bin
app_process
to
load
the
dalvik
class
from
its
containing
framework
jar
and
directly
passhv
any
arguments
to
it
to
see
the
template
it
suffices
to
look
at
the
am
script
presented
in
listing
2
1
listing
2
1
the
script
template
for
the
dalvik
upcalls
table
2
10
shows
the
scripts
and
their
purpose
invocation
with
no
arguments
will
yield
a
usage
message
table
2
10
the
app_process
wrapper
scripts
in
system
bin
script
usage
am
interact
with
activitymanager
start
activities
fire
intents
and
much
more
bmgr
backup
manager
interface
bu
start
backup
content
interface
to
android's
content
providers
ime
control
input
method
editors
input
interact
with
inputmanager
inject
input
events
discussed
in
volume
ii
media
control
the
current
media
client
play
pause
etc
monkey
run
an
apk
with
randomly
generated
input
events
pm
interact
with
packagemanager
list
install
remove
packages
list
permissions
etc
requestsync
sync
accounts
settings
get
set
system
settings
svc
control
the
power
data
wifi
and
usb
services
uiautomator
performs
ui
automation
tests
dumps
view
hierarchy
etc
wm
interact
with
windowmanager
change
display
size
density
etc
it's
a
good
idea
to
install
busybox
on
android
as
most
custom
roms
do
busybox
contains
far
more
tools
than
toolbox
does
making
it
indispensable
for
the
power
user
m's
toybox
is
far
better
as
well
providin
at
last
ore
starting
the
dalvik
vm
by
means
of
app_process
from
the
shell
rather
than
forking
off
of
zygote
which
is
itself
an
instance
of
app_process
is
considerably
slower
as
you
can
see
for
yourself
by
running
any
of
the
above
scripts
kdswhu
3duwlwlrqv
loh6
vwhpv
sm
m
stora
e
mana
ement
appwid
et
l
rant
revoke
ser
application
wid
ets
dpm
m
device
admin
profile
mana
ement
vendor
specific
binaries
these
naturally
vary
with
vendor
but
are
generally
either
services
or
debugging
tools
qualcomm
provides
a
set
of
binaries
which
are
common
to
msm
based
devices
including
the
following
table
2
11
qualcomm
specific
binaries
in
system
bin
binary
function
mm
qcamera
daemon
qualcomm
built
in
camera
daemon
mpdecision
multi
processor
decision
proprietary
tool
to
manage
cpu
frequency
interacts
with
cpu
governor
to
increase
frequency
and
or
activate
cores
when
system
is
busy
and
decrease
frequency
and
or
shutdown
cores
when
system
is
idle
qmuxd
qualcomm
baseband
access
multiplexer
qseecomd
qualcomm
secure
execution
environment
communicator
thermal
engine
hh
thermal
daemon
responsible
for
monitoring
device
temperature
and
preventing
overheating
in
addition
to
the
chipset
vendor
qualcomm
nvidia
omap
etc
there
may
or
may
not
be
other
binaries
provided
by
the
handset
vendor
htc
samsung
etc
as
you'll
see
in
a
bit
these
non
aosp
binaries
can
and
should
be
placed
elsewhere
specifically
vendor
but
whether
or
not
to
observe
this
convention
is
left
up
for
the
vendors
to
decide
vendor
specific
binaries
are
commonly
closed
source
and
regrettably
so
in
many
cases
these
binaries
can
profoundly
impact
system
performance
or
security
and
may
contain
exploitable
vulnerabilities
qualcomm's
is
a
prime
example
of
such
a
case
as
is
htc's
which
gave
rise
to
the
weaksauce
exploit
as
detailed
on
the
book's
companion
website
5
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
newandroidbook.com
articles
htc.html
system
xbin
the
system
xbin
directory
is
akin
to
unix's
sbin
in
the
sense
that
it
contains
binaries
which
administrators
find
useful
but
normal
users
are
probably
better
off
staying
away
from
the
x
was
chosen
rather
than
an
s
to
avoid
confusion
with
android's
own
sbin
which
is
part
of
the
root
filesystem
and
contains
binaries
critical
to
system
operation
binaries
in
this
directory
are
compiled
from
the
aosp's
system
extras
directory
because
this
directory
is
not
strictly
required
for
normal
operation
it
is
left
to
the
vendor's
discretion
as
to
what
to
populate
it
with
some
vendors
in
fact
choose
not
to
populate
it
at
all
or
leave
only
dexdump
table
2
12
shows
the
contents
of
the
extra
tools
found
in
the
emulator
table
2
12
aosp
binaries
found
in
the
system
xbin
directory
on
the
emulator
binary
function
add
property
tag
add
properties
to
a
system
prop
file
check
lost
found
check
lost
found
directory
after
a
fsck
operation
cpueater
tight
loop
to
consume
100
cpu
cpustats
display
cpu
and
governor
frequency
controller
statistics
daemonize
turn
an
executable
into
a
daemon
by
running
in
background
and
closing
stdin
stdout
stderr
dexdump
dex
file
dumping
tool
provides
header
and
bytecode
dump
directiotest
test
i
o
over
block
devices
kexecload
overwrite
kernel
image
with
new
kernel
using
system
call
ksminfo
kernel
same
page
merger
information
ksm
saves
ram
by
detecting
via
a
hash
duplicate
virtual
memory
pages
and
keeping
only
one
physical
page
latencytop
displays
data
from
proc
sys
kernel
latencytop
in
a
more
readable
form
librank
display
vss
rss
pss
uss
by
shared
memory
region
memtrack
tracks
process
memory
utilization
via
proc
pid
smaps
micro_bench
memory
benchmarking
tool
nc
netcat
the
swiss
army
knife
of
tcp
and
udp
netperf
netserver
network
performance
tool
client
and
server
procmem
show
process
memory
statistics
from
proc
pid
status
procrank
complement
to
librank
providing
vss
rss
pss
uss
usage
statistics
but
by
process
rawbu
low
level
backup
restore
of
data
sane_schedstat
a
human
readable
form
of
scheduler
statistics
showmap
display
process
memory
map
proc
pid
maps
showslab
display
kernel
slab
allocator
information
proc
slabinfo
sqlite3
sqlite3
command
line
tool
becuase
so
many
content
providers
in
android
are
backed
by
sqlite3
this
is
an
indispensable
tool
for
debugging
and
forensics
strace
system
call
tracer
using
the
linux
ptrace
2
system
call
unbelieveably
powerful
tool
for
tracing
and
reverse
engineering
su
switch
user
to
root
or
other
taskstats
provides
detailed
statistics
using
linux's
taskstats
interface
if
kernel
supports
it
tcpdump
packet
capture
tool
capture
files
can
then
be
opened
with
wireshark
timeinfo
print
realtime
uptime
awake
percentage
and
sleep
percentage
kdswhu
3duwlwlrqv
loh6
vwhpv
iperf3
handy
profiling
and
benchmarking
utility
perfprofd
m
perf
profiling
daemon
collects
data
to
data
misc
perfprofd
the
precompiled
binaries
are
exceptionally
useful
as
debugging
tools
on
a
real
device
moving
them
is
a
straightforward
matter
as
simple
as
using
into
a
directory
on
the
host
and
then
using
to
the
device
assuming
a
writable
system
nearly
all
binaries
however
both
those
in
system
xbin
and
system
bin
require
shared
libraries
to
work
correctly
these
found
in
system
lib
are
discussed
next
system
lib
64
the
system
lib
and
on
64
bit
devices
system
lib64
directory
contains
the
shared
libraries
used
by
the
binaries
in
system
bin
and
system
xbin
the
previous
chapter
provided
a
cursory
glance
at
the
various
libraries
in
most
devices
system
lib
has
several
subdirectories
while
some
of
these
are
device
dependent
common
ones
include
drm
providing
drm
engines
such
as
libfwdlockengine.so
for
forward
locking
egl
for
android's
opengles
implementation
discussed
in
volume
ii
hw
containing
hal
modules
as
discussed
in
the
the
previous
chapter
ssl
engines
containing
libkeystore.so
which
allows
openssl
integration
with
android
keystore
mechanism
on
intel
devices
system
lib
normally
contains
an
additional
subdirectory
called
arm
which
contains
copies
of
the
same
libraries
compiled
for
the
arm
architecture
these
are
used
by
intel's
binary
translation
layer
houdini
to
provide
a
full
environment
for
any
arm
binaries
commonly
in
apks
which
contain
native
libraries
nexus
devices
contain
even
more
subdirectories
containing
jni
libraries
for
various
google
services
such
as
chrome
drive
wallet
and
others
nearly
all
of
android's
binaries
are
dynamically
linked
an
exception
to
the
rule
are
the
binaries
in
sbin
which
following
the
traditional
un
x
model
are
meant
to
be
used
in
instances
wherein
system
and
therefore
system
lib
is
not
mounted
the
following
experiment
demonstrates
how
you
can
find
precisely
which
libraries
a
given
binary
requires
experiment
displaying
the
dependent
binaries
for
a
given
library
or
vice
versa
one
tool
sorely
lacking
from
the
android
ndk
is
which
is
used
in
linux
to
show
loader
dependencies
the
linux
version
of
ldd
actually
simulates
the
loading
of
a
binary
which
is
why
it
fails
when
processing
a
binary
on
a
machine
of
a
different
architecture
the
tool
found
on
the
book's
companion
website
will
enable
you
to
display
the
dependencies
of
an
executable
similar
to
ldd
1
but
also
scan
all
executables
in
a
given
path
to
see
which
depend
on
a
given
library
as
hinted
previously
the
tool
can
be
quite
useful
when
moving
binaries
between
devices
or
from
the
emulator
to
the
device
many
of
the
binaries
in
the
emulator's
system
xbin
are
invaluable
for
debugging
and
tracing
on
a
real
device
it's
a
fairly
simple
matter
to
move
them
from
the
emulator
to
device
when
both
use
the
same
version
of
android
provided
all
the
dependencies
are
met
as
well
for
example
and
depend
on
using
the
tool
will
show
you
this
output
2
7
using
the
utility
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
introduction.html
file
users
morpheus
documents
android
book
introduction.html
hal
system
etc
much
like
its
un
x
namesake
android's
system
etc
contains
miscellaneous
configuration
files
et
cetera
the
directory
is
also
symbolically
linked
to
from
etc
to
maintain
compatibility
with
external
projects
in
aosp
which
expect
to
find
their
configuration
there
table
2
13
shows
the
contents
commonly
found
in
this
directory
table
2
13
files
and
directories
commonly
found
in
system
etc
name
description
notice.html.gz
legal
notices
for
the
myriad
open
source
components
of
android
required
for
various
obscure
licenses
and
legal
reasons
as
these
aren't
read
frequently
or
ever
they
are
put
into
one
hyperlinked
file
and
gzipped
audio_effects.conf
audio_policy.conf
used
by
the
android
audio
hal
described
in
volume
ii
apns
conf.xml
telephony
provider
configuration
file
listing
carriers
supported
by
device
used
by
asound.conf
on
some
devices
the
advanced
linux
sound
architecture
alsa
configuration
file
for
the
device
bluetooth
the
bluedroid
configuration
files
clatd.conf
configuration
file
for
clatd
handles
ipv4
over
ipv6
event
log
tags
log
tags
for
various
android
system
components
used
by
fallback_fonts.xml
list
of
fallback
fonts
to
load
for
families
not
specified
in
system_fonts.xml
used
by
android's
layoutlib's
fontloader
gps.conf
gps
configuration
file
hosts
hosts
map
containing
localhost
127.0.0.1
for
compatibility
media_codecs.xml
stagefright's
codec
list
q.v
volume
ii
media_profiles.xml
libmedia's
profile
list
q.v
volume
ii
ppp
contains
binaries
for
starting
stopping
vpn
and
ppp
connectivity
permissions
xml
files
containing
permissions
for
built
in
apps
aosp's
and
vendor's
used
by
the
packagemanager
security
directory
containing
the
device's
hard
coded
certificate
authorities
cacerts
ota
update
certificates
otacerts.zip
and
selinux
labels
for
signed
apks
detailed
in
chapter
8
system_fonts.xml
list
of
system
fonts
organized
by
families
and
namesets
mapping
font
styles
to
ttf
files
in
system
fonts
used
by
android's
layoutlib's
fontloader
wifi
configuration
directory
for
wpa
supplicant
controlling
wi
fi
and
wi
fi
p2p
connectivity
see
volume
ii
depending
on
the
device
vendor
and
in
particular
the
chipset
provider
system
etc
may
hold
any
number
of
additional
files
table
2
14
shows
some
files
commonly
found
on
qualcomm
devices
with
the
msm
chipset
table
2
14
files
in
system
etc
on
qualcomm
msm
devices
name
description
acdb
miscellaneous
audio
calibration
database
files
used
by
libacdbloader.so
on
qualcomm
devices
snd_msm
alsa
files
for
qualcomm
msm
soc
sound
device
thermal
conf
configuration
file
for
the
thermald
daemon
which
monitors
device
temperature
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
security.html
keymgmt
data
the
data
partition
is
where
all
the
user's
personal
data
resides
providing
a
separate
partition
for
this
provides
several
important
advantages
data
is
decoupled
from
the
underlying
android
os
version
system
upgrade
and
recovery
can
thus
wipe
and
rewrite
the
entire
system
partition
without
affecting
the
user's
data
in
any
way
conversely
the
device
can
quickly
be
reset
and
all
personal
data
wiped
by
formatting
data
which
is
exactly
what
happens
during
a
factory
reset
data
may
be
encrypted
if
the
user
requires
it
encryption
however
efficient
adds
a
degree
of
latency
since
reading
and
writing
involves
decryption
and
encryption
respectively
because
by
design
system
contains
no
sensitive
information
there
is
no
need
to
encrypt
it
and
therefore
this
latency
is
avoided
data
may
also
be
made
non
executable
i.e
mounted
with
the
option
or
enforced
with
selinux
as
of
kitkat
this
isn't
a
default
option
doing
so
however
would
not
only
would
make
it
more
true
to
its
name
but
would
greatly
mitigating
an
attack
vector
for
malware
since
the
latter
would
have
no
writable
partition
that
it
can
drop
executables
to
this
would
not
affect
legitimate
dalvik
art
apps
because
dex
and
oat
run
in
a
virtual
machine
but
would
likely
impact
rooting
for
example
by
requiring
a
remount
the
same
as
it
does
with
system
the
data
partition
is
mounted
with
which
makes
rooting
the
device
a
bit
more
of
a
cumbersome
operation
assuming
that
root
access
is
somehow
obtained
the
binary
which
makes
for
an
efficient
persistent
backdoor
must
be
placed
in
system
which
is
read
only
in
practice
this
is
only
a
minor
obstacle
since
it's
a
simple
enough
operation
to
remount
system
in
read
write
mode
nonetheless
this
is
an
example
of
defense
in
depth
and
could
actually
prove
effective
when
system
is
cryptographically
hashed
as
with
kitkat's
dm
verity
q.v
chapter
8
table
2
15
shows
the
contents
of
the
data
partition
note
vendors
and
carriers
may
place
additional
files
or
directories
table
2
15
directories
under
the
data
partition
directory
notes
anr
used
by
to
record
stack
traces
of
non
responsive
android
apps
stack
traces
are
recorded
into
as
per
the
property
app
user
installed
applications
downloaded
apk
files
can
be
found
here
app
asec
application
asec
containers
described
later
in
this
chapter
app
lib
jni
libraries
of
applications
both
system
and
user
installed
can
be
found
here
app
private
provided
for
application
private
storage
in
practice
largely
unused
since
asec
provides
better
security
backup
used
by
the
backup
service
bugreports
used
exclusively
by
for
generated
reports
which
include
a
text
file
and
screenshot
png
both
named
yyyy
mm
dd
hh
mm
ss
dalvik
cache
the
optimized
of
system
and
user
applications
each
app's
dex
is
preceded
by
the
path
to
its
apk
with
replacing
the
path
separator
e.g
data
data
directories
for
installed
applications
in
reverse
dns
format
discussed
next
dontpanic
formerly
used
to
store
android
panic
console
and
threads
unused
drm
used
by
android's
digital
rights
management
local
a
readable
writable
temporary
directory
for
uid
shell
usable
in
adb
sessions
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
file
users
morpheus
documents
android
book
filesystems.html
asec
table
2
15
cont
directories
under
the
data
partition
directory
notes
media
used
by
the
service
for
mounted
media
mediadrm
used
by
the
media
drm
service
misc
miscellaneous
data
and
configuration
directories
for
components
q.v
table
2
dm
nfc
stores
nfc
parameters
property
contains
persistent
properties
i.e
saved
across
device
reboots
each
property
is
saved
in
its
own
file
with
the
property
name
serving
as
the
file
name
resource
cache
resources
cached
by
the
assetmanager
described
in
volume
ii
security
commonly
empty
ssh
for
devices
which
provide
the
secure
shell
service
usually
empty
system
a
multitude
of
system
configuration
files
shown
in
table
2
18
tombstones
application
crash
reports
generated
by
debuggerd
due
to
limited
filesystem
space
full
core
dumps
are
not
feasible
the
debuggerd
provides
basic
autopsy
services
in
absence
of
a
core
dump
some
vendors
allocate
a
separate
partition
to
this
directory
user
jb
and
later
provides
multi
user
capabilties
by
symlinking
user
numbers
0,1
to
directories
with
installed
applications
and
data
for
those
users
in
a
single
user
system
0
links
to
data
data
the
data
directory
permissions
as
well
as
those
of
data
data
discussed
next
are
both
set
to
and
therein
lies
a
tenet
of
android's
security
model
the
directory
is
executable
i.e
able
to
all
applications
but
unreadable
so
applications
or
untrusted
processes
can't
enumerate
neighbor
directories
this
means
that
as
uid
in
a
non
rooted
session
you
will
be
able
to
change
directory
into
data
and
most
of
its
subdirectories
but
not
necessarily
be
able
to
read
their
contents
the
system
subdirectories
e.g
data
system
and
data
misc
will
be
readable
but
data
data
and
data
itself
will
refuse
the
command
this
is
also
augmented
as
of
kitkat
by
selinux
labels
you
will
therefore
need
root
access
to
traverse
subdirectories
freely
kdswhu
3duwlwlrqv
loh6
vwhpv
lost
found
automatically
generated
directory
for
fsck
operations
on
data
empty
unless
the
filesystem
crashed
in
which
case
it
may
contain
unlinked
inodes
file
users
morpheus
documents
android
book
filesystems.html
t2
dm
file
users
morpheus
documents
android
book
filesystems.html
f
datasys
file
users
morpheus
documents
android
book
services.html
debuggerd
data
data
the
somewhat
redundantly
named
data
data
is
the
directory
where
all
applications
both
system
and
user
installed
store
their
information
each
application
gets
its
own
subdirectory
in
reverse
dns
format
which
is
under
the
uid
gid
of
the
owning
application
the
data
data
directory
itself
is
which
makes
it
traversable
by
all
applications
but
readable
to
none
but
the
system
owned
ones
the
burden
of
securing
specific
application
files
however
rests
on
each
and
every
application
as
the
per
app
directories
are
freely
executable
though
are
unreadable
by
anyone
other
than
the
owner
the
data
data
per
app
subdirectory
is
the
only
location
in
the
entire
filesystem
which
is
writable
by
apps
coupled
with
the
fact
that
the
stock
applications
for
location
texting
and
calls
can
be
found
on
every
android
device
this
makes
several
locations
in
it
key
for
performing
forensics
subdirectories
of
particular
interest
are
shown
in
table
2
16
table
2
16
but
a
few
of
the
app
directories
of
interest
in
data
data
app
subdirectory
used
by
contains
com.android.providers.calendar
calendar
calendar
databases
calendar.db
in
the
events
table
com.android.providers.contacts
phone
contacts
virtually
every
tidbit
of
information
which
might
be
of
remote
interest
on
the
device
in
databases
contacts2
db
a
sqlite3
master
contact
database
including
tables
like
contacts
all
contacts
stored
on
the
device
and
calls
log
of
last
calls
files
thumbnail_photo_xxxxx.png
are
individual
thumbnails
of
contacts
com.android.providers.telephony
messaging
multimedia
mms
text
sms
message
database
database
mmssms.db
com.android.providers.settings
settings
databases
settings.db
all
android
framework
runtime
settings
and
more
in
and
tables
com.google.android.apps.maps
google
maps
destinations
looked
up
gmm_myplaces.db
gmm_storage.db
and
log_events.db
cache
http
contains
map
tiles
com.google.android.gm
gmail
databases
mailstore.email.db
a
sqlite3
database
containing
all
the
user's
mail
which
has
been
downloaded
to
the
device
for
each
registered
email
address
in
the
messages
table
viewed
attachments
are
stored
in
cache
email
com.android.chrome
chrome
browser
state
of
chrome
browser
which
replaces
the
old
android
built
in
com.android.browser
files
of
interest
include
the
cache
directory
browser
cache
and
the
app_chrome
default
directory
which
contains
many
important
sqlite3
databases
such
as
history
and
archived
history
browsing
history
in
urls
table
login
data
saved
credentials
in
logins
table
and
cookies
applications
may
also
save
data
on
the
sd
card
if
they
have
permissions
but
most
of
the
data
pertinent
to
the
application
state
can
often
be
found
in
its
data
data
directory
this
is
useful
if
you
want
to
manually
save
and
rollback
application
state
for
example
to
cheat
in
most
games
applications
can
also
register
with
the
android
backup
service
for
automated
backups
locally
or
to
google's
cloud
services
as
discussed
in
the
next
chapter
table
2
16
is
naturally
far
from
comprehensive
nonetheless
if
you're
interested
in
finding
specific
application
files
it's
fairly
straightforward
to
look
for
the
app
in
data
data
by
the
reverse
dns
notation
which
matches
the
apk
name
from
there
it's
a
simple
matter
of
grabbing
the
files
on
a
rooted
device
then
using
on
the
various
databases
and
to
identify
and
view
others
this
is
shown
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
device
forensics
through
data
data
on
a
rooted
device
you
can
easily
examine
application
data
directories
with
sqlite3
the
android
emulator
image
contains
a
binary
in
system
xbin
as
do
most
rooting
packages
for
reasons
which
should
now
be
fairly
obvious
taking
as
an
example
chrome
start
the
browser
and
navigate
to
any
site
of
your
choice
to
look
at
the
history
database
you
will
need
to
kill
the
process
since
it
holds
a
lock
on
the
database
from
there
a
simple
sql
query
reveals
all
output
2
8
examining
chrome's
history
with
demonstrating
the
same
on
the
contacts2
db
in
data
data
com.android.providers.contacts
databases
output
2
9
examining
the
call
log
another
useful
forensic
trick
which
merely
requires
the
device
to
be
unlocked
and
not
necessarily
rooted
is
to
connect
the
device
via
adb
to
a
host
and
issue
an
request
for
the
packages
of
interest
this
calls
on
the
the
which
by
virtue
of
running
as
system
can
access
data
data
with
no
restriction
and
not
only
read
all
the
files
of
any
app
but
also
conveniently
transport
them
to
the
host
the
backup
process
and
the
are
both
described
in
detail
in
the
next
chapter
and
volume
ii
respectively
when
initiating
a
backup
the
will
prompt
the
user
for
confirmation
hence
the
need
for
an
unlocked
device
if
the
operation
is
approved
a
backup
archive
is
created
on
the
host
with
an
ab
android
backup
extension
backups
can
be
easily
extracted
on
the
host
once
you
figure
out
the
file
format
as
explained
in
the
next
chapter
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
boot.html
backup
file
users
morpheus
documents
android
book
boot.html
backup
data
misc
the
data
misc
directory
contains
miscellaneous
data
and
configuration
directories
for
android's
subsystems
contrary
to
its
name
the
contents
include
some
of
the
most
important
files
in
the
system
more
detail
can
be
found
in
table
2
17
table
2
17
directories
in
data
misc
directory
contents
adb
trusted
adb
host
public
keys
as
of
jb
bluetooth
bluez
4.2
bluetooth
subsystem
configuration
files
bluedroid
bluetooth
subsystem
4.2
configuration
files
dhcp
contains
pid
file
of
dhcp
ctdent
daemon
and
any
active
lease
keychain
android
built
in
certificate
pins
and
blacklists
keystore
per
user
keystore
data
sensors
sensor
debug
data
sms
contains
the
sms
codes
database
systemkeys
asec
container
keys
appsonsd.sks
vpn
vpn
state
configuration
files
wifi
wi
fi
subsystem
configuration
files
e.g
wpa_suppolcant.conf
and
sockets
data
system
another
important
subdirectory
of
data
is
data
system
as
it
contains
files
critical
to
maintaining
the
state
of
device
as
can
be
expected
access
is
restricted
to
system:system
so
if
your
device
is
not
rooted
you
can't
see
any
of
the
files
shown
in
table
2
18
table
2
18
the
contents
of
data
system
directory
notes
appops.xml
used
by
the
appops
service
which
controls
application
permissions
batterystats.bin
used
by
the
batterystats
service
which
keeps
power
statistics
by
application
called_pre_boots.dat
used
by
the
activitymanager
to
hold
pre
boot
broadcast
receivers
device_policies.xml
configuration
file
used
by
the
devicepolicymanagerservice
dropbox
directory
used
by
the
dropbox
service
entropy.dat
system
entropy
store
used
by
entropymixer
for
random
number
generation
gesture.key
lockscreen
pattern
as
discussed
in
chapter
8
framework_atlas.config
used
by
the
assetatlasservice
which
packs
bitmaps
into
a
single
file
ifw
intent
firewall
rulebase
q.v
chapter
8
locksettings.db
lock
screen
settings
contains
device
lock
policy
q.v
chapter
8
netpolicy.xml
configuration
file
used
by
the
networkpolicymanagerservice
netstats
directory
used
to
hold
networkstatsservice
statistics
by
device
uid
or
xt
previous
versions
of
android
simply
dropped
the
files
in
data
system
packages.list
packagemanager
lists
of
all
packages
apks
installed
in
the
system
packages.xml
used
by
the
packagemanager
to
hold
metadata
on
all
installed
packages
password.key
lockscreen
pin
password
hash
as
discussed
in
chapter
8
procstats
directory
used
to
store
files
for
the
processstats
service
registered_services
directory
used
by
android.content.pm.registeredservicescache
usagestats
used
to
store
files
for
the
usagestats
service
in
particular
usage
history.xml
users
android's
multi
user
support
described
in
more
detail
in
chapter
8
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
vold
m:contains
decryption
keys
for
adopted
external
storage
drive
file
users
morpheus
documents
android
book
security.html
certs
file
users
morpheus
documents
android
book
connectivity.html
wpas
file
users
morpheus
documents
android
book
services
ii.html
appops
file
users
morpheus
documents
android
book
services
ii.html
batterystats
file
users
morpheus
documents
android
book
services
ii.html
activitymanager
file
users
morpheus
documents
android
book
services
ii.html
dpms
file
users
morpheus
documents
android
book
services
ii.html
dropbox
file
users
morpheus
documents
android
book
services
ii.html
entropymixer
file
users
morpheus
documents
android
book
security.html
lockscreen
file
users
morpheus
documents
android
book
services
ii.html
assetatlas
file
users
morpheus
documents
android
book
security.html
intentfw
file
users
morpheus
documents
android
book
security.html
lockscreen
file
users
morpheus
documents
android
book
services
ii.html
npms
file
users
morpheus
documents
android
book
services
ii.html
networkstatsservice
file
users
morpheus
documents
android
book
anatomy.html
packagemanager
file
users
morpheus
documents
android
book
anatomy.html
packagemanager
file
users
morpheus
documents
android
book
security.html
lockscreen
file
users
morpheus
documents
android
book
services
ii.html
procstats
file
users
morpheus
documents
android
book
services
ii.html
3rdparty
file
users
morpheus
documents
android
book
services
ii.html
usagestats
file
users
morpheus
documents
android
book
security.html
multiuser
cache
the
cache
partitions
is
defined
by
android
for
use
during
system
upgrades
system
updates
are
downloaded
to
this
location
and
the
boot
manager
is
aware
of
this
partition
especially
when
booted
in
recovery
upgrade
mode
otherwise
the
partition
is
normally
empty
if
you've
recently
downloaded
an
ota
update
you
will
likely
see
it
in
the
partition
until
it
is
installed
additionally
the
recovery
binary
and
the
system
specifically
the
class
make
use
of
this
partition
to
exchange
information
when
booting
into
recovery
or
update
as
shown
in
table
2
19
table
fs
cache
paths
in
the
cache
partition
recovery
define
path
usage
cache_log_dir
cache
recovery
directory
used
exclusively
by
recovery
binary
last_log_file
cache
recovery
last_log
log
of
previous
recovery
update
operation
log_file
cache
recovery
log
log
of
current
recovery
update
operation
command_file
cache
recovery
command
command
line
arguments
to
the
recovery
intent_file
cache
recovery
intent
intent
to
fire
after
recovery
is
complete
last_install_file
cache
recovery
last_install
log
of
last
installation
last_locale_file
cache
recovery
last_locale
language
settings
for
next
boot
the
recovery
and
update
processes
are
both
detailed
in
chapter
3
vendor
the
vendor
directory
is
purposed
to
contain
vendor
specific
modifications
to
android
doing
so
allows
for
an
efficient
process
of
updating
or
upgrading
of
the
os
when
the
need
arises
selected
system
components
are
hard
coded
to
check
vendor
before
or
in
addition
to
system
paths
as
shown
in
table
2
20
table
2
20
vendor
paths
searched
by
system
components
component
path
searched
package
manager
vendor
app
fonts
vendor
etc
fallback_fonts.xml
shared
libraries
vendor
lib
drm
libraries
vendor
lib
drm
vendor
lib
mediadrm
egl
libraries
vendor
lib
egl
frameworks
vendor
overlay
framework
firmware
vendor
firmware
audio
effects
vendor
etc
audio_effects.conf
the
contents
of
vendor
greatly
varies
between
devices
because
vendors
add
their
own
apps
and
components
as
they
see
fit
some
vendors
e.g
amazon
create
their
own
subdirectory
structure
vendor
amazon
to
include
support
for
their
custom
frameworks
and
features
e.g
the
kindle's
smart
volume
feature
which
adjusts
audio
volume
based
on
csv
files
for
each
output
device
placed
in
vendor
amazon
smartvolume
other
vendors
ignore
this
directory
altogether
and
just
add
their
modifications
to
system
this
is
especially
common
with
vendor
apps
and
in
practice
vendor
app
is
often
unused
even
in
the
case
of
amazon's
fireos
making
it
difficult
to
reduce
the
bloatware
of
vendor
and
carrier
supplied
apps
if
android
l
on
the
nexus
9
is
any
indication
however
future
versions
of
android
will
have
vendor
as
a
separate
partition
which
would
allow
it
to
be
updated
independently
of
the
rest
of
the
system
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
boot.html
recovery
the
sd
card
one
of
android's
strongest
features
is
its
built
in
support
for
sd
cards
a
feature
which
is
sorely
lacking
for
many
users
of
ios
most
phones
come
built
in
with
an
sd
card
albeit
not
an
easily
removable
one
and
tablets
have
a
readily
accessible
expansion
slot
most
sd
cards
are
formatted
with
the
vfat
or
fat32
filesystems
but
those
filesysystems
do
not
support
permissions
in
order
to
enforce
permissions
as
well
as
support
multi
user
configurations
starting
with
jellybean
android
resorts
to
a
somewhat
contrived
method
of
emulating
the
sdcards
via
fuse
file
systems
in
user
mode
fuse
allows
the
implementation
of
filesystems
in
a
user
mode
process
hence
the
semi
acronym
rather
than
in
the
kernel
a
small
kernel
level
shim
provides
generic
support
in
the
form
of
basic
file
system
registration
and
interfaces
to
vfs
but
the
actual
implementation
is
delegated
to
a
user
mode
process
system
bin
sdcard
the
mount
point
for
the
sd
card
has
changed
several
times
over
the
course
of
android's
evolution
and
is
currently
storage
ext_sd
on
devices
with
no
sd
card
the
mountpoint
is
often
an
emulated
one
pointing
to
a
directory
in
the
data
partition
usually
data
media
0
this
is
shown
in
output
fs
sd
along
with
the
default
directory
structure
output
2
10
the
sd
card
directories
the
standard
directories
are
also
defined
as
constants
of
the
class
note
that
3rd
party
applications
can
and
often
do
create
their
own
files
and
directories
in
the
sd
card
android
provides
an
emulated
sd
card
file
system
on
devices
which
do
not
have
an
sdcard
or
in
addition
to
the
real
sd
card
file
system
you
can
see
the
sd
card
file
systems
using
the
command
output
2
11
viewing
sd
card
file
systems
a
follow
up
to
discussion
focusing
on
the
technical
aspects
of
the
daemon
can
be
found
in
chapter
5
actually
ios
does
support
sd
cards
inherently
but
the
only
way
to
add
an
sd
card
is
to
use
the
camera
connection
kit
which
is
in
fact
little
more
than
a
usb
host
adapter
in
disguise
of
course
that
requires
the
eager
applite
to
fork
over
another
29.95
or
more
and
use
up
the
only
slot
on
the
device
which
just
so
happens
to
be
needed
for
power
and
usb
connectivity
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
developer.android.com
reference
android
os
environment.html
file
users
morpheus
documents
android
book
services.html
sdcard
protected
filesystems
with
android
being
the
open
system
that
it
is
come
challenges
to
application
deployment
a
technically
savvy
user
could
use
to
copy
bundles
between
devices
and
even
an
average
user
could
do
so
when
the
application
is
installed
to
an
sd
card
which
is
by
its
very
nature
removable
unlike
ios
who
was
designed
from
the
ground
up
with
support
for
drm
using
its
fairplay
mechanism
and
encrypting
application
code
by
default
android
slowly
adopted
mechanisms
to
achieve
the
same
ends
over
its
evolution
two
such
mechanisms
opaque
binary
blobs
obb
and
android
secure
storage
asec
are
covered
in
this
section
the
former
grew
out
of
a
need
to
bypass
restrictions
in
apk
and
the
latter
with
security
in
mind
obb
opaque
binary
blobs
google
play
restricts
the
size
of
an
apk
to
about
50mb
for
some
applications
this
could
be
a
serious
restriction
especially
if
they
require
or
process
multimedia
files
with
gingerbread
android
brought
support
for
the
opaque
binary
blob
obb
format
this
allows
developers
to
provide
additional
data
files
up
to
2gb
to
the
applications
in
the
form
of
opaque
binary
blobs
or
obb
files
which
can
archive
multiple
files
into
a
single
blob
and
provide
optional
encryption
implementation
wise
the
obb
is
exactly
that
opaque
meaning
its
contents
and
formatting
are
up
to
the
application
developer
to
decide
oftentimes
though
it
is
a
vfat
filesystem
image
which
is
mounted
by
a
call
to
the
volume
daemon
the
vold
then
calls
on
the
linux
kernel's
device
mapper
to
perform
a
loop
mount
the
device
mapper
also
supports
twofish
encryption
and
the
key
is
passed
to
it
during
the
obb
mount
request
applications
can
then
call
on
the
s
method
to
mount
the
obb
by
specifying
the
key
this
is
shown
in
figure
2
1
figure
2
1
the
obb
mounting
process
as
opaque
as
they
may
be
obb
files
still
need
to
have
some
type
of
metadata
to
allow
their
parsing
by
the
system
support
for
obbs
is
provided
in
the
native
system
lib
libandroidfw.so
and
inspecting
its
obbfile.cpp
implementation
reveals
the
metadata
is
in
a
trailer
rather
than
a
header
as
one
would
normally
expect
obbs
are
thus
parsed
by
seeking
to
the
end
of
the
file
and
working
backwards
uncovering
the
footer
fields
as
shown
in
figure
2
2
application
code
application
calls
the
storagemanager's
mountobb
rawpath
key
listener
android.os.storagemanager
the
storagemanager
connects
to
the
system_server's
mountservice
over
binder
system_server
mountservice
prepares
a
mountobbaction
obbstate
key
callinguid
and
executes
as
obb
mount
filename
key
callinguid
over
vold
connector
dev
socket
vold
system
bin
vold
calls
volumemanager
mountobb
img
key
ownergid
loop
create
idhash
asecfilename
loopdevice
sizeof
loopdevice
devmapper
create
idhash
loopdevice
key
nr_sec
dmdevice
sizeof
dmdevice
kernel
device
mapper
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
kernel
dm
figure
2
2
the
obb
trailer
signature
version
version
of
package
obb
belongs
to
package
version
version
currently
only
one
version
flags
no
flags
are
presently
defined
64
bit
salt
package
name
size
strlen
package
name
minimum
1
package
name
at
least
1
byte
footer
size
always
32
strlen
package
name
ksignature0x01
0x05
0x99
0x83
the
android
source
tree
contains
the
obbtool
which
is
a
shell
script
that
can
be
used
to
create
obb
files
on
linux
first
creating
an
empty
vfat
image
then
using
the
device
mapper
on
the
host
to
loop
mount
once
mounted
files
can
be
added
to
it
and
the
image
is
then
committed
when
umounted
the
sdk
additionally
provides
the
jobb6
utility
to
create
and
manipulate
obbs
the
framework
also
provides
the
obbscanner
class
which
can
be
used
to
obtain
basic
metadata
about
obb
files
using
jni
calls
to
the
aforementioned
libandroidfw.so
obbs
are
discussed
in
the
android
documentation
under
apk
expansion
files7
you
can
interact
with
through
the
command
to
list
mount
and
unmount
obbs
as
discussed
in
chapter
5
asec
android
secure
storage
android's
secure
storage
feature
commonly
referred
to
as
asec
provides
a
mechanism
for
applications
to
securely
deploy
onto
the
device
while
maintaining
a
reasonable
level
of
assurance
that
the
user
will
not
copy
them
to
another
device
a
process
often
referred
to
as
forward
locking
by
using
asec
containers
an
application
can
be
deployed
anywhere
the
feature
was
added
in
froyo
which
was
the
first
version
of
android
to
support
external
storage
such
as
sdcards
indeed
the
containers
may
reside
on
sdcard
but
are
unusable
without
the
key
naturally
the
keys
need
to
be
stored
somewhere
and
android
maintains
them
in
a
system
keystore
in
data
system
misc
systemkeys
hence
the
reasonable
level
of
assurance
the
root
user
can
read
the
encryption
keys
asec
containers
are
in
essence
encrypted
filesystem
images
which
begin
with
a
fixed
header
the
defined
in
system
vold
asec.h
as
shown
in
figure
2
3
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
developer.android.com
tools
help
jobb.html
http
developer.android.com
reference
android
content
res
obbscanner.html
http
developer.android.com
google
play
expansion
files.html
file
users
morpheus
documents
android
book
services.html
4
voldc
http
newandroidbook.com
src
android
kk
system
vold
asec.h
figure
2
3
the
asec
header
from
system
vold
asec.h
0xc0
0xde
0xf0
0x0d
magic
value
file
signature
1
version
currently
only
one
version
c_cipher
encryption
algorithm
0
none
1
twofish
2
aes
c_chain
chaining
unused
currently
only
0
none
c_opts
options
0
none
1
ext4
c_mode
mode
unused
currently
only
0
none
asec
creation
and
management
is
handled
by
the
volume
manager
vold
which
performs
operations
as
instructed
by
the
both
asec
creation
and
mounting
require
a
key
and
when
the
asec
container
is
mounted
vold
uses
the
kernel's
device
mapper
and
performs
a
loop
mount
passing
the
key
to
the
kernel's
dm
crypt
facility
through
a
ioctl
you
can
use
to
see
asec
mounts
with
vold's
command
line
described
in
chapter
5
supplying
detail
as
well
output
2
12
viewing
asec
file
systems
an
age
old
challenge
arising
from
encryption
is
key
management
in
other
words
where
does
one
store
the
encryption
key
to
the
asec
containers
if
the
key
itself
is
encrypted
one
runs
into
a
chicken
and
egg
problem
android
therefore
chooses
to
place
the
128
bit
blowfish
key
in
a
single
file
called
data
misc
systemkeys
appsonsd.sks
the
file
contains
the
key
in
simple
plaintext
but
is
set
to
be
readable
only
by
root
naturally
this
means
on
a
rooted
device
relying
on
asec
as
a
form
of
intellectual
property
protection
is
quite
useless
for
the
reader
interested
in
more
hands
on
experiments
with
asec
containers
the
android
explorations
blog
post
about
jb's
app
encryption8
makes
a
great
read
if
the
asec
feature
seems
similar
to
the
obbs
that
were
just
discussed
it
is
no
conincidence
both
features
rely
on
the
device
mapper
and
its
file
encryption
dm
crypt
to
both
create
and
access
the
data
an
asec
can
be
seen
as
a
logical
progression
of
obb
from
containing
application
extension
files
to
encompassing
the
entire
app
the
same
mechanism
can
be
expanded
to
the
full
filesystem
level
which
is
in
fact
what
android
uses
for
its
full
disk
encryption
feature
described
in
chapter
8
this
has
been
expanded
further
in
android
m's
adoptable
storage
enabling
encryption
of
external
usb
storage
through
dm
crypt
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
services.html
vold
file
users
morpheus
documents
android
book
kernel
dm
file
users
morpheus
documents
android
book
services.html
4
voldc
http
nelenkov.blogspot.com
2012
07
using
app
encryption
in
jelly
bean.html
file
users
morpheus
documents
android
book
security.html
dataenc
the
linux
seudo
filesystems
while
not
strictly
android
filesystems
the
linux
kernel
provides
three
other
filesystems
of
note
which
are
used
by
android
as
well
these
are
especially
important
for
our
discussion
in
chapter
7
which
discusses
among
other
things
the
linux
perspective
of
apps
that
is
tracing
and
analyzing
android
apps
as
the
processes
they
are
at
the
linux
level
this
section
is
not
meant
to
provide
a
comprehensive
reference
to
these
directories
rather
it
illustrates
the
particular
paths
which
are
of
interest
to
future
discussion
note
the
term
pseudo
filesystems
none
of
these
filesystems
are
real
in
the
sense
of
being
backed
by
actual
storage
instead
the
filesystems
are
maintained
directly
by
in
kernel
callbacks
so
that
upon
access
to
a
file
or
directory
a
corresponding
kernel
level
handler
function
is
invoked
this
means
that
these
filesystems
take
no
actual
space
in
kernel
memory
for
inode
and
dentry
representation
not
withstanding
further
each
access
to
a
file
or
directory
on
a
pseudo
filesystem
triggers
the
kernel
callback
function
so
the
files
and
directories
always
reflect
the
most
up
to
date
data
as
a
corrolary
file
sizes
are
meaningless
which
is
why
an
will
show
the
files
as
seemingly
empty
or
with
an
arbitrary
size
of
4k
a
pagesize
in
older
kernels
note
that
because
the
files
are
exported
by
kernel
code
kernel
proper
or
in
some
cases
modules
the
files
greatly
vary
with
kernel
versions
and
content
especially
in
sysfs
is
highly
hardware
dependent
most
pseudo
files
created
are
read
only
and
aim
to
provide
real
time
diagnostics
providing
user
space
with
a
mechanism
to
poll
on
variables
and
structures
which
would
otherwise
be
inaccessible
in
kernel
mode
some
files
however
are
actually
writable
which
provides
an
even
more
useful
ability
to
directly
affect
kernel
data
in
real
time
from
user
space
contrary
to
certain
registry
based
systems
wherein
changes
require
excruciating
manipulation
of
hidden
and
oft
undocumented
keys
or
values
not
to
mention
a
reboot
changes
made
to
files
in
the
pseudo
filesystems
where
allowed
are
enforced
immediately
but
by
default
do
not
persist
across
a
system
reboot
that
however
is
seldom
a
concern
because
it's
a
trivial
matter
to
re
enforce
these
changes
during
system
startup
which
is
in
fact
what
significant
portions
of
the
android
init.rc
scripts
detailed
in
chapter
4
are
all
about
cgroupfs
the
linux
kernel
provides
an
important
resource
control
mechanism
called
cgroups
a
cgroup
is
a
for
one
or
more
threads
allowing
operations
and
policy
settings
to
apply
on
the
group
as
a
whole
a
fairly
comprehensive
documentation
on
cgroups
can
be
found
in
the
linux
kernel
documentation9
to
facilitate
the
placement
of
threads
into
groups
cgroups
expose
themselves
via
pseudo
file
systems
it
then
becomes
a
simple
matter
to
add
a
thread
to
a
group
by
writing
into
those
files
though
highly
versatile
and
usable
in
oh
so
many
ways
android
uses
cgroups
in
a
fairly
limited
manner
requiring
it
only
for
cpu
accounting
and
thread
scheduling
output
2
13
cgroup
related
mounts
on
a
nexus
5
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
linuxlens.html
proc
file
users
morpheus
documents
android
book
services.html
rcfiles
https
www.kernel.org
doc
documentation
cgroups
cgroups.txt
bionic
sets
up
accounting
for
every
process
it
starts
therefore
applying
to
every
process
on
the
system
through
acct
sys
fs
cgroup
memory
is
accessed
by
the
via
and
its
setswappiness
jni
method
last
but
not
least
is
the
dev
cpuctl
directory
despite
being
in
dev
this
is
a
cgroup
directory
set
up
by
android's
scheduling
policy
when
init
starts
it
sets
up
the
directory
and
creates
subdirectories
therefore
scheduling
groups
for
system
tasks
dev
cpuctl
tasks
foreground
apps
dev
cpuctl
apps
tasks
and
background
apps
dev
cpuctl
apps
bg_non_interactive
tasks
each
group
is
assigned
a
number
of
cpu
shares
and
given
an
upper
bound
on
execution
time
this
prevents
any
wayward
or
misbehaving
dsp
from
impacting
execution
as
a
whole
the
dev
cpuctl
configuration
performed
in
init.rc
is
shown
in
the
following
listing
listing
2
2
setting
up
the
cpuctl
cgroups
debugfs
the
debug
filesystem
is
strictly
intended
for
kernel
level
debugging
information
drivers
and
subsystems
alike
are
free
to
dump
droves
of
debugging
information
into
the
filesystem
which
as
with
the
other
pseudo
filesystems
if
the
filesystem
is
mounted
the
myriad
debugging
information
can
be
read
like
any
other
file
note
however
the
if
the
debug
filesystem
need
not
necessarily
be
mounted
and
the
kernel
could
possibly
be
compiled
without
debugfs
support
if
the
kernel
supports
it
the
filesystem
can
be
mounted
using
a
simple
command
line
usually
in
init.hardware.rc
like
so
though
any
mountpoint
can
be
chosen
since
it's
so
useful
it's
not
uncommon
to
find
a
symbolic
link
from
the
root
as
is
the
default
in
the
emulator
image
from
d
to
the
mount
point
the
contents
of
the
debugfs
are
highly
dependent
on
the
kernel
version
and
whichever
debug
features
have
been
implemented
in
it
the
following
table
lists
common
entries
found
in
android
kernels
table
2
21
entries
in
the
sys
kernel
debug
directory
entry
purpose
binder
plentiful
data
on
the
eponymous
android
ipc
mechanism
tracing
unbelievably
useful
copious
debugging
and
tracing
information
generated
by
the
linux
kernel's
mechanism
wakeup
sources
kernel
level
wakelocks
used
by
drivers
or
the
android
system
to
prevent
device
sleep
kdswhu
3duwlwlrqv
loh6
vwhpv
functionfs
dev
usb
ffs
adb
usb
functionality
in
android
is
controlled
by
a
special
gadget
driver
which
often
requires
dynamic
reconfiguring
according
to
user
selection
e.g
connect
device
for
usb
debugging
as
mass
storage
etc
through
init
as
explained
in
chapter
4
the
traditional
driver
in
kernels
before
l
needs
to
export
its
reconfiguration
parameters
through
sysfs
doing
so
is
one
of
the
reasons
it
is
considered
bloated
and
in
need
of
revamping
enter
functionfs
a
relatively
new
addition
to
the
linux
kernel
sometime
in
2010
this
is
a
generic
file
system
provided
by
the
linux
kernel
to
provide
a
way
for
drivers
to
pick
up
configuration
changes
from
user
space
the
filesystem
can
be
thought
of
a
complement
to
sysfs
in
that
whereas
the
latter
is
designed
for
outputting
kernel
variables
and
driver
information
to
user
mode
the
former
is
designed
for
input
the
root
user
can
use
to
create
directories
which
in
turn
will
create
corresponding
kernel
objects
which
can
then
be
initialized
from
user
space
by
further
write
2
operations
to
the
pseudo
files
in
the
directories
procfs
proc
the
procfs
filesystem
derives
its
name
from
its
initial
purpose
to
provide
a
directory
based
view
of
processes
running
in
the
system
the
idea
originated
in
plan
9
operating
system
and
linux
quickly
adopted
it
and
modified
it
to
provide
a
plethora
of
information
on
processes
threads
and
other
system
wide
diagnostics
in
fact
some
argue
that
proc
has
become
a
virtual
junkyard
of
diagnostic
files
because
linux
originally
provided
pseudo
file
interfaces
for
this
directory
only
regardless
of
whether
or
not
proc
provides
too
much
of
a
good
thing
it
is
undeniable
that
it
makes
for
a
highly
important
filesystem
many
linux
utilities
e.g
top
netstat
lsof
and
ifconfig
as
well
as
android
tools
e.g
procrank
librank
depend
on
it
as
the
source
of
diagnostic
information.linux
keeps
a
fairly
detailed
and
updated
man
page
for
we
discuss
the
usage
of
procfs
for
debugging
in
chapter
7
pstore
sys
fs
pstore
the
mechanism
is
a
linux
kernel
feature
introduced
in
3.5
which
allows
the
kernel
to
set
aside
some
ram
as
a
persistent
store
this
is
used
for
one
purpose
capture
kernel
panic
data
a
panic
indicates
an
internal
kernel
memory
corruption
which
may
affect
the
filesystem
logic
as
such
any
write
to
the
filesystem
could
worsen
things
and
lead
to
filesystem
corruption
as
well
normally
un
x
system
dump
panic
data
to
the
swap
partition
which
isn't
meant
to
survive
reboot
anyway
but
android
has
no
swap
and
therefore
the
only
reliable
solution
is
to
set
aside
some
physical
memory
i.e
a
dedicated
portion
of
the
ram
and
have
the
kernel
log
its
crash
data
the
bare
minimum
at
least
to
there
the
kernel
then
automatically
performs
a
warm
reboot
that
is
a
reboot
without
a
power
cycle
which
means
that
the
ram
does
not
undergo
full
re
initialization
during
reboot
the
kernel
checks
the
persistent
store
for
any
relics
of
its
past
incarnation
and
if
any
are
found
they
are
made
available
through
sys
fs
pstore
in
older
versions
of
android
this
functionality
was
provided
by
an
androidism
i.e
specific
android
kernel
hack
called
the
ram
console
traces
of
this
can
still
be
found
in
init.rc
files
capturing
data
from
proc
apanic_console
and
proc
apanic_threads
and
moving
them
to
data
dontpanic
with
a
wink
to
the
hitchhiker's
guide
to
the
galaxy
with
the
advent
of
the
pstore
functionality
this
is
deprecated
in
favor
of
sys
fs
pstore
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
init.html
initusb
file
users
morpheus
documents
android
book
linuxlens.html
selinuxfs
sys
fs
selinux
the
selinuxfs
like
the
debugfs
is
traditionally
mounted
under
sys
but
is
not
part
of
the
sysfs
filesystem
per
se
the
filesystem
has
been
devised
for
exclusive
use
by
selinux
and
it
stores
important
files
relating
to
the
installed
policy
selinux
is
discussed
in
more
detail
in
chapter
8
but
at
a
bird's
eye
view
the
most
important
files
in
this
filesystem
are
policy
which
provides
the
loaded
compiled
binary
form
security
policy
and
the
enable
pseudo
file
which
toggles
enforcement
of
the
policy
and
is
in
fact
what
the
tools
use
output
2
15
demonstrating
enforcement
of
an
selinux
policy
experiment
testing
the
persistent
store
on
android
l
on
an
android
l
or
any
system
with
a
kernel
version
of
3.10
or
later
it
is
very
likely
that
the
pstore
is
enabled
by
default
to
see
if
it
is
check
for
the
existence
of
sys
fs
pstore
or
any
other
mount
point
specifying
the
file
system
output
2
14
locating
the
pstore
if
your
kernel
rebooted
and
or
crashed
recently
the
mount
point
will
be
populated
with
a
single
file
console
ramoops
which
holds
the
last
output
the
file's
permissions
are
set
in
the
init.rc
and
make
it
readable
by
the
which
is
a
member
of
the
group
you
can
then
to
get
the
last
output
of
the
kernel
ring
buffer
right
up
to
the
reboot
if
you
cold
booted
your
system
however
the
directory
may
be
empty
in
this
case
you
can
either
reboot
your
system
using
or
if
you
dare
force
a
kernel
crash
using
the
command
which
will
make
the
file
appear
the
proc
sysrq
trigger
pseudo
file
is
an
incredibly
useful
but
dangerous
proc
entry
the
file
is
writable
only
and
ing
a
single
key
into
it
simulates
the
functionality
of
pressing
the
little
known
key
along
with
alt
and
the
key
specified
a
magic
key
combination
which
works
only
from
the
console
the
functionality
is
meant
as
an
emergency
channel
when
the
system
is
non
responsive
since
requests
are
processed
by
the
keyboard
interrupt
handler
which
runs
at
the
highest
possible
priority
exercise
extreme
caution
when
handling
this
file
as
most
of
the
options
there
are
for
emergency
use
only
and
may
be
destructive
kdswhu
3duwlwlrqv
loh6
vwhpv
file
users
morpheus
documents
android
book
security.html
sysfs
sys
the
sysfs
may
be
alphabetically
last
but
in
order
of
importance
it
is
second
only
to
procfs
the
sysfs
was
introduced
in
kernel
2.6
as
a
complement
to
procfs
in
an
effort
to
declutter
proc
and
move
hardware
and
module
related
configuration
files
to
a
separate
location
with
more
structure
under
sys
you
can
find
therefore
a
cleaner
separation
of
pseudofiles
by
category
the
subdirectories
you'll
see
are
shown
in
table
2
22
table
2
22
the
subdirectories
classes
in
sys
subdirectory
contents
block
block
i
o
layer
control
files
one
subdirectory
per
block
device
containing
parameters
such
as
the
i
o
scheduler
bus
devices
by
bus
connection
one
subdirectory
per
bus
type
e.g
i2c
mmc
soc
class
devices
by
class
one
directory
per
class
type
e.g
input
sound
dev
devices
by
device
type
block
or
char
devices
devices
in
device
tree
compatible
form
firmware
used
for
firmware
update
capable
devices
fs
used
by
filesystem
drivers
some
subdirectories
here
are
mountpoints
e.g
pstore
selinux
are
mount
points
for
other
pseudo
filesystems
as
previously
discussed
others
provide
exported
parameters
and
statistics
by
filesystems
such
as
ext4
kernel
various
kernel
parameters
by
subsystem
debug
serves
as
mount
point
for
debugfs
module
one
subdirectory
per
module
containing
module
statistics
and
where
applicable
module
parameters
viewable
and
sometimes
settable
from
user
space
power
power
management
statistics
and
settings
the
android
wakelocks
are
implemented
here
via
the
wake_lock
and
wake_unlock
pseudo
files
hardware
configurations
greatly
differ
in
between
devices
and
therefore
so
do
the
actual
contents
presented
by
the
corresponding
sysfs
files
the
android
frameworks
are
shielded
from
device
specific
idiosyncrasies
thanks
to
the
hardware
abstraction
layer
system
lib
libhardware.so
and
its
plugins
which
wrap
the
calls
to
the
specific
files
with
more
generic
api
calls
the
hal
is
discussed
in
more
detail
in
volume
ii
other
device
entrlhv
are
somewhat
more
standardized
these
include
the
cpu
governor
frequency
scaling
data
in
sys
devices
system
cpu
cpu
cpufreq
and
the
vibrator
on
devices
which
have
one
in
sys
class
timed_output
vibrator
for
a
quick
fun
experiment
you
might
want
to
try
to
echo
a
large
value
say
5000
to
the
enable
sysfs
entry
in
that
directory
summary
this
chapter
provided
a
walkthrough
of
android's
partitions
and
filesystems
in
particular
we
focused
on
the
partitions
commonly
found
in
android
devices
noting
all
but
a
few
are
actually
unmountable
we
then
examined
the
two
main
filesystems
system
and
data
whose
contents
subdirectory
by
subdirectory
were
detailed
lastly
the
chapter
touched
on
the
linux
pseudo
filesystems
which
contain
a
cornocupia
of
diagnostics
and
configuration
files
those
files
with
an
emphasis
on
their
use
in
debugging
will
be
revisited
throughout
this
book
especially
in
chapter
7
the
next
chapter
builds
on
this
one
as
it
explores
android's
boot
and
recovery
processes
the
non
mountable
partitions
and
in
particular
aboot
and
boot
will
be
examined
in
detail
as
they
play
the
part
in
starting
up
the
device
the
mountable
but
rarely
used
cache
will
be
revealed
as
central
to
ota
updates
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
linuxlens.html
references
1
xda
developers
on
f2fs
http
forum.xda
developers.com
showthread.php
t
2697069
2
samsung
f2fs
presentation
http
elinux.org
images
1
12
elc2013_hwang.pdf
3
linux
weekly
news
on
f2fs
http
lwn.net
articles
518988
4
xda
developers
el
grande
partition
table
reference
http
forum.xda
developers.com
showthread.php
t
1959445
5
companion
article
htc
weaksauce
exploit
http
newandroidbook.com
articles
htc.html
6
android
developer
on
the
jobb
utility
http
developer.android.com
tools
help
jobb.html
7
android
developer
on
apk
expansion
files:http
developer.android.com
google
play
expansion
files.html
8
android
explorations
on
jb
app
encryption
http
nelenkov.blogspot.com
2012
07
using
app
encryption
in
jelly
bean.html
9
linux
kernel
documentation
on
cgroups
https
www.kernel.org
doc
documentation
cgroups
cgroups.txt
or
the
kernel
sources
kdswhu
3duwlwlrqv
loh6
vwhpv
http
forum.xda
developers.com
showthread.php
t
2697069
http
elinux.org
images
1
12
elc2013_hwang.pdf
http
lwn.net
articles
518988
http
forum.xda
developers.com
showthread.php
t
1959445
http
newandroidbook.com
articles
htc.html
http
developer.android.com
tools
help
jobb.html
http
developer.android.com
google
play
expansion
files.html
http
nelenkov.blogspot.com
2012
07
using
app
encryption
in
jelly
bean.html
https
www.kernel.org
doc
documentation
cgroups
cgroups.txt
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
iii
android
boot
backup
recovery
just
like
with
their
desktop
counterparts
most
users
take
the
boot
process
of
their
mobile
device
for
granted
they
power
on
the
device
wait
for
a
few
seconds
and
the
home
or
lock
screen
appears
to
greet
them
the
only
time
this
sequence
changes
is
in
cases
where
the
device
is
being
updated
flashed
hasn't
enough
battery
charge
or
in
those
rare
cases
where
boot
fails
and
users
find
their
device
bricked
while
the
boot
process
of
mobile
devices
follows
the
general
lines
of
desktops
it
is
invariably
more
complicated
and
involves
more
parts
add
to
that
the
myriad
device
types
and
vendors
in
the
android
landscape
and
you
get
a
process
that
is
quite
lengthy
and
quite
idiosyncratic
for
each
device
and
vendor
this
chapter
aims
to
document
this
process
and
focus
on
the
common
denominators
between
devices
we
begin
with
an
examination
of
android
software
images
which
are
flashed
to
the
device
partitions
we
discussed
in
the
previous
chapter
these
can
be
manually
downloaded
but
are
often
fetched
by
the
device
in
an
over
the
air
ota
update
while
vendors
are
free
in
creating
and
formatting
the
images
most
follow
a
general
structure
consisting
of
the
boot
loader
the
the
boot
image
containing
the
kernel
and
the
ram
disk
and
the
sparse
system
images
which
we
discuss
in
turn
we
follow
these
components
as
they
each
play
their
role
in
the
boot
and
or
recovery
process
after
discussing
the
boot
process
it
makes
sense
to
discuss
its
inverse
shutdown
while
at
the
linux
level
shutdown
and
reboot
are
simple
matters
handled
by
a
kernel
system
call
android's
handling
is
more
intricate
accommodating
for
androidisms
such
as
presenting
the
power
menu
and
booting
into
recovery
mode
the
discussion
of
booting
to
recovery
begs
more
detail
about
just
how
recovery
is
performed
as
well
as
the
process
of
applying
updates
so
the
next
section
is
where
ota
update
packages
and
process
are
described
lastly
we
consider
custom
firware
images
roms
as
they
are
often
erroneously
referred
to
and
discuss
how
the
key
components
can
be
upgraded
or
entirely
replaced
we
leave
out
the
natural
sequitur
to
this
discussion
device
rooting
techniques
for
chapter
8
which
deals
with
security
aspects
of
android
this
chapter
makes
use
of
a
utility
for
viewing
and
unpacking
android
system
images
for
your
convenience
both
source
and
a
precompiled
binary
are
freely
available
for
download
in
one
package1
technically
rom
implies
read
only
memory
which
cannot
be
updated
or
in
the
case
of
eeprom
can
be
erased
and
rewritten
under
special
circumstances
android
devices
do
have
a
true
boot
rom
component
but
the
rest
of
the
boot
process
is
performed
from
flash
partitions
which
can
be
easily
written
to
assuming
permissions
hold
file
users
morpheus
documents
android
book
boot.html
images
file
users
morpheus
documents
android
book
bootldr
file
users
morpheus
documents
android
book
bootimg
file
users
morpheus
documents
android
book
boot.html
kernel
file
users
morpheus
documents
android
book
boot.html
ramdisk
file
users
morpheus
documents
android
book
boot.html
simg
file
users
morpheus
documents
android
book
boot.html
rebooting
file
users
morpheus
documents
android
book
boot.html
ota
file
users
morpheus
documents
android
book
boot.html
otaprocess
file
users
morpheus
documents
android
book
boot.html
customizing
file
users
morpheus
documents
android
book
security.html
rooting.html
http
newandroidbook.com
files
imgtool.tar
android
images
various
android
devices
each
have
their
own
specific
images
these
are
the
system
images
provided
by
the
vendor
which
are
meant
to
be
flashed
as
the
factory
default
distribution
of
android
onto
the
device
the
images
are
comprised
of
several
files
which
are
flashed
into
their
respective
partitions
the
boot
loader
which
provides
the
application
processor
bootstrap
code
this
code
is
normally
responsible
for
finding
and
loading
the
boot
image
but
also
handles
firmware
updates
and
booting
into
recovery
mode
most
bootloaders
also
implement
a
small
usb
stack
over
which
they
can
communicate
with
the
host
for
purposes
of
controlling
the
boot
or
update
process
normally
over
fastboot
the
boot
loader
usually
gets
flashed
into
the
aboot
partition
though
on
some
devices
e.g
htc
this
may
be
called
hboot
the
boot
image
which
normally
consists
of
the
kernel
and
a
ram
disk
and
is
used
to
load
the
system
assuming
normal
boot
the
ram
disk
will
serve
as
the
root
filesystem
for
android
and
its
init.rc
and
related
files
will
provide
directives
as
to
how
to
load
the
rest
of
the
system
partitions
the
boot
image
is
flashed
into
the
boot
partition
the
recovery
image
similarly
consisting
of
the
kernel
and
a
different
ram
disk
and
is
used
to
load
the
system
into
recovery
mode
in
cases
where
normal
boot
has
failed
or
in
case
of
an
ota
update
this
gets
flashed
into
the
recovery
partition
the
system
partition
which
is
the
full
android
system
including
the
google
supplied
binaries
and
frameworks
as
well
as
any
provided
by
the
vendor
and
or
the
carrier
the
data
partition
containing
the
factory
default
data
files
which
support
the
binaries
in
the
system
partition
this
image
also
provides
the
factory
default
state
to
which
the
device
is
restored
when
effaced
google
makes
the
system
images
for
the
nexus
devices
available
at
their
factory
image
repository2
you
are
encouraged
to
follow
along
with
the
hands
on
experiments
in
this
chapter
with
those
images
or
your
own
device
if
rooted
refer
to
the
method
in
chapter
2
for
safely
extracting
the
images
from
the
raw
partitions
of
a
live
device
to
unpack
a
google
stock
image
follow
these
steps
download
the
image
from
google's
factory
images
repository
this
will
be
a
gzipped
tar
file
with
a
name
in
the
following
convention
piscine_devicename
build
factory
first_32_bits_of_sha1_checksum.tgz
unpack
the
file
using
tar
this
will
look
something
like
the
following
output
output
3
1
unpacking
a
factory
image
for
a
nexus
5
next
we
discuss
each
of
these
components
with
the
exception
of
the
radio
baseband
in
turn
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
https
developers.google.com
android
nexus
images
file
users
morpheus
documents
android
book
filesystems.html
showgpt
the
boot
loader
android
vendors
are
free
to
implement
their
own
boot
loaders
though
most
samsung
being
a
notable
exception
choose
the
lk
little
kernel
bootloader
the
lk
bootloader
is
not
part
of
the
android
source
tree
but
is
available
at
least
in
part
from
codeaurora3a
and
from
googlesource3b
lk
as
as
its
name
implies
a
minimal
implementation
of
boot
functionality
the
name
is
somewhat
misleading
however
as
it
is
not
a
linux
kernel
but
a
bootable
arm
binary
image
lk
concerns
itself
with
only
the
minimal
functions
one
expects
from
a
boot
loader
these
include
basic
hardware
support
provided
by
lk's
dev
basic
common
drivers
such
as
framebuffer
buttons
and
usb
target
platform
soc
chipset
drivers
and
target
device
specific
subtrees
without
this
none
of
the
other
requirements
can
be
sated
finding
and
booting
the
kernel
the
raison
d'etre
of
any
boot
loader
locating
the
bootimg
discussed
next
and
parsing
its
components
kernel
image
ramdisk
and
device
tree
then
transferring
control
to
the
kernel
with
a
given
command
line
this
is
carried
out
by
app
aboot
basic
ui
for
cases
wherein
the
user
interrupts
the
normal
automatic
boot
sequence
commonly
via
or
pressing
button
combinations
immediately
after
device
power
on
aboot
provides
a
simple
text
interface
which
the
user
can
navigate
using
the
physical
buttons
on
the
device
using
volume
up
down
to
navigate
and
the
power
button
to
select
but
no
touchscreen
functionality
console
support
though
most
retail
devices
have
no
readily
available
console
development
boards
provide
console
functionality
through
serial
ports
rs232
uart
lk's
lib
console
called
from
app
shell
provides
a
command
interpreter
running
in
a
separate
thread
and
support
for
extending
the
command
list
lib
gfxconsole
provides
rudimentary
graphics
functions
such
as
font
support
usb
target
support
which
allows
the
bootloader
to
communicate
with
its
host
via
a
simple
protocol
called
fastboot
and
discussed
later
in
this
chapter
a
skeleton
implementation
can
be
found
in
app
aboot
fastboot.c
with
vendors
free
to
add
their
own
extension
oem
commands
flash
partition
support
in
order
to
enable
the
bootloader
to
erase
or
overwrite
partitions
as
required
during
upgrade
or
recovery
lk
also
contains
basic
filesystem
support
through
lib
fs
digital
signature
support
to
provide
support
for
loading
digitally
signed
images
with
ssl
certificates
lk
incorporates
portions
of
the
openssl
project
in
its
lib
openssl
subtree
surprisingly
it
is
possible
to
get
a
console
connection
to
some
devices
for
example
google's
nexi
through
one
of
the
last
places
one
would
suspect
the
headphone
port
there
is
ample
documentation
on
how
to
build
your
own
headphone
jack
to
rs232
for
the
nexus
44a
and
nexus94b
kdswhu
rrw
dfnxs
dqg
5hfryhu
https
www.codeaurora.org
cgit
quic
la
kernel
lk
tree
app
aboot
https
android.googlesource.com
kernel
lk
a9b07bbae16a0b1b6de07ec3a3e2005c99043757
file
users
morpheus
documents
android
book
boot.html
fastboot
http
www.accuvant.com
blog
building
a
nexus
4
uart
debug
cable
http
osdevnotes.blogspot.com
2014
11
64
bit
arm
oskernelsystems
development.html
the
boot
loader
image
boot
loaders
can
eh
updated
and
flashed
just
like
other
system
images
though
the
format
is
not
officially
documented
the
releasetools.py
script
in
some
of
the
device
specific
directories
of
the
android
source
tree
provides
the
header
format
this
enables
to
parse
and
extract
boot
images
as
shown
in
this
output
examining
google's
nexus
5
boot
loader
output
3
2
the
nexus
5
boot
loader
image
as
you
can
see
in
the
output
the
boot
loader
image
is
comprised
of
several
sub
images
each
of
which
is
meant
to
be
flashed
to
a
specific
partition
the
boot
loader
itself
is
in
aboot
which
is
the
application
processor
boot
loader
the
image
also
contains
the
resource
power
management
bootstrap
rpm
arm
trustzone
image
tz
and
secondary
boot
loader
sbl1
discussed
later
in
this
chapter
none
of
the
file
formats
of
the
boot
loader
components
are
documented
these
are
all
highly
architecture
dependent
and
the
ones
in
the
example
above
pertain
to
qualcomm's
snapdragon
processor
the
msm
chipset
the
focus
of
this
discussion
aboot
is
incorrectly
recognized
by
as
an
hitachi
sh
big
endian
coff
object
when
in
fact
it
is
formatted
with
a
proprietary
header
spanning
40
or
in
some
cases
more
bytes
the
header
format
is
shown
in
table
3
1
table
3
1
the
aboot
proprietary
header
offset
field
contains
0x00
magic
0x00000005
constant
0x04
version
version
2
or
3
0x08
null
field
0x0c
image
base
virtual
memory
address
to
load
rest
of
image
into
0x10
image
size
size
of
aboot
image
0x14
code
size
size
of
aboot
code
size
0x18
last
code
addr
image
base
code
size
0x1c
signature
size
size
of
digital
signature
usually
0x100
256
bytes
0x20
last
mapped
addr
last
code
addr
signature
size
0x24
certificate
chain
size
of
certificate
chain
if
any
following
the
header
is
an
arm
bootable
image
which
is
mapped
into
memory
at
the
address
specified
by
the
header
at
its
very
base
are
the
arm
exception
vectors
these
are
a
series
of
branch
instructions
which
define
what
addresses
the
processor
will
automatically
jump
to
in
certain
cases
e.g
interrupts
exceptions
and
aborts
the
very
first
of
those
instructions
the
reset
handler
defines
lk's
entry
point
the
following
experiment
shows
how
you
can
remove
the
aboot
header
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
boot.html
firmwareboot
experiment
removing
the
header
from
the
aboot
image
if
you
have
a
nexus
5
rom
update
using
on
its
bootloader.img
as
shown
in
output
3
2
will
extract
aboot
otherwise
on
a
rooted
device
you
can
obtain
a
partition
dump
by
the
method
shown
in
chapter
2
substituting
dev
mmbclk0
in
that
example
with
the
partition
of
aboot
likely
dev
block
mmcblk0p6
one
way
or
another
you
will
end
up
with
aboot
as
a
file
output
3
3
making
sense
of
aboot
using
the
arm
instructions
can
be
recognized
by
the
eaxxxxxx
form
ea
is
the
opcode
for
the
arm
b
ranch
instruction
exception
vectors
in
armv7
contain
seven
32
bit
slots
so
the
reset
handler
is
usually
instruction
is
usually
ea000006
as
above
6
4
bytes
away
from
next
instruction
if
you
cut
off
the
first
40
bytes
of
the
file
using
the
resulting
file
can
be
loaded
into
a
disassembler
fairly
easily
cut
again
after
codesize
bytes
to
remove
the
signature
and
the
certificates
which
should
yield
files
that
match
the
values
of
the
header
namely
output
3
4
getting
the
certificates
from
a
bootloader
image
you
will
need
to
rebase
the
image
to
0x0f900000
or
whatever
the
field
at
offset
12
states
reverse
engineering
of
the
boot
loader
is
outside
the
scope
of
this
chapter
but
can
be
found
in
a
companion
article
on
the
book's
web
site5
boot
loader
locking
the
boot
loader
on
android
devices
is
usually
locked
meaning
it
will
refuse
to
flash
or
boot
updates
which
are
not
digitially
signed
the
vendor
provides
its
public
key
in
rom
and
the
key
can
be
used
to
establish
a
chain
of
trust
throughout
the
boot
process
this
way
all
boot
components
from
the
rpm
through
the
sbl
to
the
android
boot
loader
can
be
verified
reverse
engineering
of
those
components
often
reveals
they
contain
an
x
509v3
certificate
as
well
as
the
openssl
support
needed
to
verify
keys
boot
loader
locks
are
not
to
be
confused
with
sim
locks
which
carriers
often
enforce
to
ensure
that
a
phone
purchased
from
them
will
only
operate
on
their
network
rules
in
several
countries
already
require
carriers
to
unlock
devices
in
certain
cases
but
no
such
rules
force
the
sale
of
devices
with
unlocked
boot
loaders
kdswhu
rrw
dfnxs
dqg
5hfryhu
file
users
morpheus
documents
android
book
filesystems.html
showgpt
http
newandroidbook.com
articles
aboot.html
thus
depending
on
the
vendor
a
user
may
or
may
not
be
able
to
unlock
the
phone
some
vendors
refuse
to
do
so
whereas
in
others
e.g
google's
nexus
5
and
the
nvidia
shield
it's
a
simple
a
matter
as
issuing
a
fastboot
oem
unlock
command
this
is
shown
in
output
3
5
below
output
3
5
unlocking
the
nvidia
shield
bootloader
other
vendors
like
htc
take
a
middle
ground
and
have
the
device
issue
a
challenge
in
the
form
of
a
cryptographic
token
which
must
be
responded
to
with
a
specific
response
some
vendors
sell
both
locked
and
unlocked
phones
samsung
being
the
notable
example
as
of
l
at
least
in
the
nexus
9
android's
default
setting
app
allows
the
user
to
select
whether
or
not
the
device
is
unlockable
through
settings
developer
options
the
user
choice
toggles
a
bit
in
a
partition
also
readable
by
the
bootloader
unlocking
the
bootloader
whenever
possible
mandates
that
the
boot
loader
entirely
efface
the
data
partition
this
is
because
unlocking
the
bootloader
entirely
compromises
the
device's
security
an
adversary
gaining
possession
of
the
device
can
flash
an
update
which
will
bypass
any
user
pin
or
pattern
or
just
copy
the
data
partition
and
steal
all
the
personal
information
found
there
if
the
boot
loader
cannot
be
unlocked
however
then
the
device
in
theory
should
be
secure
with
no
rooting
method
in
practice
however
android
is
not
without
its
share
of
exploits
as
a
matter
of
fact
at
the
time
of
writing
a
linux
kernel
exploit
which
plagues
versions
below
3.13
has
given
rise
to
a
root
exploit
first
publicized
by
geohot
known
as
towelroot
which
affects
all
android
devices
on
the
market
this
is
but
one
of
several
exploits
commonly
referred
to
as
one
click
which
are
akin
to
jailbreaking
on
ios
these
exploits
as
well
as
rooting
in
general
are
discussed
in
chapter
21
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
oneclick
boot
images
android's
boot
images
contain
the
core
components
of
the
operating
system
the
kernel
and
the
ram
disk
the
boot
images
created
with
in
the
android
source
tree
bundle
both
with
a
minimal
header
the
kernel
command
line
a
small
hash
and
an
optional
second
stage
boot
loader
which
in
practice
is
unused
the
images
are
recognizable
by
their
magic
similar
to
the
bootloader
magic
discussed
earlier
vendors
are
not
strictly
required
to
use
this
boot
image
format
in
their
devices
and
so
results
might
vary
with
device
htc
for
example
prepends
its
own
header
likely
for
use
by
their
custom
boot
loader
hboot
you
can
usually
spot
the
boot
image
header
thanks
to
its
magic
value
like
so
output
3
6
the
htc
boot
image
header
and
then
use
dd
to
skip
the
custom
header
in
the
example
above
dd
bs
0x100
skip
1
the
format
of
the
boot
image
is
well
documented
in
bootimg.h
as
shown
in
listing
3
1
listing
3
1
the
boot_img_hdr
kdswhu
rrw
dfnxs
dqg
5hfryhu
the
kernel
the
linux
kernel
unlike
most
os
kernels
is
mostly
compressed
the
kernel
file
format
known
as
a
consists
of
self
extracting
code
which
unpacks
the
rest
of
the
kernel
image
in
memory
as
compression
algorithms
have
greatly
advanced
there
are
multiple
options
for
compression
which
can
be
decided
during
the
build
process
make
config
as
shown
in
table
3
2
table
3
2
kernel
file
formats
magic
compression
notes
x1f
x8b
x08
x00
x00
x00
x00
x00
gzip
most
common
compression
format
x89lzox00
x0d
x0a
x1a
x0a
lzo
faster
but
10
15
less
efficient
than
gzip
used
by
samsung
the
kernel
always
starts
with
the
self
extracting
code
portion
which
means
one
has
to
scan
well
into
the
file
in
order
to
find
the
compression
magic
most
arm
kernels
traditionally
use
zimage
though
there
is
no
strict
requirement
to
do
so
the
utility
will
automatically
uncompress
both
gzip
and
lzo
kernel
images
if
requested
and
provide
you
with
a
binary
you
can
disassemble
or
search
strings
in
when
loading
into
a
disassembler
you'll
need
to
rebase
the
image
at
assuming
32
bit
the
kernel
is
the
most
architecture
specific
component
of
android
whereas
other
components
only
care
about
the
processor
type
i.e
arm
intel
or
mips
the
kernel
is
also
concerned
with
the
board
type
and
specific
chipsets
because
the
processor
is
in
effect
a
system
on
chip
soc
which
also
contains
additional
components
for
which
specific
drivers
will
be
required
those
drivers
are
part
of
the
source
tree
and
google
actually
provides
several
kernel
trees
for
the
chipsets
shown
in
table
3
3
table
3
3
chipsets
devices
and
board
names
for
google
devices
project
name
chipset
vendor
devices
board
names
goldfish
m
ranchu
n
a
android
emulator
msm
qualcomm
msm
nexus
one
nexus
4
nexus
5
hammerhead
omap
ti
omap
pandaboard
galaxy
nexus
glass
notle
samsung
samsung
hummingbird
nexus
s
tegra
nvidia
tegra
motorola
xoom
nexus
7
9
nvidia
shield
exynos
samsung
exynos
nexus
10
manta
google's
devices
are
commonly
known
by
their
piscine
board
project
name
and
their
kernel
binaries
are
available
via
git
at
subtrees
the
kernel
sources
which
naturally
must
remain
open
can
similarly
be
obtained
via
using
platform_project
as
described
further
in
android
documentation6
aside
from
table
3
3
a
good
way
of
figuring
out
which
branch
a
device's
kernel
is
derived
from
is
by
looking
at
its
strings
and
symbols
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
source.android.com
source
building
kernels.html
the
device
tree
arm
most
arm
kernels
also
rely
on
the
presence
of
a
device
tree
file
to
provide
the
kernel
with
the
hardware
device
definitions
this
file
provides
a
hierarchical
view
of
devices
by
connection
and
enables
the
kernel
to
boot
the
approriate
drivers
for
them
the
device
tree
is
commonly
appended
to
the
end
of
the
kernel
image
but
may
at
times
reside
in
a
separate
partition
the
device
tree
format
is
a
binary
blob
identified
by
the
magic
value
a
complete
discussion
of
the
device
tree
is
beyond
the
scope
of
this
book
it
is
an
arm
feature
and
not
specific
to
android
the
format
is
well
documented
in
the
epapr
specification7
and
a
presentation
by
thomas
pettazoni8
you
can
use
the
utility
to
extract
the
device
tree
from
your
kernel
image
this
is
shown
in
the
following
experiment
experiment
retrieving
the
device
tree
from
a
boot.img
the
in
addition
to
unpacking
a
boot.img
and
extracting
its
kernel
and
ramdisk
will
also
automatically
extract
the
device
tree
component
of
the
kernel
image
if
found
the
extracted
file
however
is
in
a
binary
format
dtb
identifiable
by
its
magic
header
of
to
decompile
the
device
tree
you
will
need
to
use
the
utility
which
is
part
of
the
package
on
ubuntu
or
package
on
fedora
once
installed
it's
a
simple
matter
to
decompile
the
file
and
obtain
the
textual
dts
file
output
3
7
extracting
and
decompiling
a
device
tree
from
the
nexus
5
boot.img
kdswhu
rrw
dfnxs
dqg
5hfryhu
https
www.power.org
wp
content
uploads
2012
06
power_epapr_approved_v1.1
pdf
http
elinux.org
images
a
a3
elce2013
petazzoni
devicetree
for
dummies.pdf
the
ram
disk
the
second
component
of
the
boot
or
recovery
image
is
the
initial
ram
disk
often
referred
to
as
the
initrd
the
ram
disk
provides
an
initial
filesystem
used
as
the
rootfs
when
booting
up
the
os
it's
pre
loaded
by
the
bootloader
into
ram
alongside
the
kernel
hence
the
name
and
enables
quick
access
without
any
special
drivers
this
is
not
a
linux
specific
feature
other
un
x
have
also
been
known
to
use
it
most
notably
ios
wherein
it
is
contained
in
the
ipsw
system
image
alongside
the
kernelcache
traditionally
the
initramfs
is
often
used
to
provide
device
specific
drivers
which
the
kernel
requires
for
operation
this
enables
the
linux
distributer
to
provide
a
generic
relatively
compact
kernel
and
package
the
necessary
drivers
which
vary
between
hardware
configurations
into
a
separate
file
created
during
the
initial
install
process
to
get
around
the
chicken
and
egg
case
wherein
drivers
are
required
for
storage
access
critical
ones
are
packaged
into
the
initramfs
which
the
kernel
can
then
access
directly
in
ram
it
also
contains
the
startup
program
init
which
the
kernel
loads
as
pid
1
enabling
early
startup
operations
which
require
user
mode
for
example
loading
modules
once
the
ram
disk
operation
is
done
linux
normally
discards
it
in
favor
of
the
on
disk
filesystem
a
process
often
refers
to
as
pivoting
root
in
android
however
the
initramfs
is
kept
in
memory
and
provides
the
root
filesystem
this
is
useful
since
the
files
are
consulted
often
and
the
memory
footprint
is
fairly
small
it
also
makes
tampering
with
the
rootfs
harder
since
the
boot
image
is
signed
linux
supports
two
file
formats
for
the
ramdisk
initrd
ext4
filesystem
image
and
initramfs
cpio
archive
the
latter
is
commonly
used
though
it
is
commonly
referred
to
as
an
initrd
the
cpio
archive
makes
for
a
simple
format
with
very
little
ram
requirements
to
further
save
space
the
archive
is
gzipped
the
kernel
already
has
zlib
support
which
it
needs
to
decompress
itself
every
vendor
is
free
to
build
the
ram
disk
as
it
sees
fit
though
most
take
the
android
emulator
image
as
a
baseline
which
is
why
it's
not
surprising
to
see
init.goldfish.rc
in
some
most
ram
disks
are
therefore
very
similar
further
for
a
given
device
the
boot
and
recovery
ram
disks
will
be
largely
the
same
with
the
execption
of
subtle
modifications
in
the
init.rc
file
which
controls
system
startup
in
a
recovery
ram
disk
the
init.rc
omits
the
standard
set
of
services
leaving
adbd
and
sbin
recovery
as
specified
the
kernel
is
packaged
along
with
the
ramdisk
into
a
separate
partition
this
has
a
very
important
design
rationale
behind
it
by
packing
the
two
together
a
single
digital
signature
may
be
applied
on
both
securing
two
for
the
price
of
one
against
tampering
that
the
kernel
is
a
critical
component
of
the
system
should
be
obvious
but
the
ram
disk
as
well
is
quite
important
it
controls
system
start
up
by
providing
init
and
its
corresponding
init
rc
files
init
starts
up
as
root
and
is
responsible
for
starting
up
all
the
other
system
components
getting
root
access
to
a
device
is
as
simple
as
modifying
the
init.rc
file
but
cannot
be
done
without
violating
the
digital
signature
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
unpacking
the
ram
disk
using
the
utility
you
can
obtain
the
ram
disk
from
either
the
boot
or
recovery
images
unpacking
it
is
a
simple
matter
with
the
standard
utilities
gunzip
and
cpio
as
shown
here
if
you
don't
possess
a
boot
image
you
can
try
this
on
the
android
emulator
images
output
3
8
unpacking
a
ram
disk
from
the
recovery
image
using
for
a
description
of
initramfs
contents
i.e
the
root
filesystem
see
table
2
6
in
the
previous
chapter
as
a
further
experiment
you
can
compare
the
ramdisks
of
the
boot
and
recovery
images
system
and
data
partitions
the
system
and
data
partitions
were
discussed
in
the
previous
chapter
vendors
can
provide
these
images
in
any
format
they
see
fit
since
they
can
use
proprietary
binaries
to
flash
as
well
most
vendors
use
fastboot
so
their
images
are
likely
to
follow
the
simg
sparse
image
format
used
by
google's
own
images
utilities
for
handling
this
file
format
can
be
found
in
the
aosp
under
system
core
libsparse
sparse
images
begin
with
a
small
28
byte
header
containing
metadata
about
the
image
the
header
format
is
shown
in
table
3
4
table
3
4
the
sparse
image
header
offset
length
field
0
4
magic
value
4
4
version
as
major
minor
currently
8
2
header
size
always
28
10
2
chunk
size
12
4
block
size
usually
0x1000
4k
for
ext
filesystems
16
4
number
of
blocks
in
filesystem
20
4
number
of
chunks
in
this
file
24
4
optional
checksum
usually
zero
kdswhu
rrw
dfnxs
dqg
5hfryhu
file
users
morpheus
documents
android
book
filesystems.html
2
6
file
users
morpheus
documents
android
book
filesystems.html
system
experiment
mounting
the
android
system
image
on
a
host
extracting
a
sparse
image
is
a
simple
matter
using
the
provided
on
the
book's
companion
website
you
can
also
compile
the
aosp's
from
source
this
is
demonstrated
on
the
system.img
the
userdata
and
cache
images
are
largely
empty
output
3
9
unpacking
an
android
system
image
android
emulator
images
found
in
sdk_root
system
images
are
simply
raw
filesystem
images
and
so
you
can
loop
mount
them
directly
later
in
this
chapter
we
show
how
you
can
use
this
experiment
in
reverse
to
modify
the
system
images
in
preparation
for
flashing
to
the
device
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
the
boot
process
with
all
the
components
of
the
system
images
dissected
we
can
now
turn
our
attention
to
the
actual
boot
process
though
device
dependent
the
boot
process
can
be
generalized
to
the
following
stages
figure
3
1
the
generalized
android
boot
process
firmware
boot
the
device's
firmware
is
akin
to
bios
or
nowadays
efi
on
pcs
its
main
component
is
a
boot
rom
which
is
supplied
by
the
hardware
vendor
the
boot
rom
being
a
component
of
read
only
memory
is
quite
often
a
very
small
component
and
contains
only
the
initial
boot
sequence
which
initializes
hardware
components
to
the
bare
minimum
required
for
usability
the
boot
rom
then
proceeds
to
load
a
secondary
boot
loader
sbl
which
being
software
can
afford
to
be
of
a
bigger
size
and
therefore
perform
more
complicated
initialization
tasks
for
example
displaying
a
startup
graphic
image
unlike
a
pc
a
mobile
device's
processor
is
not
a
single
cpu
as
would
be
the
case
with
an
intel
or
amd
processor
but
a
complete
system
on
chip
soc
in
practice
this
means
that
there
are
several
processors
working
in
tandem
of
which
the
application
processor
is
only
one
the
qualcomm
snapdragon
processors
for
example
contain
no
less
than
four
sub
processor
rpm
resource
power
management
krait
the
application
processor
adreno
the
graphics
processor
cpu
and
hexagon
the
digital
signal
processor
dsp
msm
chipsets
therefore
involve
a
particularly
lengthy
boot
process
wherein
the
boot
rom
provides
the
primary
boot
loader
pbl
to
initialize
the
rpm
processor
this
in
turn
loads
the
secondary
boot
loader
sbl
which
is
itself
broken
into
three
parts
sbl1
sbl2
sbl3
the
parts
load
and
authenticate
one
another
in
an
intricate
choreography
which
also
involves
code
from
the
rpm
and
tz
arm
trustzone
partition
the
application
processor
then
boots
up
the
other
components
and
executes
the
application
boot
which
is
where
android's
boot
loader
comes
into
play
said
choreography
is
actually
quite
complex
and
entirely
undocumented
outside
qualcomm
confidential
documents
some
of
which
have
been
leaked
for
obvious
reasons
this
work
cannot
go
into
detail
but
the
information
gleaned
from
said
documents
as
well
as
a
very
detailed
discussion
can
be
found
at
the
xda
developers
forum9a
with
a
plethora
of
information
in
thread
241001419b
bootrom
sbl
rpm
sbl
modem
modem
dsp
etc
android
bootloader
aboot
partition
linux
kernel
boot
partition
bootimg
initramfs
init
rc
files
frameworks
gui
etc
system
partition
kdswhu
rrw
dfnxs
dqg
5hfryhu
http
forum.xda
developers.com
showthread.php
t
1856327
page
1
http
forum.xda
developers.com
showpost.php
p
24100141
postcount
1968
the
fastboot
protocol
most
android
bootloaders
support
the
fastboot
protocol
which
google
makes
available
as
part
of
android
itself
the
fastboot
protocol
is
a
simple
text
based
protocol
which
is
meant
to
be
used
over
a
usb
channel
between
the
device
and
the
host
it's
not
exceptionally
fast
in
terms
of
performance
e.g
it
is
synchronous
so
the
name
likely
applies
to
it
being
very
easy
and
hence
fast
to
implement
figure
3
2
shows
the
message
passing
between
host
and
device
figure
3
2
the
fastboot
choreography
the
current
protocol
version
at
the
time
of
writing
0.4
is
fairly
well
detailed
in
system
core
fastboot
fastboot_protocol.txt
table
3
5
lists
the
commands
understood
by
the
host
side
binary
and
their
corresponding
protocol
messages
table
3
5
default
fastboot
commands
command
line
protocol
command
description
flash
partition
filename
download
08x
flash:partition
write
a
file
to
a
flash
partition
flash:raw
boot
kernel
ramdisk
create
bootimage
and
flash
it
flashall
flash
boot
recovery
system
update
reflash
device
from
update.zip
erase
partition
erase:partition
erase
a
flash
partition
format
partition
format
a
flash
partition
getvar
variable
getvar:variable
display
a
bootloader
variable
boot
kernel
ramdisk
download
08x
boot
download
and
boot
kernel
devices
getvar:serialno
list
all
connected
devices
continue
continue
continue
with
autoboot
reboot
reboot
reboot
device
normally
reboot
bootloader
reboot
bootloader
reboot
device
into
bootloader
oem
command
args
command
args
send
an
oem
extension
command
vendors
are
not
required
to
support
fastboot
and
may
support
their
own
boot
loader
protocols
instead
of
or
in
addition
to
fastboot
an
example
of
that
can
be
found
in
samsung's
odin
and
amazon's
bootloader
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
using
fastboot
the
android
sdk
provides
the
command
which
is
a
simple
but
complete
implementation
of
the
protocol
to
see
if
your
device's
bootloader
supports
fastboot
you
first
need
to
force
it
to
halt
at
the
bootloader
stage
rather
than
start
up
with
the
magic
button
combination
which
is
tricky
on
some
devices
you
can
use
your
device
will
restart
into
the
bootloader
and
if
it
supports
fastboot
will
be
visible
by
fastboot
devices
by
its
serial
number
similar
to
adb
output
3
10
output
from
at
this
point
the
device
should
present
the
bootloader
ui
and
you
should
be
able
to
independently
navigate
the
boot
loader
menus
using
the
physical
buttons
usually
volume
up
down
and
power
to
select
you
can
also
use
any
one
of
the
commands
in
table
3
5
though
because
most
are
potentially
dangerous
unless
you
know
what
you're
doing
you
can
try
getvar
all
to
list
all
the
bootloader
variables
these
will
be
different
on
every
device
and
the
output
from
the
htc
one
m8
will
show
this
output
3
11
output
from
an
htc
one
m8
the
really
interesting
part
of
fastboot
however
is
in
the
oem
extension
try
to
obtain
a
list
of
all
commands
which
will
surely
vary
between
devices
the
commands
are
extremely
versatile
and
useful
htc
supports
dmesg
to
get
bootloader
log
get_temp
to
read
temperature
sensors
read
writeusername
personalize
the
phone
read
writecid
carrier
id
and
read
writeimei
which
can
be
used
by
carriers
to
configure
the
phone
for
their
networks
as
noted
previously
some
devices
notably
the
nexus
5
and
nvidia's
shield
support
oem
unlock
which
enables
you
to
unlock
the
bootloader
and
free
your
phone
to
load
any
custom
firmware
image
kdswhu
rrw
dfnxs
dqg
5hfryhu
kernel
boot
android's
kernel
boot
process
isn't
much
different
than
that
of
linux
the
bad
news
however
is
that
the
latter
is
somewhat
of
a
moving
target
with
kernel
version
updates
often
adding
or
removing
components
as
well
as
variance
between
platforms
this
section
therefore
aims
to
provide
a
high
level
overview
of
the
kernel
startup
as
it
is
implemented
in
the
3
x
line
of
kernels
you
might
want
to
follow
along
with
a
device
specific
kernel
source
tree
recall
that
the
boot
loader
is
responsible
for
locating
the
kernel
zimage
and
ram
disk
2qfh
erwk
are
resident
in
memory
control
is
transferred
to
the
zimage's
entry
point
the
kernel
is
compressed
at
this
time
so
the
entry
point
implemented
in
arch
architecture
boot
compressed
head.s
head_32
s
or
head_64
s
on
x86
is
responsible
for
calling
which
displays
the
familiar
uncompressing
linux
done
booting
the
kernel
message
and
transfer
control
to
the
real
entry
point
this
is
again
an
architecture
specific
function
implemented
in
assembly
in
arch
arm
kernel
head.s
or
in
arch
x86
kernel
x86
kernel
head_
32
64
s
respectively
what
follows
is
a
low
level
setup
of
the
mmu
and
page
tables
switching
to
virtual
addressing
before
control
is
transferred
to
the
kernel's
main
function
the
function
is
architecture
independent
and
is
thus
implemented
in
init
main.c
it
is
fairly
well
writ
in
the
sense
that
it
has
almost
no
variables
and
most
of
the
startup
is
performed
by
calling
functions
to
make
a
very
long
story
short
initializes
all
the
critical
framework
using
the
specialized
functions
then
calls
which
as
the
name
implies
initializes
everything
else
this
function
spawns
the
thread
which
is
responsible
for
initializing
the
various
subsystems
with
so
many
subsystems
to
initialize
the
kernel
code
would
be
terribly
long
and
messy
instead
the
initcall
mechanism
provides
an
elegant
solution
it
defines
8
initialization
levels
which
the
thread
calls
on
via
in
in
order
as
shown
in
table
3
6
table
3
6
the
initcall
levels
level
notes
0
early
used
to
spawn
initial
helper
threads
such
as
rcu
softirqs
and
workqueues
1
core
used
for
core
subsystems
such
as
binfmt
and
sockets
2
postcore
used
by
bdi
block
device
flush
threads
and
kobjects
3
arch
architecture
dependent
initialization
4
subsys
general
subsystems
such
as
bio
crypto
and
sound
5
fs
used
by
the
vfs
layer
for
filesystem
support
6
device
used
by
drivers
and
general
modules
the
macro
maps
to
this
level
7
late
very
last
stage
advanced
memory
management
oops
handling
and
more
the
idea
is
similar
to
the
classic
user
mode
init's
runlevel
concept
which
used
run
levels
to
group
subsystem
startup
scripts
the
emulate
this
idea
by
allowing
subsystems
to
register
their
initialization
functions
with
a
level
macro
which
in
turn
will
be
invoked
when
processes
the
level
once
all
init
levels
have
been
iterated
through
the
kernel
initialization
is
complete
the
messages
output
during
the
kernel
boot
can
be
seen
using
dmesg
1
but
because
the
kernel
uses
a
ring
buffer
it
will
most
likely
be
partially
overwritten
by
the
time
you
get
the
root
shell
necessary
to
run
this
command
on
a
device
the
size
of
the
kernel
ring
buffer
can
be
configured
when
the
kernel
is
built
rather
than
follow
the
sequence
step
by
step
the
following
listing
maps
the
output
to
the
startup
functions
which
emit
them
the
bold
lines
are
architecture
independent
so
you
should
be
able
to
see
them
albeit
with
slightly
different
values
on
x86
and
arm
alike
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
listing
3
2
an
annotated
output
from
the
android
emulator
kdswhu
rrw
dfnxs
dqg
5hfryhu
listing
3
2
an
annotated
output
from
the
android
emulator
cont
when
the
kernel
startup
thread
is
done
it
emerges
into
user
mode
as
pid
1
init
we
discuss
init
in
detail
in
the
next
chapter
alongside
the
various
android
specific
services
it
launches
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
shutdown
reboot
most
users
keep
their
devices
on
but
there
are
the
occasional
times
when
a
user
decides
to
shutdown
or
reboot
the
device
in
those
cases
the
decision
usually
starts
with
holding
the
power
button
down
for
a
few
seconds
which
pops
up
a
confirmation
dialog
if
the
user
opts
to
actually
shut
down
or
reboot
the
phone
as
opposed
to
say
airplane
mode
the
phone
reboots
behind
the
scenes
however
the
process
is
quite
lengthy
and
involves
a
rather
complicated
choreography
as
shown
in
figure
3
3
which
should
be
read
from
bottom
to
top
figure
3
3
pressing
the
shutdown
button
the
button
press
generates
an
interrupt
which
is
picked
up
by
the
linux
kernel
the
interrupt
is
translated
by
the
kernel
to
an
input
event
which
is
then
propagated
to
the
android
runtime
as
an
as
with
all
other
events
this
is
picked
up
by
the
android's
and
duo
both
threads
with
the
latter
passes
the
event
to
the
object
the
default
policy
object
com.android.internal.policy.impl.phonewindowmanager
intercepts
the
key
if
held
for
a
sufficiently
long
period
which
is
defined
in
the
s
constant
to
be
500ms
and
brings
up
the
menu
through
a
call
to
the
detailed
discussion
of
android's
input
architecture
from
the
low
level
interrupt
through
the
policy
and
views
can
be
found
in
volume
ii
kdswhu
rrw
dfnxs
dqg
5hfryhu
file
users
morpheus
documents
android
book
frameworks
base
master
policy
src
com
android
internal
policy
impl
phonewindowmanager.java
if
the
user
grhv
rsw
wr
shut
dowq
two
roads
diverge
a
tap
will
proceed
with
a
normal
shutdown
but
a
long
press
will
instead
reboot
to
safe
mode
both
tasks
are
handled
by
a
dedicated
whose
method
optionally
pops
up
a
confirmation
dialog
before
beginning
the
shutdown
sequence
if
the
user
confirms
the
shutdown
sets
two
wakelocks
to
keep
the
screen
on
during
the
process
for
a
better
user
experience
the
shutdown
thread
can
then
be
run
its
flow
is
shown
in
figure
3
4
figure
3
4
the
flow
of
the
android
shutdown
sequence
the
last
step
of
the
shutdown
at
the
linux
native
level
is
performed
by
init
as
the
process
responsible
for
implementing
system
properties
q.v
chapter
4
it
picks
up
the
setting
of
the
property
to
either
shutdown
or
reboot
reason
the
reason
can
be
either
or
if
the
values
seem
familiar
it's
because
they
are
the
very
same
ones
used
by
which
sets
the
very
same
property
as
to
the
value
chosen
by
the
user
this
way
all
paths
lead
to
init
which
in
turn
calls
on
function
this
is
nothing
more
than
a
wrapper
to
the
kernel's
system
call
or
with
the
latter
being
a
linux
specific
invocation
which
allows
the
passing
of
the
additional
reason
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
boot.html
application
backup
restore
just
as
humans
grapple
with
sickness
operating
systems
face
the
risk
of
data
corruption
or
outright
loss
backup
and
restore
is
therefore
an
important
functionality
which
an
operating
system
needs
to
provide
applications
need
an
ability
to
save
and
recover
their
configuration
and
data
and
power
users
require
a
similar
ability
to
backup
the
entire
device
to
a
well
known
bootable
configuration
or
a
system
checkpoint
which
can
be
rolled
back
to
in
case
of
calamity
indeed
as
of
api
level
8
android
provides
applications
with
the
a
framework
service
which
provides
both
per
application
backups
as
well
as
full
backups
of
all
apps
the
internals
of
the
framework
service
including
the
application
programming
interface
it
provides
is
covered
along
with
the
rest
of
the
framework
services
in
volume
ii
the
backup
architecture
is
quite
elegant
delegating
the
responsibility
of
selecting
which
data
is
to
be
backed
up
to
the
application
the
application
notifies
the
backup
manager
when
data
has
changed
and
the
backup
manager
adds
the
application
to
a
queue
figure
3
5
a
simplified
view
of
the
android
backup
architecture
at
some
later
time
when
the
gets
a
request
to
actually
perform
a
backup
it
creates
a
backup
set
grouping
together
the
one
or
more
applications
that
were
queued
for
each
application
it
invokes
the
callback
the
passes
the
application
a
file
descriptor
in
the
callbacks
which
the
application
is
expected
to
use
in
order
to
write
out
or
read
from
the
backup
data
the
descriptor
provided
is
connected
to
a
transport
to
which
the
application
remains
entirely
oblivious
data
is
written
and
read
to
the
transport
while
leaving
its
implementation
opaque
data
can
be
backed
up
either
locally
or
to
the
cloud
i.e
google's
servers
or
the
device
vendor's
but
the
choice
of
where
to
back
up
to
remains
at
the
system
or
vendor
level
the
common
transports
are
shown
in
table
3
7
kdswhu
rrw
dfnxs
dqg
5hfryhu
table
3
7
android
transports
transport
backs
up
to
google's
servers
application
needs
a
special
api
key
to
use
this
service
enterprise
backup
for
managed
devices
local
backup
to
device
command
line
tools
from
the
perspective
of
the
power
user
there's
a
far
simpler
interface
to
backup
and
restore
in
the
form
of
two
dalvik
upcall
scripts
the
and
utilities
both
utilities
require
java
to
facilitate
communication
with
the
which
they
perform
over
binder
as
discussed
in
chapter
7
the
utility
is
well
documented10
and
explains
its
usage
in
detail
when
invoked
with
no
arguments
a
summary
of
its
arguments
is
shown
in
table
3
8
table
3
8
commands
and
arguments
understood
by
the
upcall
script
command
purpose
package
mark
package
to
be
backed
up
on
next
run
0
1
enable
disable
the
backup
mechanism
report
if
backup
mechanism
is
enabled
or
disabled
transports
list
available
transports
specifying
default
q.v
table
3
7
sets
list
restore
sets
transportname
set
default
transport
set
app
restore
from
a
specific
set
all
apps
or
only
app
specified
perform
pending
backups
now
transportname
package
erase
all
backups
of
package
from
transportname
package
perform
a
full
backup
of
specified
package
by
contrast
the
utility
is
entirely
undocumented
and
provides
no
user
facing
output
preferring
instead
to
use
the
android
logging
system
expects
only
one
argument
or
but
can
handle
quite
a
few
switches
when
backing
up
the
switches
expected
by
are
shown
in
table
3
9
with
the
defaults
in
bold
table
3
9
switches
understood
by
switch
purpose
save
or
omit
application
apk
files
save
or
omit
application
opaque
binary
blobs
obb
files
save
or
omit
shared
resources
save
or
omit
system
applications
in
full
backups
save
or
omit
widgets
default
nowidgets
compress
backup
backup
everything
requires
user
confirmation
if
the
switches
seem
vaguely
familiar
it's
because
they
are
the
same
as
those
passed
to
though
the
latter
does
not
advertise
as
an
option
backups
through
are
just
direct
invocations
of
the
upcall
script
which
helps
explain
why
it's
not
as
user
friendly
as
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
systemserver.html
servicepattern
http
developer.android.com
tools
help
bmgr.html
figure
3
6
the
default
backup
ui
lg
g3
running
kitkat
local
backups
using
triggers
a
full
backup
of
all
applications
doing
so
causes
the
utility
to
call
the
s
method
which
pops
up
a
customizable
ui
notification
to
the
user
the
default
notification
ui
activity
is
hardcoded
to
and
shown
in
figure
3
6
using
a
ui
requires
the
device
to
be
unlocked
adding
a
measure
of
security
for
users
by
mitigating
the
chance
a
device
could
be
taken
for
a
minute
or
two
backed
up
and
returned
to
the
unwitting
user
another
measure
of
security
offers
the
user
a
chance
to
cancel
the
backup
as
well
as
enter
a
password
if
the
user
approves
the
backup
operation
a
toast
notification
informs
that
the
backup
started
and
the
current
package
progress
is
displayed
when
backing
up
to
a
connected
host
connects
the
other
end
of
the
transport
file
descriptor
to
a
local
file
on
the
host
specified
by
the
switch
or
simply
the
backup.ab
default
the
backup
file
uses
a
proprietary
format
which
differs
slightly
if
the
backup
is
encrypted
or
not
the
format's
only
documentation
is
embedded
in
the
source
of
the
class
but
this
provides
comprehensive
detail
as
shown
in
listing
3
3
listing
3
3
the
format
of
an
android
backup
file
kdswhu
rrw
dfnxs
dqg
5hfryhu
https
android.googlesource.com
platform
frameworks
base
master
services
backup
java
com
android
server
backup
backupmanagerservice.java
experiment
examining
android
backups
the
android
backup
file
header
is
easy
to
figure
out
using
listing
3
3
but
its
contents
are
compressed
by
default
using
the
semi
documented
which
is
supported
by
the
upcall
script
but
not
readily
advertised
by
you
can
create
an
uncompressed
backup
output
3
12
creating
and
inspecting
an
uncompressed
backup
the
header
is
straightforward
enough
but
what
of
the
actual
backup
contents
the
first
line
looks
suspiciously
like
meta
data
we
therefore
strip
the
header
and
try
our
luck
with
output
3
13
stripping
the
header
from
an
android
archive
and
thus
we
see
that
android
backups
internally
are
nothing
more
than
good
ol
un
x
archives
using
compression
applies
the
deflate
algorithm
after
the
if
you
do
use
encryption
the
header
size
and
complexity
both
increase
the
following
shows
the
header
of
the
same
archive
when
compressed
and
encrypted
with
password
output
3
14
examining
an
encrypted
backup
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
monitoring
backup
operations
the
stores
its
configuration
in
two
main
locations
the
system
secure
settings
common
to
all
android
framework
services
and
accessible
via
the
class
the
manager
defines
the
following
settings
with
constants
in
the
class
identical
to
the
string
values
uppercased
table
3
10
settings
controlling
backup
behavior
setting
purpose
backup_enabled
is
backup
enabled
equivalent
to
backup_transport
default
transport
settable
by
backup_provisioned
is
backup
provisioned
useful
for
managed
devices
backup_auto_restore
can
application
data
be
automatically
restored
the
data
backup
directory
containing
the
list
of
transports
as
directories
and
backup
queues
normally
you
won't
need
to
go
into
the
directory
or
settings
yourself
as
you
can
use
or
to
toggle
the
settings
and
to
get
verbose
information
on
the
queues
the
annotated
output
is
shown
below
output
3
15
using
to
display
the
backup
status
kdswhu
rrw
dfnxs
dqg
5hfryhu
https
android.googlesource.com
platform
frameworks
base
master
core
java
android
provider
settings.java
experiment
delving
deeper
into
backups
to
get
a
better
grip
of
backups
on
android
have
a
look
at
the
data
backup
directory
which
is
where
the
maintains
its
metadata
as
root
you
should
see
something
similar
to
the
following
output
3
16
the
data
backup
directories
getting
the
default
transport
is
a
simple
matter
either
by
calling
on
the
upcall
script
or
querying
the
value
directly
from
the
system's
secure
settings
output
3
17
finding
the
default
transport
the
backup
queue
is
maintained
in
memory
but
also
written
to
the
pending
directory
as
a
journal
xxxx.tmp
temporary
file
to
provide
recovery
in
case
the
backup
service
itself
crashes
the
file
format
is
simply
a
concatenation
of
package
names
to
be
backed
up
since
the
package
names
are
preceded
by
a
length
byte
and
null
terminated
use
to
display
this
file
output
3
18
displaying
the
backup
journal
lastly
the
fb
schedule
file
schedule
is
used
to
maintain
a
list
of
all
installed
packages
which
are
backup
eligible
i.e
declared
a
in
their
manifest
as
we
discuss
in
volume
ii
and
is
well
documented
in
the
android
developer
website11
the
file
format
is
very
similar
to
that
of
the
journal
albeit
with
a
few
more
fields
but
this
is
where
gets
handy
which
is
even
more
useful
since
you
don't
need
root
privileges
to
use
it
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
root
flounder
data
backup
bmgr
list
transports
com.google.android.backup
backuptransportservice
android
com.android.internal.backup.localtransport
root
flounder
data
backup
settings
get
secure
backup_transport
com.google.android.backup
backuptransportservice
root
flounder
data
backup
cat
tv
pending
journal
168056423
tmp
com.android.providers.userdictionary
com.google.android.googlequicksearchbox
com.google.android.marvin.talkback
com.google.android.inputmethod.latin
ucom
google.android.gm
ocom.android.nfc
scom.android.vending
gandroid
wcom.google
android.talk
_com.android.sharedstoragebackup
com.google.android.apps.genie
geniewidget
com.google.android.calendar
com.android.providers.settingsroot
http
developer.android.com
guide
topics
data
backup.html
backupmanifest
system
recovery
updates
system
recovery
and
updates
are
similar
processes
in
both
the
system
needs
to
be
diverted
to
an
alternate
boot
sequence
which
rather
than
load
the
full
os
ui
loads
a
minimal
configuration
wherein
a
special
binary
sbin
recovery
can
be
used
to
handle
the
process
in
question
either
process
is
normally
started
when
the
system
is
fully
booted
and
in
ui
mode
though
the
device
can
also
be
ordered
into
recovery
through
or
via
fastboot
when
started
from
the
ui
the
class
provides
the
framework
support
needed
for
downloading
and
verifying
an
update
if
one
is
required
the
update
must
be
digitally
signed
and
is
validated
against
certificates
taken
from
system
etc
security
otacerts.zip
keystore
if
validation
passes
the
update
is
copied
to
the
cache
partition
this
is
why
on
devices
like
the
amazon
kindle
with
forced
automatic
updates
which
can
break
root
removing
the
otacerts.zip
file
will
prevent
updates
an
equally
effective
measure
can
be
to
and
the
cache
partition
the
class
also
provides
arguments
to
the
recovery
process
which
it
writes
to
the
cache
recovery
command
file
the
class
then
reboots
the
system
but
passes
an
argument
to
the
bootloader
to
boot
from
the
recovery
partition
rather
than
the
boot
partition
recall
from
the
earlier
discussion
that
the
recovery
and
boot
partitions
are
usually
identical
save
for
the
ramdisk
image
which
in
the
case
of
recovery
will
load
the
sbin
recovery
instead
of
the
full
android
framework
the
flow
of
commands
from
to
sbin
recovery
is
shown
in
the
following
figure
figure
3
7
interaction
of
with
sbin
recovery
kdswhu
rrw
dfnxs
dqg
5hfryhu
the
sbin
recovery
binary
gets
its
arguments
from
its
command
line
if
any
if
those
aren't
supplied
the
misc
partition
is
searched
for
the
bootloader
control
block
bcb
if
the
partition
cannot
be
found
or
its
contents
cannot
be
parsed
the
binary
turns
to
cache
recovery
command
the
android
runtime
does
not
interface
with
the
bcb
directly
but
sbin
recovery
saves
any
arguments
supplied
to
it
into
the
partition
to
enable
recovery
to
resume
if
somehow
interrupted
the
sbin
recovery
binary
is
guaranteed
to
load
because
it's
part
of
the
ramdisk
and
not
in
any
way
dependent
on
system
this
is
an
important
observation
because
the
system
may
be
in
an
entirely
unbootable
state
at
this
point
then
the
kernel
has
initialized
init
has
loaded
but
recovery
and
possibly
adbd
is
the
only
process
executing
the
sbin
recovery
will
then
read
the
command
left
for
it
in
the
cache
recovery
command
file
as
shown
in
the
previous
figure
and
act
according
to
its
content
shown
in
table
3
10
table
3
10
arguments
understood
by
argument
purpose
wipe
the
cache
partition
and
reboot
wipe
all
the
user
data
in
the
data
partition
i.e
a
factory
reset
throughout
the
device
lifetime
system
is
normally
mounted
read
only
and
should
therefore
face
little
risk
of
corruption
restoring
the
device
to
factory
defaults
therefore
amounts
to
formatting
data
which
both
serves
to
efface
personal
user
data
as
well
as
clear
any
corrupted
files
which
may
be
hindering
the
boot
process
this
option
also
implies
specifies
the
path
to
the
an
ota
update
package
which
needs
to
be
applied
as
a
patch
over
the
system
ota
packages
are
discussed
next
specify
locale
used
this
goes
into
cache
recovery
last_locale
name
of
intent
to
place
in
cache
recovery
intent
show
textual
messages
exit
without
performing
any
actions
unused
during
the
process
it's
important
to
keep
the
user
informed
and
visually
engaged
recovery
therefore
makes
use
of
minui
a
library
which
as
its
name
implies
provides
basic
gui
functionality
this
library
is
discussed
in
more
depth
in
volume
ii
over
the
air
ota
updates
occasionally
the
vendor
or
carrier
and
sometimes
google
itself
may
provide
an
update
to
the
android
os
in
the
form
of
an
over
the
air
ota
update
to
be
delivered
over
the
air
updates
must
be
kept
as
small
as
possible
it
is
for
this
reason
that
ota
updates
are
usually
differential
patches
based
on
a
particular
build
of
android
which
is
assumed
to
be
the
one
being
updated
android's
ota
updates
are
packaged
as
a
single
zip
file
technically
more
like
a
jar
as
it
contains
a
meta
inf
subdirectory
digitally
signed
which
consists
of
multiple
patch
files
in
the
bsdiff
1
format
which
is
essentially
a
series
of
file
offsets
and
lengths
along
with
the
data
to
insert
or
delete
from
the
offsets
the
standard
patch
files
have
the
names
of
the
files
they
are
patching
with
a
p
extension
appended
to
them
a
patch
binary
usually
called
update
binary
which
can
parse
the
patch
files
and
apply
them
according
to
directions
given
by
a
patch
script
usually
called
updater
script
which
executes
the
binary
multiple
times
one
per
patch
and
specifies
the
expected
hash
of
the
file
to
be
patched
pre
post
patch
operation
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
any
additional
files
which
are
either
newly
added
to
the
system
or
are
so
heavily
modified
that
a
patch
file
would
actually
be
larger
than
the
full
file
a
metadata
file
consisting
of
post
build
post
timestamp
pre
build
and
pre
device
entries
which
provide
the
device
properties
before
and
after
the
update
an
otacert
file
a
pem
formatted
certificate
can
be
compared
to
and
optionally
imported
into
system
etc
security
otacerts.zip
note
that
vendors
are
free
to
add
and
or
modify
any
of
the
ota
components
a
good
example
can
be
seen
in
the
updates
of
amazon's
kindle
which
contains
not
only
updates
to
the
files
in
system
but
also
additional
firmware
images
including
the
non
mountable
partitions
listing
3
4
shows
the
content
of
an
ota
update
in
this
case
the
google
supplied
kitkat
update
for
the
nexus
5
listing
3
4
the
contents
of
an
ota
update
for
the
nexus
5
the
ota
update
process
when
started
with
recovery
binary
calls
which
loads
the
package
specified
as
argument
and
looks
for
the
update
binary
inside
it
the
binary
name
is
hard
coded
d
as
the
of
meta
inf
com
google
android
update
binary
if
found
it
starts
it
and
the
update
binary
executes
the
updater
script
in
a
manner
akin
to
shell
scripts
the
standard
update
binary's
source
can
be
found
in
the
android
source
tree
in
the
bootable
recovery
directory
the
update
binary
used
by
most
ota
packages
is
derived
from
this
source
as
vendors
are
encouraged
to
use
the
source
as
a
point
of
departure
rather
than
modifying
it
vendors
can
easily
add
additional
libraries
as
device
extensions
this
is
done
by
adding
any
such
libraries
to
the
variable
in
the
android.mk
file
and
providing
a
libname
function
in
each
looking
at
the
source
of
the
updater
binary
you
can
find
a
list
of
all
functions
in
the
implementation
of
kdswhu
rrw
dfnxs
dqg
5hfryhu
http
newandroidbook.com
src
android
bootable
recovery
updater
listing
3
5
the
s
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
listing
3
6
shows
an
annotated
example
of
an
updater
script
from
the
samsung
ota
update
for
4.4.2
this
demonstrates
not
just
the
commands
from
listing
3
5
but
also
their
usage
with
arguments
listing
3
6
an
annotated
example
of
updater
script
kdswhu
rrw
dfnxs
dqg
5hfryhu
customizing
images
armed
with
the
information
in
this
chapter
you
should
now
have
all
the
ingredients
required
to
concoct
your
own
firmware
image
note
that
as
a
prerequisite
to
this
step
the
bootloader
on
your
device
must
be
unlocked
because
otherwise
custom
images
will
be
rejected
when
customizing
images
the
usual
caveats
apply
images
downloaded
from
untrusted
sources
can
contain
malware
especially
spyware
using
custom
images
may
or
may
not
void
carrier's
or
vendor's
warranty
that
said
if
the
bootloader
is
not
tampered
with
the
process
is
generally
reversible
some
bootloaders
don't
keep
track
of
tampering
so
at
times
it's
possible
to
just
re
lock
the
bootloader
leaving
no
trace
of
any
modification
improperly
installing
a
custom
image
may
render
the
device
unbootable
brick
the
probability
of
this
increases
in
direction
relation
to
the
parts
of
the
image
being
modified
if
only
data
is
modified
the
os
can
still
boot
from
system
at
worst
it
is
possible
to
undo
changes
by
resetting
to
factory
defaults
which
effaces
data
if
both
data
and
system
are
modified
the
kernel
and
ramdisk
can
still
boot
normally
from
the
boot
partition
and
so
the
system
can
always
enter
rescue
mode
if
the
boot
partition
kernel
initramfs
are
modified
the
kernel
and
ramdisk
may
fail
to
load
but
the
boot
loader
can
still
load
and
hopefully
offer
fastboot
or
another
custom
protocol
which
still
enable
overwriting
boot
or
any
other
partition
thus
recovering
bootability
if
the
bootloader
itself
is
modified
you
run
the
risk
of
corrupting
it
so
that
the
device
is
unbootable
and
possibly
bricked
for
good
given
the
above
it
makes
sense
to
proceed
with
appropriate
caution
most
bootloaders
allow
you
to
boot
alternate
images
via
fastboot
without
overwriting
any
existing
ones
which
provides
a
safe
environment
for
testing
we
next
describe
methods
for
customizing
an
image
adding
files
to
an
existing
filesystem
if
your
device
is
already
rooted
adding
files
to
an
existing
filesystem
is
quite
trivial
you
need
to
first
make
sure
the
filesystem
is
writable
and
if
it
isn't
remount
it
as
such
and
then
simply
proceed
to
copy
the
files
onto
it
since
normally
doesn't
run
as
root
though
that
too
can
be
modified
it's
usually
a
two
step
operation
of
dropping
the
files
via
adb
push
at
a
writable
directory
data
local
tmp
makes
a
good
choice
and
then
ing
them
to
their
final
destination
usually
doesn't
work
with
toolbox
since
it
involves
linking
this
method
involves
more
work
than
others
presented
here
but
is
generally
the
safest
so
long
as
you
just
add
files
and
don't
overwrite
any
existing
ones
the
chances
of
impacting
the
system
are
fairly
small
a
minor
exception
to
the
rule
is
when
adding
property
files
or
other
files
whose
presence
changes
the
system
behavior
modifying
the
initramfs
to
modify
files
outside
data
or
system
filesystem
you
will
need
to
tweak
the
initramfs
recall
from
our
earlier
discussion
that
the
initramfs
forms
the
root
file
system
and
remains
loaded
in
addition
to
system
and
data
the
initramfs
also
contains
the
init.rc
file
which
contains
the
startup
commands
for
init
this
makes
the
initramfs
a
suitable
vector
for
inserting
commands
for
rooting
the
device
as
well
this
is
demonstrated
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
repacking
an
initramfs
and
writing
it
as
a
bootimg
to
the
device
a
previous
experiment
in
this
chapter
demonstrated
how
to
unpack
the
initramfs
repacking
the
initramfs
into
a
gzip
image
is
as
simple
as
executing
the
inverse
operations
namely
run
cpio
with
output
rather
than
input
and
then
run
to
compress
output
3
19
creating
a
compressed
initramfs
note
however
the
the
initramfs
is
not
standalone
but
always
bundled
alongside
the
kernel
you
therefore
have
to
use
the
inverse
of
the
aosp's
to
package
the
initramfs
along
with
the
kernel
so
both
can
then
be
flashed
to
the
boot
partition
assuming
you
have
the
kernel
from
the
previous
example
handy
you
wouldn't
normally
need
to
modify
it
this
would
look
something
like
output
3
20
creating
a
boot
image
from
a
kernel
and
a
compressed
initramfs
and
then
write
it
to
the
device
if
your
bootloader
is
unlocked
or
by
using
a
simple
but
careful
if
your
device
is
otherwise
rooted
the
following
uses
the
symlinks
to
figure
out
where
the
boot
partition
is
note
results
may
vary
and
be
extremely
careful
not
to
confuse
boot
with
aboot
or
hboot
output
3
21
booting
from
an
image
as
a
measure
for
added
safety
you
can
repeat
the
previous
experiment
to
unpack
the
boot
image
and
verify
it
before
writing
it
to
the
device
it's
always
a
good
idea
to
save
the
unmodified
boot
image
you
started
with
since
it
can
easily
be
written
back
to
the
device
via
fastboot
should
something
go
awry
overwriting
an
entire
partition
sometimes
it's
easier
to
just
overwrite
the
entire
partition
rather
than
just
add
files
to
it
this
is
usually
the
case
when
the
customization
involves
many
files
such
as
reducing
vendor
bloatware
or
when
it
involves
a
partition
that
is
not
necessarily
mountable
in
either
case
the
first
step
involves
copying
the
partition
directly
from
the
raw
block
device
onto
an
image
using
the
utility
or
a
direct
of
the
raw
block
device
to
the
host
this
method
is
essentially
the
same
as
the
process
shown
in
chapter
2
you
can
also
use
the
android
stock
images
as
a
point
of
departure
as
shown
in
the
earlier
experiment
kdswhu
rrw
dfnxs
dqg
5hfryhu
morpheus
forge
android
book
tmp
find
xargs
cpio
ovd
gzip
output.gz
morpheus
forge
android
book
tmp
mkbootimg
kernel
kernel
ramdisk
output.gz
output
bootimg.img
morpheus
forge
android
book
tmp
adb
push
bootimg.img
data
local
tmp
morpheus
forge
android
book
tmp
adb
shell
shell
android
grep
boot
proc
partitions
shell
android
su
root
android
dd
if
data
local
tmp
bootimg.img
of
dev
block
platform
msm
sdcc
1
by
name
boot
file
users
morpheus
documents
android
book
boot.html
unpackinginitramfs
file
users
morpheus
documents
android
book
filesystems.html
showgpt
file
users
morpheus
documents
android
book
b
mountimg
experiment
packing
an
android
system
partition
image
recreating
the
partition
image
is
generally
an
inverse
of
the
process
and
will
require
you
to
use
on
the
host
to
create
a
new
filesystem
before
adding
the
files
you
want
to
it
unmounting
the
filesystem
will
commit
changes
to
the
image
and
you
can
then
copy
it
to
the
device
switching
the
arguments
very
carefully
alternatively
you
can
use
fastboot
to
flash
the
image
to
its
target
partition
the
method
may
be
preferable
as
a
workaround
for
cases
where
the
bootloader
refuses
to
flash
unsigned
partition
images
compiling
instead
of
in
the
earlier
experiment
will
provide
you
with
a
binary
that
can
take
a
raw
filesystem
image
and
make
it
into
a
sparse
one
this
is
useful
if
you
want
to
customize
your
android
device's
image
in
a
way
that
will
enable
you
to
flash
it
you
can
take
the
android
partition
images
as
a
base
add
more
files
a
setuid
su
comes
to
mind
and
then
create
a
raw
filesystem
image
from
the
mounted
filesystem
from
there
using
is
trivial
and
you
can
then
flash
the
resulting
file
to
your
device
using
discussed
later
in
this
chapter
resources
for
image
modding
the
discussion
of
customizing
images
in
this
book
should
provide
a
solid
foundation
for
you
if
you
choose
to
foray
into
this
exciting
yet
somewhat
dangerous
realm
fortunately
there
are
quite
a
few
resources
which
can
be
of
great
value
providing
mods
developed
and
tested
by
other
users
and
sparing
you
the
unfortunate
experience
of
a
bricked
device
xda
developers
hands
down
the
most
important
resource
for
android
power
users
the
xda
developers12a
website
is
a
vast
repository
for
all
things
android
in
particular
its
extensive
forums12b
which
contain
threads
and
vivid
discussions
for
just
about
any
device
on
the
market
rooting
and
recovery
tools
often
get
advertised
first
via
the
forums
and
with
a
community
of
nearly
6
million
users
amongst
them
well
known
names
in
the
modding
world
it's
always
possible
to
get
help
in
all
but
the
most
newbie
of
questions
cyanogen
aokp
etc
with
android's
open
source
nature
it
was
only
a
matter
of
time
before
groups
outside
of
google
picked
up
the
gauntlet
of
modding
or
customizing
the
operating
system
indeed
several
open
source
projects
were
up
to
the
task
such
as
the
android
open
kang
project
and
cyanogenmod
the
latter
has
become
a
one
stop
shop
for
virtually
every
device
on
the
market
with
customized
versions
of
firmware
rebuilt
for
each
device
from
the
vendor
provided
kernel
and
system
image
cyanogen
developers
also
tweak
the
operating
system
in
many
ways
not
the
least
of
which
is
rooting
which
is
an
easy
by
product
of
a
custom
image
more
often
than
not
images
incorporating
fixes
and
patches
from
newer
versions
of
android
appear
on
cyanogenmod
well
before
the
official
vendors
release
an
update
what
makes
cyanogen
possible
is
the
fact
that
vendors
must
supply
the
source
for
the
kernel
they
use
in
android
that
in
addition
to
the
aosp
remaining
open
enables
the
collaborative
effort
by
many
developers
to
vastly
improve
vendor
releases
and
liberate
others
from
being
subject
to
the
vendor's
often
sluggish
update
cycles
thus
device
specific
tweaks
to
android
either
get
published
as
part
of
the
vendor's
kernel
sources
or
in
binary
form
as
modules
in
the
latter
case
however
recompiling
the
kernel
maintains
compatibility
with
vendor
modules
vendor
specific
apks
can
be
moved
or
removed
from
the
base
image
easily
and
others
added
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
www.xda
developers.com
http
forum.xda
developers.com
figure
3
8
the
twrp
2.8
latest
at
the
time
of
writing
ui
in
most
cases
rather
than
build
your
own
image
cyanogen
can
provide
you
with
ready
made
images
which
mitigate
the
potential
for
an
error
during
image
creation
which
can
brick
your
device
cyanogenmod
have
gone
as
far
as
to
implement
their
own
boot
loader
and
the
entire
process
of
customizing
and
installing
an
image
has
been
reduced
to
only
a
few
clicks
the
avid
reader
is
strongly
encouraged
to
check
out
the
cyanogenmod
website13a
for
more
in
particular
cyanogen
maintains
an
extensive
wiki
and
their
development
learning
center13b
is
a
particularly
good
reference
team
win
recovery
project
the
team
win
recovery
project14
is
a
custom
recovery
image
created
by
a
group
of
android
enthusiasts
in
it
for
the
fun
of
the
win
like
all
recovery
images
it
consists
of
a
bootimg
formatted
partition
containing
a
kernel
and
ram
disk
the
kernel
is
usually
the
same
one
found
in
the
stock
image
but
the
ramdisk
contains
a
full
featured
recovery
binary
which
includes
a
featureful
gui
with
backup
restore
functionality
support
for
ext
file
systems
exfat
and
f2fs
and
chainfire's
supersu
the
inclusion
of
the
latter
makes
it
a
popular
choice
as
a
rooting
tool
for
devices
with
unlocked
bootloaders
ru
dgydqfhg
xvhuv
7
53
v
lpdjh
surylghv
d
txlfn
zd
wr
jhw
wkh
exv
er
elqdu
frpslohg
djdlqvw
bionic
and
thus
able
to
show
androidlvpv
such
as
aids
in
output
twrp's
gui
layout
is
provided
in
the
res
ui.xml
which
can
be
customized
with
resources
found
at
the
team's
github
repository15
the
res
directory
also
contains
fonts
and
png
images
used
by
the
layout
the
binary
is
a
larger
than
usual
sbin
recovery
which
uses
a
modified
version
of
the
aosp's
minui
library
the
modifications
enables
the
simple
gui
and
touch
support
as
opposed
to
standard
recovery
binaries
which
require
the
physical
keys
of
the
device
volume
and
power
buttons
none
of
the
android
runtime
features
or
services
are
needed
though
a
barebones
init
does
load
as
is
required
by
the
boot
process
which
keeps
the
image
compact
minui
is
covered
in
more
detail
in
volume
ii
kdswhu
rrw
dfnxs
dqg
5hfryhu
dqrjhq
lv
ehfrplqj
vrphzkdw
ri
dq
dowhuqdwlyh
wr
vwrfn
qgurlg
dv
vrph
yhqgruv
qrwdeo
2qh
3oxv
xvh
lw
dv
wkh
ghidxow
yhuvlrq
ri
qgurlg
udwkhu
wkdq
rrjoh
v
rzq
1rz
d
ixoo
iohgjhg
vwduwxs
dqrjhq
frppdqghg
ryhu
lq
lqyhvwphqwv
iurp
0lfurvriw
r
rqq
dqg
rwkhuv
http
www.cyanogenmod.org
http
wiki.cyanogenmod.org
w
development
http
teamw.in
project
twrp2
https
github.com
teamwin
team
win
recovery
project
tree
jb
wip
gui
devices
summary
this
chapter
explored
aspects
of
the
android
boot
sequence
and
lifecycle
from
the
formats
of
the
various
images
involved
through
their
step
by
step
operation
shutting
down
and
restarting
was
explained
in
particular
booting
to
recovery
recovery
mode
concepts
and
the
role
of
sbin
recovery
followed
finally
the
process
of
customizing
or
modding
images
was
explained
in
detail
one
glaring
yet
intentional
omission
was
that
of
user
mode
boot
i.e
what
happens
following
kernel
initialization
when
pid
1
init
starts
up
and
launches
the
various
android
native
services
and
eventually
the
framework
services
the
roles
of
init
and
the
various
native
services
are
explored
in
great
detail
in
chapter
5
and
the
framework
services
in
volume
ii
references
1
companion
website
imgtool
source
binary
http
newandroidbook.com
files
imgtool.tar
2
google
nexus
factory
image
repository
https
developers.google.com
android
nexus
images
3
a
codeaurora
lk
https
www.codeaurora.org
cgit
quic
la
kernel
lk
tree
app
aboot
b
google
source
lk
https
android.googlesource.com
kernel
lk
a9b07bbae16a0b1b6de07ec3a3e2005c99043757
4
a
accuvant
building
a
nexus
4
uart
debug
cable
http
www.accuvant.com
blog
building
a
nexus
4
uart
debug
cable
b
osdevnotes
blog
64
bit
arm
kernel
development
demo
http
osdevnotes.blogspot.com
2014
11
64
bit
arm
oskernelsystems
development.html
5
companion
article
disassembling
aboot
http
newandroidbook.com
articles
aboot.html
6
android
documentation
building
kernels
http
source.android.com
source
building
kernels.html
7
epapr
dtb
specification
https
www.power.org
wp
content
uploads
2012
06
power_epapr_approved_v1.1
pdf
8
thomas
pettazoni
device
tree
for
dummies
http
elinux.org
images
a
a3
elce2013
petazzoni
devicetree
for
dummies.pdf
9
a
xda
developers
discussion
of
qualcomm
leaked
documents
http
forum.xda
developers.com
showthread.php
t
1856327
page
1
b
thread
24100141
10
android
developer
utility
http
developer.android.com
tools
help
bmgr.html
11
android
developer
declaring
backup
agent
in
manifest
http
developer.android.com
guide
topics
data
backup.html
backupmanifest
12
a
xda
developers
http
www.xda
developers.com
b
xda
developers
forums
http
forum.xda
developers.com
13
a
cyanogenmod
http
www.cyanogenmod.org
b
cyanogenmod
wiki
http
wiki.cyanogenmod.org
w
development
14
team
win
recovery
project
http
teamw.in
project
twrp2
15
team
win
github
repository
https
github.com
teamwin
team
win
recovery
project
tree
jb
wip
gui
devices
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
http
newandroidbook.com
files
imgtool.tar
https
developers.google.com
android
nexus
images
https
www.codeaurora.org
cgit
quic
la
kernel
lk
tree
app
aboot
https
android.googlesource.com
kernel
lk
a9b07bbae16a0b1b6de07ec3a3e2005c99043757
http
www.accuvant.com
blog
building
a
nexus
4
uart
debug
cable
http
osdevnotes.blogspot.com
2014
11
64
bit
arm
oskernelsystems
development.html
http
newandroidbook.com
articles
aboot.html
http
source.android.com
source
building
kernels.html
http
elinux.org
images
a
a3
elce2013
petazzoni
devicetree
for
dummies.pdf
http
forum.xda
developers.com
showthread.php
t
1856327
page
1
http
forum.xda
developers.com
showpost.php
p
24100141
postcount
1968
http
developer.android.com
tools
help
bmgr.html
http
developer.android.com
guide
topics
data
backup.html
backupmanifest
http
www.xda
developers.com
http
forum.xda
developers.com
http
www.cyanogenmod.org
http
wiki.cyanogenmod.org
w
development
http
teamw.in
project
twrp2
https
github.com
teamwin
team
win
recovery
project
tree
jb
wip
gui
devices
iv
init
all
un
x
systems
have
a
special
process
a
process
which
is
the
first
to
spring
into
existence
in
user
mode
when
the
kernel
has
finished
booting
and
is
charged
with
starting
up
the
system
and
serving
as
the
progenitor
of
all
other
processes
traditionally
this
process
is
called
init
and
android
follows
that
convention
as
well
the
android
init
however
is
vastly
different
than
that
of
un
x
or
linux
with
the
most
important
differences
being
in
its
support
of
system
properties
and
using
a
particular
set
of
rc
files
following
the
explanation
of
those
two
features
we
piece
together
the
flow
of
init
its
initialization
and
run
loop
as
it
so
happens
also
fills
additional
roles
assuming
the
guise
of
ueventd
and
watchdogd
two
important
core
services
which
are
also
implemented
by
init
loaded
through
a
symbolic
link
file
users
morpheus
documents
android
book
init.html
systemproperties
file
users
morpheus
documents
android
book
init.html
rcfiles
file
users
morpheus
documents
android
book
init.html
alltogether
file
users
morpheus
documents
android
book
init.html
guises
file
users
morpheus
documents
android
book
init.html
ueventd
file
users
morpheus
documents
android
book
init.html
watchdogd
the
roles
and
responsbilities
of
init
like
most
un
x
kernels
the
linux
kernel
looks
for
a
hard
coded
binary
to
launch
as
the
first
user
mode
process
on
desktop
linux
systems
this
has
traditionally
been
sbin
init
which
read
the
etc
inittab
file
for
a
description
of
supported
run
levels
or
runtime
configurations
single
user
multi
user
network
file
systems
etc
start
up
processes
and
ctrl
alt
del
behavior
android
also
uses
an
init
binary
but
most
similarities
end
with
the
name
the
following
table
shows
the
differences
table
4
1
android's
init
versus
the
traditional
un
x
sbin
init
linux
sbin
init
android
init
config
file
etc
inittab
init.rc
and
any
ed
file
commonly
init.hardware.rc
and
init.usb.rc
sometimes
init.hardware.usb.rc
multiple
configurations
supported
through
the
notion
of
run
levels
0
shutdown
1
single
user
2
3
multi
user
etc
each
run
level
loads
scripts
from
etc
rcrunlevel.d
no
run
levels
but
offers
configuration
options
through
triggers
and
system
properties
watchdog
functionality
yes
daemons
defined
with
the
keyword
are
restarted
on
exit
unless
they
repeatedly
crash
in
which
case
they
are
suspended
for
a
few
minutes
yes
services
are
kept
alive
by
default
unless
defined
as
services
may
also
further
be
defined
as
which
will
force
the
system
to
reboot
if
they
cannot
be
restarted
adopting
orphan
processes
yes
will
call
to
reap
the
return
code
and
avoid
zombies
yes
registers
a
handler
for
which
the
kernel
will
automatically
send
on
child
process
exit
most
processes
are
silently
ed
for
and
their
exit
code
discarded
system
properties
no
linux
does
not
support
the
notion
of
system
properties
provides
read
access
to
properties
to
all
processes
on
the
system
via
shared
memory
and
a
which
allows
write
access
socket
assignment
no
linux's
init
cannot
get
sockets
for
its
child
processes
this
functionality
is
available
for
inetd
yes
can
bind
a
unix
domain
or
as
of
l
seqpacket
socket
for
a
child
which
can
then
get
it
through
triggered
operation
no
linux
allows
only
very
specific
triggers
such
as
ctrl
alt
del
and
ups
power
events
but
does
not
allow
arbitrary
triggers
yes
can
execute
commands
on
any
system
property
change
allowing
it
to
run
pre
defined
commands
on
triggers
that
can
be
set
by
any
or
some
users
handling
uevents
no
linux
relies
on
the
daemon
usually
sort
of
also
spawns
itself
as
with
separate
config
files
as
a
binary
init
is
statically
linked
this
means
that
all
of
its
dependencies
are
merged
into
the
binary
during
compilation
so
as
to
mitigate
the
risk
that
a
corrupt
or
missing
library
abort
system
startup
when
it
is
first
launched
the
only
filesystem
mounted
is
the
root
filesystem
i.e
and
sbin
which
is
packaged
in
the
android
boot
partition
along
with
the
kernel
in
a
sense
the
android
take
on
init
is
closer
to
another's
ios's
launchd
triggers
and
sockets
in
particular
are
features
offered
by
the
latter
though
android
shows
novelty
with
the
introduction
of
system
properties
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
system
properties
the
android
system
properties
provide
a
globally
accessible
repository
of
configuration
settings
they
are
somehwat
similar
in
form
and
function
to
mibs
but
are
implemented
in
user
mode
by
the
code
in
loads
properties
from
several
files
in
the
order
shown
in
table
4
2
table
4
2
property
files
in
the
android
file
system
file
contains
default.prop
initial
settings
note
this
file
is
part
of
the
initramfs
and
not
present
on
the
device's
flash
partitions
system
build.prop
settings
generated
by
the
android
build
process
system
default.prop
settings
usually
added
by
vendor
data
local.prop
loaded
if
was
compiled
with
and
the
property
is
set
to
1
this
enables
developers
to
override
previous
settings
by
dropping
a
file
into
data
data
properw
shuvlvw
persistent
properties
prefixed
by
these
are
saved
across
reboot
individually
in
files
in
this
directory
can
also
re
load
them
at
any
time
using
the
directive
in
the
init.rc
an
additional
property
file
factory
factory.prop
is
defined
but
no
longer
supported
note
the
order
of
loading
does
matter
since
setting
the
same
property
a
second
time
will
overwrite
the
previous
value
unless
the
property
is
marked
read
only
because
is
the
ancestor
of
all
processes
in
the
system
it
is
only
natural
that
it
implement
the
property
store
early
in
its
initialization
the
code
calls
to
set
up
system
properties
this
function
eventually
calls
which
opens
the
d
as
dev
__properties__
and
into
memory
with
read
write
permissions
before
closing
it
additionally
init
re
opens
the
file
this
time
for
and
then
unlinks
it
figure
4
1
handling
the
property
workspace
mapping
kdswhu
9
qlw
the
read
only
file
descriptor
of
the
property
file
is
set
to
be
inheritable
by
children
this
allows
any
process
in
the
system
easy
access
to
system
properties
albeit
read
only
by
ing
the
descriptor
early
on
this
clever
approach
effectively
allows
all
users
of
the
properties
area
to
share
the
same
physical
memory
backing
the
property
area
d
as
128k
by
default
the
only
write
access
to
this
area
however
remains
in
the
hands
and
memory
of
you
can
see
the
shared
memory
area
in
all
user
mode
processes
on
the
system
easily
by
looking
at
the
maps
proc
entry
output
4
1
viewing
the
mapping
of
the
system
property
area
through
the
proc
filesystem
most
developers
remain
agnostic
to
the
internal
structure
of
the
shared
property
area
the
area
is
prefixed
by
a
short
header
which
contains
a
serial
number
reflecting
internal
versioning
a
magic
value
or
prop
and
a
version
0xfc6ed0ab
for
newer
versions
of
android
or
for
compatibility
then
following
another
112
bytes
padding
the
header
to
128
bytes
are
the
properties
themselves
properties
are
stores
in
a
data
structure
which
hybridizes
a
trie
prefix
tree
and
a
binary
tree
this
is
rather
nicely
documented
if
you
appreciate
ascii
art
in
bionic's
system_properties.c
listing
4
1
internal
structure
of
system
properties
from
system_properties.c
the
in
order
to
service
write
requests
opens
up
a
dedicated
unix
domain
socket
dev
socket
property_service
which
is
world
writable
0666
so
that
any
client
may
connect
it
is
then
up
to
to
enforce
permissions
on
the
properties
which
are
hard
coded
in
an
ever
increasing
list
called
the
permissions
are
based
on
simple
uid
and
gid
checks
which
obtains
from
the
socket
caller
credentials
as
shown
in
table
4
3
uid
0
is
allowed
full
access
to
the
properties
when
selinux
is
enabled
as
of
kitkat
and
l
property
namespaces
are
further
protected
by
security
contexts
as
defined
in
property_contexts
and
shown
in
the
following
listing
selinux
on
android
is
explained
in
chapter
8
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
in
init
note
area
is
writable
root
generic
grep
__properties
proc
1
maps
dev
__properties__b6f2f000
b6f4f000
rw
s
00000000
00
0b
1369
in
any
user
mode
process
in
this
case
the
shell
root
generic
grep
__properties
proc
maps
dev
__properties__b6e5a000
b6e7a000
r
s
00000000
00
0b
1369
file
users
morpheus
documents
android
book
security.html
propertycontexts
table
4
3
property
namespaces
and
their
permissions
namespace
owning
uid
contains
network
properties
used
by
rild
gsm
related
settings
persistent
radio
settings
dns
resolver
settings
in
loco
etc
resolv.conf
usb
mode
adb
mtp
mass
storage
rndis
etc
aid_system
all
network
settings
including
those
owned
by
aid_radio
all
device
settings
unused
hardware
related
settings
system
related
settings
service
start
stop
keys
security
related
settings
wireless
lan
wifi
settings
security
enhanced
linux
settings
aid_system
aid_dhcp
dhcp
settings
aid_system
aid_shell
debug
settings
aid_shell
logging
settings
aid_shell
used
by
adb
if
running
as
root
aid_shell
used
by
adb
if
running
over
tcp
ip
aid_shell
power
management
control
aid_bluetooth
bluetooth
settings
bluetooth
settings
for
bluedroid
stack
special
namespace
prefixes
recognizes
several
special
prefixes
which
govern
how
it
handles
the
properties
the
pseudo
prefix
designates
the
property
as
meant
to
survive
reboot
persistent
properties
are
backed
up
by
files
in
data
property
which
must
be
owned
by
root:root
with
no
links
the
pseudo
prefix
is
used
for
read
only
properties
these
like
c
constants
may
be
set
once
and
once
only
irrespective
of
owner
uid
normally
these
are
set
as
early
as
possible
i.e
in
the
vendor
supplied
build
files
the
prefix
is
used
to
provide
a
convenient
way
to
control
init's
services
by
setting
the
or
properties
respectively
to
the
service
name
7kh
vwduw
dqg
vwrs
wrrov
ri
wrroer
duh
qrwklqj
pruh
wkdq
xvlqj
fwo
iru
jrwh
vxuidfhiolqjhu
dqg
qhwg
a
separate
acl
is
maintained
in
the
array
to
restrict
services
by
uid
gid
as
of
kitkat
this
list
defined
and
in
l
selinux
takes
over
acl
enforcement
kdswhu
9
qlw
accessing
properties
the
command
provides
command
line
property
access
through
and
a
property
listener
in
the
command
the
native
api
for
properties
are
defined
in
system
core
include
cutils
properties.h
key
value
default_value
to
retrieve
a
property
optionally
specifying
a
default
value
if
it
does
not
exist
this
simply
accesses
the
shared
memory
area
key
value
to
set
the
value
of
a
property
this
serializes
the
key
and
value
and
sends
them
over
the
property
service
socket
propfn
key
value
cookie
cookie
to
enumerate
properties
using
a
callback
function
which
will
be
invoked
per
property
with
a
pre
specified
cookie
the
file
includes
a
few
other
undocumented
though
accessible
functions
the
most
useful
of
which
is
serial
which
blocks
until
any
property
is
set
this
is
used
by
the
command
framework
level
access
to
system
properties
is
carried
out
through
which
accesses
the
properties
via
jni
calls
to
the
api
calls
experiment
using
watchprops
the
tool
can
be
used
to
monitor
system
property
changes
in
real
time
starting
this
tool
as
close
as
possible
to
device
boot
by
using
on
the
host
will
still
miss
the
build
properties
since
those
are
sourced
before
is
started
but
nonethless
reveal
the
setting
of
important
properties
during
boot
as
shown
in
the
following
annotated
listing
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
the
rc
files
s
main
operation
involves
loading
its
configuration
file
and
acting
upon
its
directives
traditionally
two
files
were
used
the
main
init.rc
and
a
device
specific
init.hardware.rc
where
hardware
is
obtained
from
the
kernel
argument
or
proc
cpuinfo
the
default
emulator
hardware
for
example
is
goldfish
and
in
m
ranchu
and
it
is
not
uncommon
to
see
init.goldfish.rc
on
actual
devices
as
well
probably
due
to
most
implementors
copying
the
default
filesystem
without
really
paying
attention
to
detail
the
original
idea
might
have
been
to
have
all
android
devices
use
the
same
init.rc
leaving
the
device
specific
file
for
vendor
customizations
in
practice
one
finds
quite
often
that
implementors
simply
add
more
directives
into
init.rc
as
of
jb
the
only
hard
coded
rc
file
is
init.rc
and
the
directive
is
used
to
include
additional
rc
files
explicitly
jb's
default
init.rc
also
includes
init.hardware.rc
imported
as
init
ro.hardware
rc
substituting
the
value
of
the
property
and
init.usb.rc
or
init
ro.hardware
rc
which
contains
the
usb
related
directives
for
as
discussed
later
in
this
chapter
an
additional
is
also
present
in
the
default
build
to
enable
the
kernel
facility
to
be
used
for
debugging
discussed
in
volume
iii
triggers
actions
and
services
the
rc
files
are
composed
of
trigger
and
service
blocks
trigger
blocks
contain
commands
to
be
executed
when
a
trigger
is
satisfied
service
blocks
define
daemons
which
can
start
by
command
and
be
responsible
for
with
optional
modifiers
options
per
such
service
service
blocks
start
with
the
service
keyword
followed
by
a
name
and
the
command
line
triggers
are
defined
by
the
on
keyword
followed
by
an
argument
which
is
either
a
well
known
name
of
a
boot
stage
or
the
property
keyword
followed
by
a
property
value
expression
in
case
the
trigger
is
tied
to
a
property
value
change
when
executing
a
given
action
or
command
sets
the
or
properties
respectively
well
known
boot
stages
are
shown
in
table
4
4
but
note
that
not
all
boot
stages
need
be
used
and
vendors
often
deviate
e.g
mount
filesystems
in
the
init
stage
table
4
4
the
boot
stages
init
stage
contents
early
init
very
first
stage
of
initialization
used
for
selinux
and
oom
settings
init
creates
file
systems
mount
points
and
writes
kernel
variables
early
fs
run
just
before
filesystems
are
ready
to
be
mounted
fs
specifies
which
partitions
to
load
post
fs
commands
to
run
after
filesystems
other
than
data
are
mounted
post
fs
data
data
decrypted
if
necessary
and
mounted
early
boot
run
after
property
service
has
been
initialized
but
before
booting
rest
boot
normal
boot
commands
charger
commands
used
when
device
is
in
charger
mode
init.rc
syntax
and
command
set
the
init.rc
and
its
imported
files
are
very
well
annotated
but
also
quite
long
instead
of
cutting
pasting
them
and
wasting
bytes
and
pages
we
next
focus
on
their
syntax
and
other
features
which
are
relatively
undocumented
or
little
known
you
may
want
to
look
at
init.rc
alongside
reading
this
section
the
recognizes
two
types
of
keywords
when
parsing
the
rc
files
commands
naming
actions
to
execute
on
a
trigger
boot
stage
valid
only
in
a
trigger
block
and
options
modifiers
pertaining
to
a
service
declaration
valid
only
in
a
service
block
table
4
5
shows
the
commands
supported
by
from
keywords.h
colors
correspond
to
different
versions
kdswhu
9
qlw
file
users
morpheus
documents
android
book
init.html
initusb
table
4
5
init
commands
command
syntax
notes
directory
as
cd
command
calls
octal_perms
file
change
octal_perms
masks
of
file
user
group
file
same
as
user
group
file
directory
as
linux
chroot
command
calls
service_class
stop
start
all
services
associated
with
service_class
class
start
or
stop
src_file
dst_file
same
as
command
domainname
writes
domainname
to
proc
sys
kernel
domainname
command
no
longer
supported
service
l
enable
an
otherwise
disabled
service
variable
value
export
environment
variable
will
be
inherited
by
all
children
hostname
writes
hostnname
to
proc
sys
kernel
hostname
interface
bring
up
an
interface
same
as
ifconfig
interface
up
module.ko
load
a
kernel
module
filename.rc
include
an
additional
rc
file
l
re
load
all
properties
from
build
default
and
factory
files
re
load
all
persistent
properties
from
data
propert
level
set
kernel
loglevel
printk
directory
create
a
directory
calls
fstype
fs
point
mount
a
file
system
of
fs_htype
from
fs
on
mount
point
mount
file
systems
in
vold's
fstab.hardware
this
causes
init
to
fork
and
perform
mounts
using
init
detects
any
encrypted
file
systems
shutdown
reboot
kk
shutdown
reboot
wrapper
service_name
start
restart
service
specified
in
service
block
matching
service_name
path
restore
selinux
context
for
path
recursive
added
in
l
filename
remove
a
file
or
directory
calls
respectively
secontext
set
change
selinux
context
init
uses
0
1
toggle
selinux
enforcement
on
off
table
index
value
set
key
table
key
value
set
a
system
property
value
set
an
selinux
boolean
property
value
can
be
0
false
off
or
1
true
on
category
min
max
use
system
call
to
enforce
process
q.v
service_name
stop
service
specified
in
service
block
matching
service_name
kk
activate
all
swap
partitions
in
fstab
target
src
creates
a
symbolic
link
as
calls
tzoffset
set
system
clock
timezone
using
trigger_name
activate
a
trigger
causing
init
to
re
run
corresponding
commands
file
timeout
wait
up
to
timeout
seconds
for
file
to
be
created
file
value
writes
value
to
file
same
as
value
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
m
pdates
dm
erity
partition
encryption
state
for
mount
point
m
loads
dm
verity
state
m
start
bootchartin
if
confi
ured
m
makes
bootchartin
optional
if
you
look
through
your
init.rc
files
you
will
likely
see
these
commands
used
during
the
various
boot
stages
to
perform
what
one
might
expect
during
system
startup
setting
up
the
directory
structure
enforcing
filesystem
permissions
and
setting
up
various
kernel
parameters
via
proc
or
sys
once
the
boot
stages
are
all
defined
the
rest
of
the
file
will
deal
with
service
definitions
as
stated
service
blocks
are
modified
by
options
these
provide
the
parameters
by
means
of
which
determines
how
the
services
are
to
be
run
and
monitored
table
4
6
lists
the
available
options
table
4
6
init
options
option
syntax
notes
supports
linux
or
at
least
will
at
some
point
in
the
future
defines
the
service
to
be
part
of
a
service
group
classes
can
then
be
manipulated
together
by
the
commands
defines
the
service
as
a
console
service
linked
to
dev
console
defines
the
service
as
a
critical
one
critical
services
are
automatically
restarted
if
they
crash
more
than
4
times
in
240
seconds
the
system
will
auto
reboot
into
recovery
mode
indicates
service
will
not
be
started
service
can
still
be
started
manually
specifies
the
gid
to
start
the
service
as
will
call
for
this
specifies
the
i
o
priority
for
the
service
will
call
specifies
a
key
chord
that
can
trigger
this
service
discussed
below
tells
init
to
start
the
service
but
not
worry
about
it
that
is
ignore
its
lists
which
commands
to
invoke
if
when
the
service
needs
to
be
restarted
this
is
commonly
used
to
restart
dependent
services
specifies
the
selinux
label
to
apply
to
this
service
set
an
environment
variable
prior
to
ing
and
ing
the
service
unlike
this
environment
variable
will
only
be
seen
by
the
service
tells
to
open
this
unix
domain
socket
and
let
the
process
inherit
the
open
socket
descriptor
this
enables
services
to
work
with
and
not
worry
about
which
sockets
to
open
or
the
permissions
they
may
require
specifies
the
uid
to
start
the
service
as
will
call
for
this
starting
services
although
the
syntax
is
different
when
starting
services
assumes
the
traditional
function
of
pid
1
the
traditional
or
to
start
up
services
it
s
sets
up
the
service's
permissions
by
calling
sets
up
any
input
unix
domain
sockets
and
any
environment
variables
i
o
priority
for
services
with
and
selinux
context
for
services
defined
with
connects
dev
console
to
stdin
stdout
stderr
and
for
all
others
it
zaps
stdio
though
presently
unsupported
will
also
set
the
capability
set
for
services
defined
with
as
discussed
in
chapter
8
only
once
all
of
these
operations
have
been
performed
will
call
to
launch
the
service
binary
after
the
service
is
started
maintains
a
parental
link
to
it
should
the
service
terminate
or
crash
will
receive
a
signal
notifying
it
of
the
event
and
allowing
the
service
to
be
restarted
the
option
allows
to
form
dependencies
between
services
and
run
additional
commands
or
restart
dependent
services
when
a
particular
service
needs
restarting
the
option
defines
the
service
as
a
must
have
and
if
encounters
a
restart
loop
for
a
service
deemed
critical
that
is
it
restarts
the
service
only
to
have
it
crash
again
it
will
reboot
the
entire
system
into
recovery
mode
for
every
service
also
maintains
a
corresponding
service
property
to
reflect
the
service
status
running
stopped
restarting
kdswhu
9
qlw
file
users
morpheus
documents
android
book
security.html
capabilities
keychords
an
interesting
though
little
known
function
of
is
starting
services
in
response
to
keychords
the
chords
are
defined
as
combinations
of
keys
on
devices
with
a
physical
keyboard
or
buttons
pressed
by
the
user
at
any
time
akin
to
key
combinations
one
would
press
on
a
piano
the
keys
are
specified
by
their
ids
which
are
taken
from
linux's
input
mechanism
note
the
keychords
follow
codes
specified
in
android's
key
layout
files
usually
found
in
system
usr
keylayout
and
not
the
same
codes
as
specified
and
used
by
the
frameworks
i.e
the
codes
at
frameworks
native
include
android
keycodes.h
the
only
default
service
tied
to
a
keychord
is
defined
on
some
devices
like
the
nexus
5
to
be
associated
with
the
volume
and
power
buttons
you
can
find
its
definition
in
the
nexus
init.hammerhead.rc
listing
4
2
the
bugreport
service
demonstrating
the
use
of
keychords
from
init.hammerhead.rc
the
dumpstate
command
is
an
aosp
provided
binary
which
iterates
over
all
subsystems
and
services
and
dumps
all
diagnostics
and
statistics
available
for
them
note
the
service
is
disabled
meaning
it
has
to
be
started
manually
and
its
startup
is
tied
to
keycodes
114
115
and
116
these
as
you
can
verify
by
system
usr
keylayout
generic.kl
are
mapped
to
and
respectively
for
keychords
to
be
supported
dev
keychord
must
exist
this
is
a
device
node
exported
by
the
keychord
kernel
driver
if
the
kernel
was
compiled
with
or
the
driver
was
installed
as
a
module
the
driver
can
be
considered
an
androidism
of
sorts
and
is
discussed
in
more
detail
in
volume
iii
on
a
rooted
device
i.e
one
with
a
modified
root
filesystem
you
can
add
all
sorts
of
functionality
using
keychords
in
the
default
configuration
you're
somewhat
limited
since
only
physical
keys
can
be
specified
but
you
can
still
override
the
combinations
to
implement
any
functionality
of
your
choice
in
devices
with
physical
keyboard
or
additional
buttons
using
keychords
opens
up
even
more
possibilities
mounting
file
systems
though
android
has
a
dedicated
volume
manager
daemon
init
still
has
to
perform
some
mount
operations
by
itself
recall
that
when
init
is
started
only
the
root
filesystem
is
mounted
no
system
or
data
and
therefore
it
falls
on
it
to
at
the
very
least
mount
system
so
that
the
various
daemons
including
can
start
naturally
this
is
a
critical
operation
if
neither
filesystem
can
be
mounted
init
will
drop
the
device
into
recovery
mode
init
recognizes
the
directive
in
the
init.rc
usually
placed
in
the
trigger
as
a
request
to
perform
a
mount
of
all
the
default
file
systems
these
are
specified
in
the
fstab.hardware
file
which
is
one
of
the
files
built
by
the
aosp
the
code
to
handle
the
mount
is
in
which
is
used
by
both
init
and
when
init
performs
the
mount
it
first
forks
so
as
to
mitigate
the
chance
of
a
critical
error
impacting
its
own
startup
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
the
child
process
performs
the
mount
operations
potentially
running
on
the
filesystems
if
required
hardcodes
the
paths
to
the
various
checkers
presently
and
as
of
l
and
those
too
are
fork
ed
the
code
bumps
up
its
logging
level
so
you
can
see
its
messages
in
the
kernel
ring
buffer
using
if
you
do
so
early
on
enough
provided
the
buffer
hasn't
cycled
to
overwrite
older
messages
you
will
find
flagged
messages
interspersed
with
those
of
both
kernel
modules
providing
respective
filesystem
support
and
which
is
enforced
on
the
filesystems
if
extended
attributes
are
detected
it
iv
thus
that
the
child
process
handles
the
mounts
and
returns
a
code
to
the
parent
as
all
children
do
it
is
according
to
this
return
value
that
init
sets
the
value
of
the
property
which
will
be
later
picked
up
by
to
handle
decryption
of
the
filesystem
if
necessary
if
no
filesystems
are
encrypted
init
fires
the
trigger
putting
it
all
together
the
flow
of
as
is
the
pattern
with
most
daemons
init's
code
follows
a
classic
server
setup
initialization
followed
by
a
run
loop
which
hopefully
never
exits
initialization
init's
initialization
consists
of
the
following
steps
check
if
the
binary
was
invoked
as
or
as
of
kitkat
if
so
the
rest
of
the
flow
is
diverted
to
the
corresponding
main
loop
for
either
of
those
daemons
discussed
later
in
this
chapter
create
directory
entries
for
dev
proc
and
sys
and
mount
them
touch
open
and
then
close
dev
booting
this
file
is
cleared
once
startup
is
complete
by
q.v
figure
4
2
to
daemonize
link
to
dev
null
creates
dev
__kmsg__
major
1
minor
11
and
immediately
deletes
it
creates
the
shared
property
area
in
memory
as
discussed
earlier
in
this
chapter
in
system
properties
gets
the
hardware
name
by
reading
proc
cpuinfo
and
extracting
the
hardware
line
rather
crude
but
it
works
at
least
on
arm
architectures
reads
proc
cmdline
and
imports
as
properties
any
arguments
beginning
with
as
selinux
is
initialized
on
jellybean
and
later
in
jb
it
is
still
conditionally
ifdef'ed
have_selinux
in
kk
selinux
is
assumed
to
be
available
by
default
the
selinux
security
contexts
are
restored
for
dev
and
sys
a
special
check
is
made
to
see
if
the
device
is
in
charger
mode
as
indicated
by
an
kernel
argument
this
will
divert
the
flow
of
init
by
skipping
most
of
the
initialization
stages
and
loading
only
the
class
of
services
which
presently
contains
only
the
daemon
if
the
device
is
not
in
charger
mode
proceeds
to
load
default.prop
and
the
boot
up
proceeds
normally
is
called
to
parse
init.rc
enqueues
the
actions
supplied
in
the
init.rc
sections
using
and
the
built
in
actions
on
an
the
resulting
queue
is
shown
in
figure
4
2
kdswhu
9
qlw
file
users
morpheus
documents
android
book
init.html
propertyinit
figure
4
2
the
init
boot
stages
in
white
and
built
in
commands
in
yellow
early
init
writes
oom_adj
sets
selinux
context
starts
ueventd
wait_for_coldboot_done
blocks
until
ueventd
creates
dev
coldboot_done
mix_hwrng_into_linux_rng
copies
entropy
from
dev
hw_random
if
present
to
dev
urandom
if
not
skip
keychord_init
opens
dev
keychord
for
service
keycodes
console_init
loads
logo
initlogo.rle
on
graphics
console
fb0
or
displays
a
n
d
r
o
i
d
on
40x30
text
console
tty0
init
ro.bootmode
chargerro.bootmode
charger
early
fs
fs
post
fs
post
fs
data
mix_hwrng_into_linux_rng
remixes
entropy
in
case
random
devices
weren't
available
property_service_init
loads
properties
from
files
initializes
dev
socket
property_service
signal_init
create
signal
socketpair
registers
sigchld
handler
check_startup
verify
sockets
exist
unlink
dev
booting
ro.bootmode
chargerro.bootmode
charger
early
boot
charger
boot
queue_property_triggers
add
all
property
triggers
at
end
of
action_queue
bootchart_init
if
bootchart
collect
boot
statistics
o
t
o
a
m
eventually
the
main
loop
iterates
through
at
all
the
init.rc
commands
and
spends
most
of
its
days
asleep
polling
the
file
descriptors
optionally
logging
to
bootchart
and
waking
up
only
when
necessary
you
can
see
init's
file
descriptors
by
looking
at
the
proc
file
system
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
output
4
2
init's
file
descriptors
as
seen
through
proc
1
fd
the
run
loop
the
main
run
loop
is
also
quite
simple
consisting
only
of
three
steps
dequeues
the
action
at
the
head
of
the
queue
if
any
and
performs
it
which
iterates
over
all
registered
services
and
restarts
them
if
necessary
set
up
and
poll
monitor
three
socket
descriptors
the
dev
socket
property_service
through
which
client
processes
who
wish
to
set
a
property
pass
the
property
key
and
value
the
code
obtains
the
peer's
credentials
using
and
performs
the
permission
checks
on
the
property
if
it
can
be
set
any
triggers
or
related
services
for
properties
are
executed
as
well
if
selinux
is
enabled
init
calls
on
it
to
enforce
the
property_contexts
the
dev
keychord
if
it
exists
which
handles
any
service
key
combinations
as
discussed
previously
the
one
end
of
a
created
to
handle
from
dead
offspring
when
the
signal
is
received
the
writes
data
to
the
other
end
of
the
making
data
available
on
the
receiving
end
and
causing
to
call
this
reaps
the
process
return
value
so
as
to
lay
it
to
rest
and
avoid
a
zombie
cleans
up
any
sockets
and
potentially
restarts
the
process
if
it
is
a
tracked
service
it's
important
to
emphasize
that
aside
from
listening
on
the
file
descriptors
init
accepts
no
other
input
from
any
source
in
other
words
there
is
no
way
to
affect
init's
operation
this
is
by
design
since
init
remains
an
unrestricted
root
owned
process
the
only
way
to
modify
init's
operation
requires
editing
of
the
init.rc
files
which
being
part
of
the
root
file
system
are
on
a
separate
partition
along
with
the
kernel
and
digitally
signed
so
as
to
reject
modifications
in
all
but
bootloader
unlocked
devices
kdswhu
9
qlw
root
generic
proc
1
ls
l
fd
lrwx
0
dev
__null__
deleted
lrwx
1
dev
__null__
deleted
stdin
stdout
and
stderr
closed
lrwx
2
dev
__null__
deleted
l
wx
3
dev
__kmsg__
deleted
major
1
minor
11
lr
x
4
dev
__properties__
lrwx
5
socket
1643
read
only
property
store
for
children
property_set_fd
dev
socket
property_service
lrwx
6
socket
1645
lrwx
7
socket
1646
signal_fd
socketpair
0
signal_recv_fd
socketpair
1
lrwx
9
socket
1784
file
users
morpheus
documents
android
book
init.html
keychords
init
and
usb
an
android
device
occasionally
needs
to
change
its
behavior
as
a
usb
attachment
based
on
user
preference
act
as
a
mass
storage
device
emulate
a
digital
camera
start
up
or
shutdown
adb
and
more
rather
than
use
a
dedicated
daemon
to
toggle
behavior
the
responsibility
falls
on
init
which
communicates
with
the
usb
components
in
the
kernel
usb
behavior
is
dictated
the
system
property
the
frameworks
specifically
usbdevicemanager
and
its
related
classes
set
the
value
of
this
property
according
to
the
user
choice
and
init
being
the
keeper
of
all
system
properties
picks
up
any
changes
and
applies
them
using
a
trigger
for
convenience
the
property
triggers
are
maintained
separately
in
init.hardware.usb.rc
this
can
be
seen
in
the
following
listing
demonstrating
the
contents
of
this
file
on
a
nexus
5
listing
4
3
usb
settings
from
from
a
nexus
5
as
shown
in
the
figure
s
response
to
property
changes
involves
writing
parameters
to
sys
class
android_usb
android0
the
receiving
end
of
these
pseudo
files
is
the
usb
gadget
driver
this
as
the
name
implies
is
a
multipurpose
driver
which
can
emulate
any
aspect
of
usb
functionality
as
dictated
from
user
mode
the
functions
this
driver
can
handle
correspond
to
the
usb
modes
shown
in
table
4
usb
table
4
usb
usb
modes
recognized
by
the
usb
gadget
driver
accessory
connecting
accessories
to
the
device
implements
aoa
protocol
acm
abstract
control
model
usb
modems
adb
android
debugger
bridge
adbd
functionality
creates
dev
android_adb
device
node
over
which
a
host
can
communicate
with
the
device's
adbd
audio_source
usb
audio
source
when
connected
to
external
speakers
provides
pcm
playback
mass_storage
mass
storage
device
portable
disk
mtp
media
transfer
protocol
identifies
as
camera
and
creates
kernel
thread
to
handle
mtp
requests
creates
dev
mtp_usb
rndis
usb
remote
ndis
used
when
usb
tethering
the
device
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
android_src_root
frameworks
base
services
usb
java
com
android
server
usb
usbdevicemanager
to
effectuate
the
changes
the
driver
needs
to
be
disabled
and
reenabled
this
is
why
toggling
usb
debugging
or
tethering
temporarily
disconnects
the
device
from
its
host
as
you
can
see
by
observing
the
host's
kernel
messages
or
if
you
have
a
virtual
machine
getting
a
pop
up
experiment
modifying
device
usb
identification
the
following
experiment
shows
how
you
can
control
the
device's
usb
personality
this
is
demonstrated
on
a
galaxy
s3
but
the
steps
work
on
all
devices
output
4
3
the
usb
personality
files
on
a
galaxy
s3
changing
the
iproduct
will
change
the
string
with
which
the
device
identifies
itself
to
the
host
for
example
kindle
hdx's
string
is
lab126
android
whereas
some
chinese
goophones
identify
as
apple
iphone
changing
the
iserial
will
change
the
string
reported
by
useful
for
and
the
imanufacturer
or
iproduct
can
similarly
be
changed
you
can
test
this
for
yourself
by
writing
a
string
of
your
choice
then
disconnecting
and
reconnecting
the
usb
cable
to
the
host
note
these
changes
do
not
persist
across
a
reboot
but
you
can
easily
write
them
to
the
init.hardware.usb.rc
or
applicable
file
on
your
device
if
you
like
your
new
device
identity
kdswhu
9
qlw
shell
s3
sys
class
android_usb
android0
ls
bdeviceclass
bdeviceprotocol
bdevicesubclass
bcddevice
enable
toggles
enable
disable
f_accessory
f_acm
f_adb
f_ccid
f_diag
f_mass_storage
exported
gadget
driver
functionsf_mtp
f_ncm
f_ptp
f_rmnet
f_rmnet_sdio
f_rmnet_smd
f_rmnet_smd_sdio
f_rndis
functions
controls
functionality
host_state
holds
vendor
string
e.g
samsung
imanufacturer
iproduct
iserial
idproduct
idvendor
holds
product
id
reported
e.g
samsung_android_sgh
i747
holds
serial
reported
by
adb
vendor's
product
id
well
known
vendor
id
e.g
intel
8086
power
remote_wakeup
state
subsystem
terminal_version
uevent
shell
s3
sys
class
android_usb
android0
cat
functions
mtp
acm
adb
shell
s3
sys
class
android_usb
android0
cat
iproduct
samsung_android_sgh
i747
the
other
roles
of
init
as
discussed
in
the
last
section
can
also
be
fill
additional
roles
that
of
and
as
of
kitkat
even
though
these
are
filled
by
the
same
binary
the
code
path
taken
is
an
entirely
different
one
and
is
chosen
before
any
other
initalization
step
ueventd
as
assumes
the
responsibility
of
managing
hardware
devices
responding
to
kernel
notifications
and
device
representations
in
the
sys
filesystem
and
making
them
available
to
processes
via
symbolic
links
it
creates
in
dev
it
uses
different
initialization
files
that
is
it
consults
ueventd.rc
and
ueventd.hardware.rc
where
hardware
is
obtained
from
proc
cpuinfo
or
the
kernel
argument
unlike
however
the
configuration
file
s
only
contain
entries
related
to
device
nodes
and
their
permissions
iterates
over
the
lines
of
the
file
and
calls
for
every
device
entry
figure
4
3
the
flow
of
the
next
step
is
to
call
which
initializes
a
socket
if
a
cold
boot
is
detected
i.e
if
the
dev
coldboot_done
cannot
be
found
iterates
through
the
sys
class
sys
block
and
sys
devices
subtrees
writing
add
to
uevent
psuedo
files
in
each
this
triggers
uevent
device
addition
notifications
which
otherwise
might
have
missed
prior
to
its
startup
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
once
the
socket
is
initialized
the
role
of
becomes
very
simple
continuously
poll
it
read
events
as
they
become
available
and
handle
them
events
may
be
of
two
general
types
device
events
these
events
are
generated
by
kernel
subsystems
when
devices
are
added
or
removed
in
this
sense
functions
like
the
traditional
linux
it
creates
or
removes
nodes
corresponding
to
the
devices
firmware
events
listens
on
firmware
add
events
and
attempts
to
load
firmware
updates
from
etc
firmware
vendor
firmware
and
firmware
image
if
compiled
with
will
log
events
as
messages
watchdogd
just
like
is
another
facet
of
in
this
identity
it
is
responsible
for
interfacing
with
the
hardware
watchdog
timer
dev
watchdog
if
present
by
setting
a
timeout
value
and
sending
a
keepalive
signal
a
null
byte
at
regular
intervals
if
the
timeout
value
passes
and
fails
to
wake
up
in
time
the
hardware
timer
interrupt
can
be
used
by
the
kernel
to
reset
while
a
somewhat
drastic
measure
the
only
reason
wouldn't
wake
up
in
time
would
be
a
system
hang
it's
likely
the
system
wouldn't
recover
from
such
a
hang
and
and
therefore
it
is
simpler
to
restart
the
device
as
the
daemon
accepts
two
command
line
arguments
the
interval
and
a
margin
both
in
seconds
with
initial
values
of
10
the
overall
device
timeout
value
is
the
sum
of
both
i.e
20
by
default
allowing
for
some
leeway
before
the
drastic
measure
of
a
reboot
is
taken
summary
this
chapter
explored
all
aspects
of
init
the
most
critical
of
system
processes
without
which
there
would
be
no
user
mode
we
started
by
comparing
it
to
its
linux
and
un
x
counterparts
then
moved
on
to
explore
its
single
most
important
idiosyncratic
feature
system
properties
we
next
discussed
the
syntax
of
its
rc
files
and
constructed
the
full
flow
the
next
chapter
explores
the
services
themselves
focusing
on
the
default
system
daemons
and
then
going
on
to
which
provides
support
for
all
of
android's
frameworks
the
actual
framework
services
which
number
in
the
many
dozens
require
much
detail
from
a
programmatic
perspective
which
is
why
they
have
been
left
for
volume
ii
files
discussed
in
this
chapter
section
file
directory
contains
init
system
core
init
the
code
of
init
system
core
init
readme.txt
documentation
on
commands
and
triggers
ueventd
system
core
init
ueventd
ch
the
code
of
init's
persona
watchdogd
system
core
init
watchdogd
ch
the
code
of
init's
persona
kdswhu
9
qlw
file
users
morpheus
documents
android
book
init.html
systemproperties
file
users
morpheus
documents
android
book
init.html
rcfiles
file
users
morpheus
documents
android
book
init.html
alltogether
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
v
android
daemons
android
has
quite
a
few
daemons
running
in
the
background
for
providing
its
miscellaneous
housekeeping
and
operational
functions
the
services
are
mostly
strewn
in
init.rc
without
much
ordering
save
the
service
class
the
core
services
start
first
followed
by
the
main
ones
the
rc
also
defines
a
late_start
class
for
services
which
depend
on
the
data
partition
though
no
default
services
belong
to
it
in
this
section
we
adopt
the
service
class
division
but
since
most
services
are
in
main
further
subcategorize
by
function
following
our
discussion
of
init
in
the
previous
chapter
we
continue
to
cover
the
core
services
adbd
the
servicemanager
and
kitkat's
healthd
as
well
as
new
core
services
added
in
l
lmkd
and
logd
all
other
services
are
generally
classified
into
the
main
category
so
a
subcategorization
by
network
services
netd
mdnsd
mtpd
and
rild
and
graphics
and
media
services
surfaceflinger
bootanimation
mediaserver
and
drmserver
follows
the
remaining
services
are
hard
to
group
so
they
are
placed
into
the
other
services
category
which
includes
installd
keystore
debuggerd
sdcard
and
last
but
far
from
least
zygote
file
users
morpheus
documents
android
book
init.html
file
users
morpheus
documents
android
book
services.html
coreservices
file
users
morpheus
documents
android
book
services.html
adbd
file
users
morpheus
documents
android
book
services.html
servicemanager
file
users
morpheus
documents
android
book
services.html
healthd
file
users
morpheus
documents
android
book
services.html
lmkd
file
users
morpheus
documents
android
book
services.html
logd
file
users
morpheus
documents
android
book
services.html
networkservices
file
users
morpheus
documents
android
book
services.html
netd
file
users
morpheus
documents
android
book
services.html
mdnsd
file
users
morpheus
documents
android
book
services.html
mtpd
file
users
morpheus
documents
android
book
services.html
rild
file
users
morpheus
documents
android
book
services.html
graphicsservices
file
users
morpheus
documents
android
book
services.html
surfaceflinger
file
users
morpheus
documents
android
book
services.html
bootanimation
file
users
morpheus
documents
android
book
services.html
mediaserver
file
users
morpheus
documents
android
book
services.html
drmserver
file
users
morpheus
documents
android
book
services.html
otherservices
file
users
morpheus
documents
android
book
services.html
installd
file
users
morpheus
documents
android
book
services.html
keystore
file
users
morpheus
documents
android
book
services.html
debuggerd
file
users
morpheus
documents
android
book
services.html
sdcard
file
users
morpheus
documents
android
book
services.html
zygote
core
services
the
services
in
the
core
class
are
the
first
to
be
started
during
user
mode
boot
these
services
do
not
access
the
data
partition
and
therefore
can
run
irrespective
of
whether
or
not
it
is
mounted
adbd
if
you're
reading
this
book
likely
adb
needs
no
introduction
it
is
through
this
medium
known
as
the
android
debugger
bridge
that
the
host
and
the
device
communicate
the
bridge
can
be
used
either
directly
using
the
command
or
indirectly
using
the
command
itself
is
well
documented
and
running
it
without
any
arguments
will
display
a
rather
lengthy
usage
message
of
more
interest
to
our
discussion
is
how
adb
actually
works
in
its
basic
configuration
the
which
is
the
device
daemon
providing
the
server
functionality
of
adb
is
defined
in
the
init.rc
albeit
disabled
and
started
on
demand
in
init.usb.rc
when
the
property
contains
adb
which
is
what
the
well
known
usb
debugging
gui
option
activates
listing
5
1
adb
definitions
in
the
rc
files
kitkat
note
that
the
is
run
by
default
as
uid
root
it
does
however
drop
privileges
to
run
as
uid
shell:shell
along
with
several
other
groups
as
shown
in
this
snippet
from
adb.c
listing
5
2
the
adb
main
startup
function
showing
privilege
settings
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
interestingly
samsung's
tizen
uses
the
smart
debugger
bridge
or
sdb
which
in
almost
all
ways
including
command
line
syntax
is
a
complete
clone
of
adb
listing
5
2
cont
the
adb
main
startup
function
showing
privilege
settings
it's
possible
to
make
to
retain
its
privileges
from
the
host
running
which
sets
the
to
1
a
limitation
in
the
adb
source
permits
this
only
if
the
property
is
set
to
1
and
otherwise
prints
the
familiar
error
adbd
cannot
run
as
root
in
production
builds
the
can
contain
a
hexadecimal
value
specifying
the
logging
mask
try
setting
it
to
0xff
for
maximum
verbosity
if
the
property
exists
and
is
valid
adb
will
log
to
data
adb
adb
y
m
d
h
m
s
the
normally
uses
the
dev
socket
adb
unix
domain
socket
as
set
up
by
but
also
uses
dev
android_adb
or
as
of
l
the
functionfs
endpoints
in
dev
usb
ffs
adb
ep
when
connecting
to
the
host
over
usb
i.e
not
in
the
emulator
the
latter
is
a
device
node
which
is
created
by
the
usb
gadget
driver
the
can
also
be
made
to
listen
on
the
tcp
port
specified
by
the
property
or
in
its
absence
the
property
in
any
of
these
cases
the
architecture
can
be
generialized
as
shown
in
figure
5
1
figure
5
1
the
adb
architecture
kdswhu
9
dhprqv
tracing
the
adb
protocol
the
adb
protocol
is
described
in
the
protocol.txt
file
in
its
implementation
and
therefore
does
not
merit
much
further
discussion
here
adb
has
a
simple
yet
efficient
tracing
mechanism
in
the
form
of
the
environment
variable
this
variable
when
exported
to
an
session
causes
the
client
side
binary
to
verbosely
print
the
protocol
commands
the
source
for
lists
several
options
for
this
variable
all
adb
sockets
packets
rwx
usb
sync
sysdeps
transport
jdwp
though
in
practice
transport
is
the
most
useful
one
for
viewing
adb
messages
though
without
indicating
the
message
direction
output
5
1
tracing
adb
protocol
commands
using
adb
security
because
adb
is
a
portal
into
such
powerful
debugging
and
tracing
capabilities
it
naturally
poses
a
significant
security
risk
running
as
uid
is
still
rather
far
from
access
but
nonetheless
provides
powerful
abilities
by
virtue
of
the
various
group
memberships
and
to
name
but
a
few
using
adb
it's
trivial
to
access
the
user's
personal
data
including
the
lock
screen
sequence
as
well
as
upload
any
application
or
binary
to
the
device
for
this
reason
later
versions
of
jellybean
take
a
step
to
secure
adb
by
introducing
public
key
authentication
through
the
message
if
the
is
enabled
as
can
be
seen
in
listing
5
2
the
message
is
sent
in
response
to
an
demanding
authentication
before
any
more
commands
can
be
exchanged
the
argument
of
is
always
a
which
is
an
array
of
20
random
bytes
collected
from
the
device's
entropy
source
dev
urandom
the
host
is
expected
to
answer
by
signing
the
token
with
its
private
key
which
will
be
generated
and
stored
in
home
android
adbkey
using
an
reply
specifying
a
argument
and
the
random
bytes
encrypted
read
signed
by
its
private
key
if
the
corresponding
public
key
is
known
to
the
device
verification
can
ensue
and
if
successful
the
session
may
move
to
the
online
state
as
with
all
things
related
to
public
keys
there
is
the
chicken
and
egg
problem
of
making
the
public
key
known
a
priori
so
it
can
be
used
for
verification
the
default
is
to
allow
the
host
to
respond
with
a
argument
since
the
key
cannot
be
trusted
adb
shoves
the
key
through
its
to
specifically
which
is
started
by
which
in
turn
pops
up
a
dialog
asking
the
user
to
confirm
the
thumbprint
md5
hash
of
the
key
if
the
user
agrees
the
key
is
added
to
the
adb
key
store
in
data
misc
adb
adb_keys
note
that
vendors
can
easily
recompile
adbd
to
remove
this
functionality
in
and
allow
only
hard
coded
vendor
supplied
keys
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
message
of
length
12
morpheus
forge
adb_trace
transport
adb
shell
30303063
000c
686f73743a76657273696f6e
host:version
reply4f4b4159
okay
30303034
0004
30303166
001f
30303132
0012
message
of
length
18
reply
message
of
length
6
686f73743a7472616e73706f72742d61
host:transport
a
4f4b4159
okay
30303036
0006
7368656c6c3a
shell
4f4b4159
okay
reply
file
users
morpheus
documents
android
book
services.html
l5
2
you
can
see
the
usb
debugging
state
along
with
the
adb_keys
in
the
output
of
note
the
similarities
to
ssh
known_hosts
files
which
likely
served
as
inspiration
output
5
2
dumping
usb
debugging
state
with
servicemanager
the
is
a
key
component
of
android's
ipc
mechanism
though
a
small
binary
it
is
an
important
one
without
which
inter
process
communication
would
be
severely
impaired
this
is
reflected
in
its
defition
in
the
init.rc
as
shown
in
listing
5
3
listing
5
3
the
servicemanager
definition
in
init.rc
what
makes
so
critical
and
makes
so
many
other
services
dependent
upon
it
is
its
function
as
a
service
mapper
virtually
every
ipc
mechanism
requires
a
mapper
to
enable
clients
to
find
and
connect
to
the
services
un
x
has
its
portmapper
for
sunrpc
windows
has
its
dce
endpoint
mapper
and
the
fulfills
this
function
in
android
given
this
the
definition
in
init.rc
should
make
sense
it's
not
that
the
services
actually
require
the
so
much
as
that
in
the
case
of
its
untimely
demise
clients
would
be
unable
to
find
them
when
the
is
restarted
it
does
so
with
a
tabula
rasa
which
requires
services
to
re
register
in
order
to
be
found
since
there
is
no
method
for
services
to
detect
the
manager
is
dead
the
only
way
is
to
get
them
to
re
register
is
to
force
restart
them
as
well
the
certainly
merits
more
attention
as
do
all
the
framework
services
which
it
supports
the
next
chapter
discusses
it
in
detail
alongside
the
process
serves
as
the
service
host
and
its
individual
services
kdswhu
9
dhprqv
shell
hammerhead
dumpsys
usb
usb
debugging
state
connected
to
adbd
true
last
key
received
null
user
keys
qaaaaagih7j
oqp
s8amuvbrpjxgy
5yppwthz4mpp6u9wt
fzgyip4snt
2cp
40rrb8whqlalvps2fawlm1ljstmj
public
key
as
base64
a
2cnpxxtmoh6gzocnmwpavsqcmlkyx1yccs2o4hnjkymjqbqeaaqa
morpheus
forge
system
keys
ioexception
java.io.filenotfoundexception
adb_keys
open
failed
enoent
no
such
file
or
directory
file
users
morpheus
documents
android
book
systemserver.html
servicemanager
healthd
the
health
daemon
is
meant
to
service
general
device
health
tasks
periodically
though
at
present
the
only
tasks
are
battery
related
this
will
likely
change
in
future
releases
the
daemon
registers
itself
as
the
service
or
in
l
as
the
registrar
healthd
provides
the
framework
services
e.g
with
up
to
date
battery
statistics
which
it
obtains
from
sysfs
like
most
daemons
sets
up
an
initial
configration
and
then
enters
a
run
loop
the
detailed
flow
is
shown
in
figure
5
2
figure
5
2
the
flow
of
healthd
process
commandline
n
no
publish
with
servicemanager
c
charger
l
healthd_board_init
loads
configuration
sysfs
file
names
for
battery
stats
wakealarm_init
sets
timer
for
periodic
chores
uevent_init
opens
a
netlink
multicast
socket
for
uevents
binder_init
set
up
binder
fd
create
init
batterymonitor
construct
and
then
initialize
a
batterymonitor
object
epoll_wait
set
up
three
descriptors
in
epoll
and
wait
for
events
or
timeout
after
periodic
chores
interval
handle
eventsperiodic_chores
healthd
main
loop
blocks
on
the
linux
api
to
multiplex
read
operations
on
three
descriptors
and
registers
actions
for
each
as
shown
in
the
following
table
table
5
1
the
file
descriptors
held
by
and
their
purpose
descriptor
type
purpose
wakealarm_fd
timerfd
timer
set
to
fire
every
seconds
upon
wakeup
runs
event_fd
netlink
reads
kernel
notification
events
only
concerns
itself
with
those
of
the
power
subsystem
these
events
include
battery
and
charger
notifications
and
runs
binder_fd
dev
binder
listener
updates
by
framework
clients
when
acting
as
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
the
first
descriptor
polled
is
the
which
uses
for
its
periodic
chores
two
interval
types
are
used
fast
1
minute
when
on
ac
power
and
slow
10
minutes
on
battery
the
only
chore
presently
defined
is
which
updates
battery
statistics
in
healthd's
role
as
the
this
is
also
called
when
events
from
the
subsystem
are
received
over
netlink
from
makes
no
attempt
to
parse
the
events
and
merely
refereshes
the
battery
statistics
the
latter
mode
is
required
in
order
for
to
respond
to
events
such
as
charger
dis
connection
or
other
power
management
alerts
finally
the
is
used
to
interact
with
the
framework
listeners
primarily
the
as
described
in
the
next
chapter
experiment
observing
using
the
powerful
utility
you
can
watch
behind
the
scenes
by
attaching
to
its
process
id
as
root
and
calling
on
the
api
can
get
notifications
of
system
calls
because
anything
meaningful
a
process
does
goes
through
a
system
call
this
will
provide
a
detailed
trace
of
the
activity
and
reveal
the
names
of
the
sysfs
files
uses
to
obtain
its
statistics
as
shown
in
the
following
annotated
output
output
5
3
using
on
interestingly
enough
in
many
android
releases
the
call
returns
einval
invalid
argument
not
creating
and
thus
defaulting
to
polling
on
the
as
an
event
source
alone
kdswhu
9
dhprqv
root
htc_m8wl
ls
l
proc
healthd_pid
fd
cut
c
1
10,55
lrwx
0
dev
null
lrwx
1
dev
null
lrwx
2
dev
null
output
log
to
kernell
wx
3
dev
__kmsg__
deleted
lrwx
4
socket
6951
lrwx
5
dev
binder
lrwx
6
anon_inode
eventpoll
l
wx
7
dev
cpuctl
apps
tasks
event_fd
netlink
socket
binder_fd
epollfd
fg_cgroup_fd
libcutils
l
wx
8
dev
cpuctl
apps
bg_non_interactive
tasks
bg_cgroup_fd
libcutils
lr
x
9
dev
__properties__
r
o
property
fd
root
htc_m8wl
strace
p
healthd_pid
process
healthd_pid
attached
interrupt
to
quit
healthd
patiently
polling
0xffffffff
indefinitely
until
an
fd
signals
an
event
epoll_wait
0x6
0xbebb5898
0x2
0xffffffff
1
netlink
msg
received
on
fd
4
event_fd
indicating
core
state
change
going
offline
recvmsg
4
msg_name
12
sa_family
af_netlink
pid
0
groups
00000001
msg_iov
1
offline
devices
system
cpu
cpu1
1024
msg_controllen
24
healthd's
not
interested
so
it
goes
back
to
polling
epoll_wait
0x6
0xbebb5898
0x2
0xffffffff
1
message
indicating
change
in
battery
status
recvmsg
4
msg_name
12
sa_family
af_netlink
pid
0
groups
00000001
msg_iov
1
change
devices
platform
htc_bat
1024
msg_controllen
24
cmsg_len
24
cmsg_level
sol_socket
cmsg_type
scm_credentials
pid
0
uid
0
gid
0
msg_flags
0
0
488
healthd
goes
into
a
flurry
of
statistics
collection
opening
and
closing
files
open
sys
class
power_supply
battery
present
o_rdonly
10
is
battery
present
2read
10
1
n
16
yes
1
close
10
0
open
sys
class
power_supply
battery
capacity
o_rdonly
10
what
is
its
capacity
3read
10
96
n
128
96
close
10
0
open
sys
class
power_supply
battery
batt_vol
o_rdonly
10
voltage
read
10
4303
n
128
5
close
10
0
open
sys
class
power_supply
wireless
online
o_rdonly
10
alas
no
wireless
charging
2read
10
0
n
128
for
the
m8
close
10
0
report
to
kernel
logwrite
3
6
healthd
battery
l
96
v
4
t
2
51
51
ioctl
5
binder_write_read
0xbebb5070
0
epoll_wait
0x6
0xbebb5898
0x2
0xffffffff
report
to
client
listeners
back
to
polling
file
users
morpheus
documents
android
book
services
ii.html
batterystats
experiment
observing
cont
note
the
sysfs
psuedo
files
sys
class
power_supply
are
standard
in
practice
they
are
symbolic
links
to
the
specific
platform
device
nodes
which
change
between
devices
as
an
improvement
on
the
above
you
might
want
to
send
the
into
the
background
by
using
and
then
disconnect
and
reconnect
the
usb
cable
you
will
then
see
the
netlink
notification
for
battery
change
followed
by
a
change
in
sys
class
power_supply
usb
online
from
1
to
0
on
disconnect
or
vice
versa
on
connect
as
of
android
l
healthd
supports
you
can
actually
take
the
android
l
binary
from
a
nexus
5
or
emulator
and
copy
it
to
a
device
as
shown
in
this
output
output
5
4
running
l's
on
kk
if
you
use
to
watch
behind
the
scenes
of
you'll
see
the
following
output
file
descriptors
are
different
here
so
they've
been
symbolically
replaced
output
5
5
running
concurrently
on
output
5
4
this
example
aside
from
showing
the
inner
workings
of
on
l
also
demonstrates
an
important
part
of
android
ipc
over
binder
in
the
above
you
can
see
how
a
file
descriptor
has
been
passed
from
the
calling
process
to
binder
internals
are
a
complicated
discussion
in
their
own
right
and
are
left
for
volume
ii
of
this
work
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
before
only
kk
healthd
note
old
service
name
batterypropreg
root
htc_m8wl
service
list
grep
batteryprop
91
batterypropreg
android.os.ibatterypropertiesregistrar
root
htc_m8wl
data
local
tmp
healthd.l
run
healthd
from
l
1
7287
after
new
service
name
batteryproperties
added
name
is
different
so
no
conflict
root
htc_m8wl
service
list
grep
batteryprop
0
batteryproperties
android.os.ibatterypropertiesregistrar
l
diff
name
same
iface
92
batterypropreg
android.os.ibatterypropertiesregistrar
calling
dumpsysroot
htc_m8wl
dumpsys
batteryproperties
ac
0
usb
1
wireless
0
status
5
health
2
present
1
level
100
voltage
4
temp
273
epoll_pwait
epoll_fd
epollin
u32
37597
u64
12884939485
2
1
null
1
0
incoming
binder
req
4
ioctl
binder_fd
binder_write_read
0xbeab1748
write
tasks
healthd_pid
4
make
healthd
foreground
write
output
to
binder
supplied
file
descriptor
make
healthd
background
write
new_fd
ac
0
usb
1
wireless
0
n
25
25
write
new_fd
status
5
health
2
present
1
n
31
31
write
new_fd
level
100
voltage
4
temp
273
n
32
32
fsync
new_fd
1
einval
invalid
argument
ioctl
binder_fd
binder_write_read
0xbeab1600
0
close
new_fd
0
write
tasks
healthd_pid
4
4
ioctl
binder_fd
binder_write_read
0xbeab1758
0
file
users
morpheus
documents
android
book
ipc.html
binder
healthd
as
charger
in
android
versions
leading
up
to
l
android
had
a
special
daemon
which
was
started
by
when
the
system
was
detected
to
boot
in
charger
mode
via
a
directive
containing
only
a
single
service
in
l
has
been
merged
into
which
makes
sense
as
s
main
task
is
observing
the
battery
state
anyway
when
running
as
healthd
starts
up
in
a
manner
similar
to
s
additional
personae
and
described
previously
in
other
words
bin
charger
is
now
merely
a
symbolic
link
to
sbin
healthd
which
also
starts
with
a
command
line
argument
the
daemon
is
responsible
for
relaying
the
battery
status
graphically
to
the
user
while
the
device
is
charging
it
does
so
using
the
minui
library
which
is
covered
in
depth
in
volume
ii
though
merely
a
speculation
it
is
likely
that
will
be
augmented
and
play
an
increasingly
larger
role
in
android
possibly
starting
with
l
a
hint
as
to
its
importance
can
be
found
in
the
fact
that
aside
from
it
being
critical
it
is
also
one
of
the
few
daemons
that
have
made
it
into
the
root
file
system
it's
in
sbin
and
not
system
bin
like
most
others
lmkd
android
l
android
l
uses
another
specialized
core
service
class
daemon
called
it
is
defined
in
the
init.rc
as
follows
listing
5
4
the
definition
in
init.rc
the
provides
an
interface
to
the
kernel's
low
memory
killer
lmk
mechanism
which
is
an
androidism
i.e
a
feature
present
in
android
kernels
but
not
linux
ones
the
lmk
allows
android
finer
control
over
the
linux
out
of
memory
oom
mechanism
which
automatically
kills
tasks
during
memory
pressure
using
the
proc
pid
oom_score_adj
files
the
can
adjust
the
oom
score
of
processes
making
them
more
or
less
killable
that
is
prone
to
being
killed
when
the
system
experiences
memory
pressure
the
linux
oom
mechanism
is
discussed
in
detail
in
a
later
volume
has
two
possible
modes
of
operation
depending
on
whether
or
not
the
lmk
androidism
is
detected
if
present
merely
writes
oom
score
adjustment
values
to
the
target
processes
proc
entries
leaving
it
to
the
lmk
module
to
perform
the
actual
killing
on
low
memory
pressure
in
kernels
without
lmk
however
also
takes
it
upon
itself
to
respond
to
memory
pressure
events
and
perform
the
actual
killing
that
is
sending
to
the
process
maintains
a
process
hash
table
to
allow
it
to
quickly
look
up
processes
and
their
memory
scores
as
with
all
the
other
daemons
discussed
in
this
chapter
uses
to
simultaneously
wait
on
input
from
multiple
sockets
the
main
socket
dev
socket
lmkd
is
the
one
created
for
it
by
init
which
is
listening
for
connections
the
only
expected
client
is
the
discussed
in
the
next
chapter
which
uses
this
socket
to
notify
the
daemon
which
process
needs
to
have
its
score
adjusted
via
the
processlist
class
when
the
in
kernel
lmk
is
not
available
i.e
its
files
in
sys
module
lowmemorykiller
cannot
be
found
additionally
listens
on
the
memory
cgroup
files
to
pick
up
memory
pressure
events
this
is
shown
in
figure
5
3
kdswhu
9
dhprqv
file
users
morpheus
documents
android
book
services
ii.html
activitymanager
file
users
morpheus
documents
android
book
android_src_root
l
l
base
services
core
java
com
android
server
am
processlist.java
figure
5
3
the
flow
of
when
responding
to
memory
pressure
events
that
is
in
cases
where
an
in
kernel
low
memory
killer
cannot
be
used
parses
the
kernel's
proc
zoneinfo
entry
to
extract
the
following
values
nr_free_pages
amount
of
free
memory
in
units
of
4k
nr_file_pages
amount
of
memory
mapped
by
files
in
units
of
4k
nr_shmem
amount
of
shared
memory
these
pages
are
used
by
multiple
processes
and
are
therefore
decremented
from
the
file
mapped
page
count
nr_totalreserve_pages
amount
of
reserved
system
memory
these
pages
are
free
but
aren't
really
usable
so
they
are
decremented
from
the
free
count
the
then
proceeds
to
kill
processes
until
meeting
the
adjusted
free
and
file
mapped
targets
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
observing
at
the
time
of
writing
the
android
source
code
for
l
hasn't
been
made
available
aside
from
a
very
limited
preview
which
hasn't
proven
helpful
the
binaries
however
are
available
for
both
the
nexus
5
and
the
android
emulator
it
is
therefore
easy
to
reverse
engineer
them
in
a
level
of
detail
sufficient
for
this
work
both
static
analysis
i.e
disassembly
and
dynamic
analysis
runtime
debugging
methods
have
been
used
the
method
shown
previously
with
using
proves
its
efficacy
once
again
note
that
cannot
be
backported
into
kitkat
as
it
relies
on
the
seqpacket
sockets
created
for
it
by
init
to
communicate
with
the
frameworks
output
5
6
using
to
figure
out
looking
at
the
above
you
can
see
like
other
daemon
blocks
on
the
fd
3
waiting
for
an
event
the
fd
used
for
input
5
is
the
dev
socket
lmkd
the
other
end
of
which
is
connected
to
the
android
messages
are
variable
length
up
to
52
bytes
starting
with
a
message
type
three
message
types
have
been
observed
table
5
2
protocol
messages
constant
type
parameters
lmk_target
0x00000000
integer
array
of
parameters
which
writes
to
sys
module
lowmemorykiller
parameters
minfree
lmk_prio
0x00000001
pid
to
adjust
e.g
0
0
4
5
above
for
pid
1029
and
oom_score_adj
to
set
for
it
lmk_procremove
0x00000002
pid
to
remove
from
monitoring
kdswhu
9
dhprqv
root
lemulator
ls
l
proc
lmkd_pid
fd
cut
c1
10,55
lrwx
0
dev
null
lrwx
1
dev
null
lrwx
10
socket
7360
dev
socket
lmkd
listening
lrwx
2
dev
null
lrwx
3
anon_inode
eventpoll
lrwx
4
socket
7364
dev
socket
logdw
to
logd
lrwx
5
socket
7653
dev
socket
lmkd
to
activitymanager
lr
x
8
dev
__properties__
root
lemulator
strace
p
lmkd_pid
epoll_pwait
3
epollin
u32
3069216345
u64
37428954713
2
1
null
8
1
read
5
0
0
0
1
0
0
4
5
0
0
0
v
52
12
openat
at_fdcwd
proc
1029
oom_score_adj
o_wronly
6
write
6
647
3
3
close
6
0
logd
android
l
android
l
defines
a
new
much
needed
logging
mechanism
with
its
daemon
this
daemon
serves
as
a
centralized
user
mode
logger
as
opposed
to
the
traditional
android's
dev
log
files
implemented
in
kernel
ring
buffers
this
not
only
addresses
the
main
shortcomings
of
the
ring
buffers
their
small
size
and
resident
memory
requirements
but
also
allows
to
integrate
with
selinux
auditing
by
registering
itself
as
the
which
receives
the
selinux
messages
from
the
kernel
via
netlink
and
records
them
in
the
system
log
another
important
new
feature
provided
by
is
log
pruning
which
allows
the
automatic
clearing
or
retaining
of
log
records
from
specific
uid
this
aims
to
solve
the
problem
of
logs
being
flooded
with
messages
from
overly
verbose
processes
which
make
it
harder
to
separate
the
wheat
from
the
chaff
allows
for
white
lists
uids
or
pids
whose
messages
will
be
retained
for
longer
and
blacklists
uids
or
pids
whose
messages
will
be
quickly
pruned
using
the
new
switch
of
the
service
is
defined
in
init.rc
as
follows
listing
5
5
the
definition
in
init.rc
note
this
service
is
designed
with
not
one
but
four
sockets
dev
socket
logd
the
control
interface
socket
dev
socket
logdw
a
write
only
socket
permissions
022
dev
socket
logdr
a
read
write
socket
designed
for
reading
unlike
the
logd
un
x
domain
socket
this
is
a
seqpacket
sequential
packet
socket
an
unnamed
netlink
socket
used
when
also
provides
functionality
for
selinux
messages
the
spawns
listener
threads
over
its
sockets
as
well
as
threads
for
clients
spawned
on
demand
the
threads
are
individually
named
using
so
you
can
see
them
for
yourself
in
s
proc
pid
task
when
is
running
as
with
the
traditional
logs
recognizes
the
log
buffers
of
main
radio
events
and
system
along
with
a
new
log
crash
added
in
l
these
logs
are
identified
by
their
log
ids
lids
numbered
0
through
5
respectively
system
properties
used
by
the
recognizes
several
system
properties
all
in
the
namespace
which
toggle
its
behavior
those
are
well
documented
in
the
readme.property
file
in
s
directory
shown
here
for
convenience
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
listing
5
6
properties
used
by
controlling
clients
can
connect
to
dev
socket
logd
to
control
logd
with
an
array
of
protocol
commands
commonly
the
client
doing
so
is
the
command
which
has
been
modified
to
use
the
socket
rather
than
the
legacy
codes
over
dev
log
the
commands
are
shown
in
table
5
3
table
5
3
protocol
commands
command
logcat
switch
purpose
clear
lid
for
callers
with
log
credentials
this
clears
the
specified
log's
buffers
getlogsize
lid
get
maximum
size
of
log
specified
by
lid
getlogsizeused
lid
get
actual
size
of
log
specified
by
lid
setlogsize
lid
set
maximum
size
of
log
specified
by
lid
getstatistics
lid
for
callers
with
log
credentials
this
retrieves
statistics
of
log
messages
by
pid
etc
getprunelist
get
prune
list
all
logs
setprunelist
set
prune
list
all
logs
shutdown
force
daemon
exit
surprisingly
this
doesn't
require
any
credentials
the
commands
in
gray
require
the
caller
to
possess
log
credentials
be
root
possess
a
primary
gid
of
root
system
or
log
or
a
secondary
gid
of
log
to
verify
the
last
case
the
code
of
uses
a
crude
method
of
parsing
the
caller's
proc
pid
status
and
sifting
through
its
groups
line
writing
to
logd
logging
android's
logging
mechanism
is
supplied
by
and
therefore
applications
remain
oblivious
to
the
underlying
implementation
of
logging
as
of
l
both
bionic
and
can
be
compiled
to
use
by
ing
which
then
directs
all
the
logging
apis
to
use
rather
than
the
traditional
dev
log
device
files
which
have
in
effect
become
legacy
and
apparently
removed
in
m
effectuating
the
change
is
a
simple
matter
since
all
system
logging
apis
eventually
funnel
to
s
or
bionic's
which
then
open
the
socket
instead
of
dev
log
and
write
the
log
message
to
it
figure
5
4
shows
the
flow
of
log
messages
from
the
application
all
the
way
to
a
similar
flow
occurs
for
event
log
android.util.eventlog
messages
kdswhu
9
dhprqv
http
developer.android.com
reference
android
util
eventlog.html
figure
5
4
the
android
logger
architecture
reading
from
logd
logcat
the
familiar
command
in
l
still
sports
the
same
command
line
arguments
it
has
in
the
past
its
underlying
implementation
however
has
rewritten
to
use
through
an
updated
api
clients
such
as
logcat
can
connect
to
the
logd
reader
socket
dev
socket
logdr
and
instruct
the
instance
of
to
provide
the
log
by
writing
parameters
to
it
as
shown
in
the
following
table
table
5
4
parameters
recognized
by
over
the
reader
socket
parameter
provides
lids
value
log
ids
start
value
start
time
from
log
to
dump
default
is
epoch
start
of
log
tail
value
number
of
lines
from
log
to
dump
as
per
command
pid
value
filter
by
pid
originator
of
log
messages
dumpandclose
tells
reader
thread
to
exit
when
log
dumping
is
done
log
records
are
serialized
into
a
structures
before
being
passed
to
the
reader
over
the
socket
the
structure
format
is
shown
in
the
following
figure
calling
application
jni
liblog
android.util.log
android_util_log.cpp
d
tag
msg
priority
debug
e
tag
msg
priority
error
i
tag
msg
priority
info
v
tag
msg
priority
verbose
w
tag
msg
priority
warn
println_native
log_id_main
priority
tag
msg
liblog
__android_log_buf_write
bufid
priority
tag
msg
write_to_log
filedes
vector
count
dev
socket
logdw
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
figure
5
5
the
format
of
a
message
putting
all
the
above
together
we
can
now
observe
in
action
through
the
command
as
shown
in
the
following
experiment
experiment
observing
using
will
allow
you
a
behind
the
scenes
look
at
the
workings
of
including
its
connection
to
the
command
it
sends
to
dump
the
log
and
the
serialization
of
log
messages
output
5
7
under
annotated
sifting
through
s
thread
to
find
and
trace
the
thread
instance
will
show
you
the
logging
from
the
perspective
of
and
is
left
as
an
exercise
for
the
reader
kdswhu
9
dhprqv
tracing
logcat
during
an
adb
logcat
operation
shows
messages
are
received
from
file
descriptor
3
and
sent
to
file
descriptor
1
stdout
root
generic
strace
logcat
connect
3
sa_family
af_local
sun_path
dev
socket
logdr
20
0
write
3
stream
lids
0,3,4
17
17
dump
main
system
crash
16
14
bytes
payload
30
24
bytes
header
t
1
340
pid
3
0
0
0
system
recvfrom
3
16
30
0t
1
0
0m
1
0
0
275bbt
2374
3
0
0
0
6act
5120
0
null
0
3668
write
1
e
activitymanager
340
anr
in
5472
5472
in
case
you
missed
the
connect
2
call
above
e.g
if
attaching
to
logcat
you
can
still
look
through
its
proc
fd
entry
to
see
file
descriptor
3
is
a
socket
which
you
can
also
deduce
from
the
use
of
recvfrom
2
root
generic
cd
proc
logcat_pid
fd
root
generic
proc
337
fd
ls
l
grep
3
lrwx
root
root
2014
11
11
14
24
3
socket
2442
looking
through
proc
net
unix
which
shows
domain
sockets
we
can
find
the
socket
and
its
remote
endpoint
next
inode
number
which
happens
to
be
logdr
root
generic
proc
337
fd
grep
2442
proc
net
unix
00000000
00000003
00000000
00000000
0005
03
2442
root
generic
proc
337
fd
grep
2443
proc
net
unix
00000000
00000003
00000000
00000000
0005
03
2443
dev
socket
logdr
vold
the
android
is
a
volume
management
daemon
this
concept
which
originally
appeared
in
the
now
deceased
solaris
operating
system
employs
a
user
space
daemon
to
automatically
mount
file
systems
volumes
as
they
are
detected
by
the
kernel
beginning
with
honeycomb
also
enables
file
system
encryption
in
particular
data
listing
5
7
shows
its
definition
in
init.rc
listing
5
7
vold
definitions
in
init.rc
kitkat
is
the
only
daemon
to
have
an
attribute
which
specifies
an
i
o
priority
for
the
service
and
share
a
common
codebase
in
the
form
of
which
is
statically
compiled
into
both
binaries
the
provides
file
system
mounting
and
checking
functionality
by
wrapping
together
system
calls
such
as
and
hard
coded
calls
the
external
binaries
system
bin
e2fsck
together
configuration
true
to
a
mount
daemon
requires
a
configuration
file
to
list
known
file
systems
and
their
mount
points
this
file
is
referred
to
as
the
file
system
table
or
fstab
for
short
prior
to
4.3
it
was
called
system
etc
vold.fstab
and
mapped
the
file
systems
by
their
block
device
paths
in
sys
as
of
4.3
however
the
file
has
been
moved
to
the
rootfs
and
has
been
made
device
specific
by
renaming
to
fstab
ro.hardware
similar
to
the
device
specific
rc
files
it
has
also
been
formatted
along
the
lines
of
classic
un
x
fstab
files
like
so
listing
5
8
post
4.3
fstab
ro.hardware
syntax
you
may
remember
we
encountered
the
fstab
ro.hardware
file
in
the
discussion
of
how
init
mounts
file
systems
evaluates
the
file
in
a
similar
manner
to
init
using
the
shared
code
but
whereas
init
ignores
lines
with
the
concerns
itself
with
these
lines
only
the
field
though
incorrectly
specified
in
the
documentation
as
being
ignored
is
passed
verbatim
to
the
system
call
the
options
are
parsed
by
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
init.html
mounting
table
5
5
options
option
purpose
wait
wait
for
file
system
to
mount
for
up
to
20
seconds
before
continuing
check
perform
a
file
system
check
on
the
file
system
prior
to
mounting
nonremovable
volume
is
not
a
removable
volume
i.e
not
an
sd
card
recoveryonly
file
system
only
mounted
during
recovery
noemulatedsd
tells
vold
this
is
not
an
emulated
sd
card
if
vfat
formatted
asec
can
be
used
verify
as
of
kitkat
enable
the
linux
kernel's
dm_verity
to
cryptographically
verify
the
filesystem
integrity
described
in
chapter
8
zramsize
compressed
ram
zram
size
swapprio
specifies
priority
of
partition
as
swap
partition
length
denotes
the
size
of
the
partition
voldmanaged
partition
is
managed
by
vold
expects
tag:number
with
partition
number
or
auto
encryptable
specifies
the
location
of
the
keys
for
an
encrypted
partition
forceencrypt
l
encrypt
on
first
boot
architecture
the
internally
comprises
three
components
responsible
for
maintaining
volume
state
and
handling
various
volume
operations
this
singleton
class
provides
all
the
framework
facing
functionality
responsible
for
listening
on
kernel
netlink
events
of
the
subsystems
using
the
which
passes
them
to
the
volumemanager
responsible
for
listening
on
the
dev
socket
vold
socket
for
commands
issued
by
the
framework
and
relaying
the
output
of
those
commands
or
other
events
received
from
figure
5
6
presents
the
structure
of
figure
5
6
the
internal
architecture
of
kdswhu
9
dhprqv
file
users
morpheus
documents
android
book
security.html
diskver
the
main
client
of
is
though
applications
cannot
call
this
service
directly
and
must
instead
use
the
maintains
a
which
uses
the
client
side
of
the
socket
to
send
commands
to
s
most
android
devices
have
a
vdc
utility
which
you
can
use
to
send
these
commands
to
vold
yourself
as
root
or
listen
to
file
system
mounting
events
using
as
shown
in
output
5
8
output
5
8
the
output
generated
by
sd
card
events
the
utility
is
nothing
more
than
a
tiny
unix
domain
socket
client
whose
source
can
be
found
in
system
vold
vdc.c
the
commands
which
it
relays
verbatim
to
are
shown
in
table
5
9
table
5
6
commands
cmd
subcmd
arguments
purpose
dump
dumps
loop
device
mapper
and
mounted
filesystems
volume
list
list
mounted
volumes
debug
on
off
toggle
debug
messages
for
formatting
unmounting
mount
path
mount
a
file
system
unmount
path
force
_and_revert
unmount
a
file
system
possibly
forcefully
un
share
ums
share
unshare
usb
mass
storage
shared
ums
return
share
state
enabled
disabled
of
usb
mass
storage
mkdirs
path
make
a
directory
mount
point
format
wipe
path
format
a
fat
volume
optionally
erasing
its
contents
first
storage
users
list
pids
using
a
mounted
volume
like
mountall
call
on
fs_mgr
to
mount
all
filesystems
in
fstab
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
root
htc_m8wl
vdc
monitor
connected
to
vold
sd
card
inserted
605
volume
ext_sd
storage
ext_sd
state
changed
from
0
no
media
to
2
pending
605
volume
ext_sd
storage
ext_sd
state
changed
from
2
pending
to
1
idle
unmounted
630
volume
ext_sd
storage
ext_sd
disk
inserted
179
128
630
volume
ext_sd
storage
ext_sd
disk
inserted
179
128
605
volume
ext_sd
storage
ext_sd
state
changed
from
1
idle
unmounted
to
3
checking
613
ext_sd
storage
ext_sd
8a07
a343
614
ext_sd
storage
ext_sd
605
volume
ext_sd
storage
ext_sd
state
changed
from
3
checking
to
4
mounted
sd
card
removed
632
volume
ext_sd
storage
ext_sd
bad
removal
179
129
605
volume
ext_sd
storage
ext_sd
state
changed
from
4
mounted
to
5
unmounting
613
ext_sd
storage
ext_sd
614
ext_sd
storage
ext_sd
605
volume
ext_sd
storage
ext_sd
state
changed
from
5
unmounting
to
1
idle
unmounted
631
volume
ext_sd
storage
ext_sd
disk
removed
179
128
605
volume
ext_sd
storage
ext_sd
state
changed
from
1
idle
unmounted
to
0
no
media
table
5
7
commands
cont
cmd
subcmd
arguments
purpose
asec
list
list
all
android
secure
storage
containers
create
cid
mb
fstype
key
uid
create
new
asec
with
cid
as
a
filesystem
fstype
of
size
mb
destroy
cid
force
destroy
the
asec
identified
by
cid
possibly
forcefully
finalize
cid
finalize
container
cid
fixperms
cid
gid
filename
fix
permissions
in
container
cid
so
as
to
be
owned
by
gid
mount
cid
key
uid
mount
the
container
cid
under
app
id
uid
with
key
unmount
cid
force
unmount
the
container
cid
possibly
forcefully
if
in
use
path
cid
return
the
path
to
the
container
cid
rename
old_cid
new_cid
change
the
name
of
old_cid
to
new_cid
fspath
cid
return
file
system
path
corresponding
to
cid
obb
list
list
all
mounted
opaque
binary
blobs
mount
filename
key
ownergid
mount
the
opaque
binary
blob
specified
by
filename
for
app
ownergid
with
optional
key
unmount
source
force
unmount
the
opaque
binary
blob
specified
by
source
filename
path
source
cryptfs
restart
signal
to
restart
frameworks
cryptocomplete
query
if
filesystem
is
fully
encrypted
enablecrypto
inplace
wipe
password
encrypt
filesystem
possibly
erasing
first
changepw
default
password
pin
pattern
new_passwd
change
encryption
password
checkpw
passwd
check
if
supplied
password
can
mount
encrypted
fs
verifypw
passwd
used
by
getfield
name
get
metadata
field
from
cryptfs
setfield
name
value
set
metadata
field
in
cryptfs
fstrim
do
d
trim
issues
an
allowing
mmc
driver
to
wipe
unused
blocks
android
l
removes
support
for
xwarp
commands
a
relic
of
older
versions
of
android
which
used
yaffs
with
the
move
to
ext4
this
has
been
deprecated
and
the
commands
while
they
still
exist
through
kk
fail
on
missing
file
requirements
of
particular
interest
is
s
filesystem
encryption
handling
the
android
documentation1
provides
a
detailed
explanation
of
the
process
as
implemented
in
honeycomb
as
does
this
book
next
kdswhu
9
dhprqv
file
users
morpheus
documents
android
book
filesystems.html
asec
file
users
morpheus
documents
android
book
filesystems.html
obb
http
source.android.com
devices
tech
encryption
android_crypto_implementation.html
decrypting
filesystems
with
honeycomb
android
brings
support
for
disk
encryption
by
extending
linux's
mechanism
which
already
provides
the
foundation
for
the
mechanism
android
enables
the
entire
user
data
partition
to
be
encrypted
the
system
partition
still
remains
very
much
cleartext
because
the
system
has
to
somehow
boot
but
this
is
quite
fine
the
system
partition
is
for
all
intents
and
purposes
identical
on
all
devices
and
never
actually
holds
any
user
specific
data
so
there
would
be
little
advantage
in
encrypting
it
the
feature
is
described
in
more
detail
in
chapter
8
at
a
high
level
view
however
suffice
it
to
say
that
transparently
encrypts
and
decrypts
block
devices
the
password
required
for
doing
so
however
needs
to
be
supplied
in
user
mode
android
derives
the
passcode
or
pattern
the
user
is
already
using
for
the
lock
screen
and
uses
the
activity
to
prompt
the
user
for
the
credentials
required
to
unlock
the
device
without
which
cannot
be
mounted
what
follows
therefore
is
a
choreography
between
driving
the
system
startup
providing
the
actual
mount
services
and
handling
the
ui
displayed
to
the
user
this
is
shown
in
figure
5
7
figure
5
7
the
interaction
between
and
during
boot
calls
on
the
to
mount
the
file
systems
if
none
are
encrypted
iw
sets
the
to
unencrypted
and
enqueues
any
actions
associated
with
the
nonencrypted
trigger
usually
those
services
in
the
class
the
android
explorations
blog2
shows
how
to
decouple
the
encryption
password
from
the
pattern
by
using
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
dmcrypt
file
users
morpheus
documents
android
book
note1
http
nelenkov.blogspot.com
2012
08
changing
androids
disk
encryption.html
if
a
file
system
is
encrypted
however
an
encrypted
mount
will
obviously
fail
unless
the
password
is
supplied
the
mounts
the
filesystem
instead
as
a
tmpfs
and
returns
1
to
which
sets
to
encrypted
and
informs
of
the
need
to
decrypt
data
by
setting
to
1
prior
to
kitkat
would
use
the
value
of
the
property
as
mount
options
but
these
options
are
now
hardcoded
the
mounting
of
data
is
a
prerequisite
for
loading
the
ui
frameworks
since
those
need
to
write
various
files
as
a
temporary
filesystem
however
the
data
mount
holds
no
data
when
the
is
set
the
only
runs
the
core
apps
and
services
the
activity
registers
itself
as
the
home
screen
using
an
with
a
higher
priority
so
as
to
ensure
it
starts
first
when
it
loads
it
checks
the
value
of
in
its
if
unset
it
simply
exits
making
room
for
the
real
home
screen
if
the
filesystem
is
encrypted
however
the
start
an
async
in
its
to
contact
the
calling
its
to
see
if
the
partition
is
indeed
properly
encrypted
recall
that
the
is
connected
to
the
socket
it
can
thus
send
the
daemon
the
command
this
makes
check
if
the
encryption
is
indeed
recoverable
as
it
may
be
that
the
encryption
has
been
interrupted
rendering
data
unmountable
and
forcing
the
user
to
do
a
recovery
reset
if
the
operation
is
successful
the
calls
setupui
to
input
the
user
for
the
decryption
password
or
sequence
it
passes
this
again
to
which
sends
it
to
as
a
command
if
the
password
is
correct
the
sends
the
command
this
makes
update
the
property
to
and
sleep
for
2
seconds
in
the
hopes
that
all
the
services
loaded
under
the
class
will
be
stopped
and
the
tmpfs
data
can
be
unmounted
if
the
unmount
is
successful
remounts
the
now
unecrypted
data
partition
and
again
updates
the
property
first
to
since
those
reside
in
data
next
to
to
get
to
set
up
any
paths
in
data
defined
in
init.rc
and
then
to
which
makes
restart
the
frameworks
the
properties
must
be
defined
in
init.rc
to
arm
the
approriate
triggers
as
shown
in
listing
5
11
listing
5
9
actions
in
init.rc
relating
to
encryption
events
kdswhu
9
dhprqv
encrypting
filesystems
encrypting
file
systems
is
handled
in
a
similar
manner
to
decrypting
them
once
again
the
ui
is
supplied
by
with
the
providing
the
dalvik
level
bridge
to
the
ui
prompts
the
user
for
the
encryption
password
and
verifies
the
device
is
on
ac
power
to
prevent
any
power
outage
which
may
disrupt
the
encryption
the
s
method
is
called
which
sends
the
with
either
to
format
data
before
encrypting
it
or
argument
and
the
password
upon
getting
the
command
and
verifying
it
can
proceed
sets
the
to
this
causes
to
stop
all
services
but
the
core
ones
this
is
exactly
the
mirror
image
of
the
state
the
system
is
in
while
booting
before
the
user
password
is
entered
and
data
can
be
safely
unmounted
then
sets
to
start
at
0
and
to
to
get
to
restart
the
main
services
once
again
loads
as
the
home
app
upon
seeing
it
loads
the
status
bar
ui
if
all
goes
well
the
progress
bar
reaches
100
if
not
is
set
to
an
string
l
offers
resumable
encryption
but
if
resumption
fails
the
user
may
be
left
with
no
choice
but
to
reset
the
device
to
defaults
the
technical
aspects
of
encryption
as
well
as
the
kernel
perspective
are
discussed
in
chapter
8
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
dataenc
network
services
netd
android
uses
a
dedicated
daemon
to
control
network
interfaces
and
configuration
management
if
you've
ever
used
tethering
firewalling
or
wifi
access
point
features
or
even
a
basic
dns
lookup
consider
yourself
a
proud
client
of
the
daemon
is
defined
in
init.rc
listing
5
10
the
service
defition
in
init.rc
the
shares
many
structural
similarities
with
and
in
fact
shares
some
code
with
it
using
the
native
class
among
others
in
its
socket
handlers
figure
5
8
shows
the
architecture
which
you
can
compare
and
contrast
with
that
of
q.v
figure
5
6
unlike
each
of
s
subcomponents
uses
a
dedicated
socket
s
structure
comprises
four
components
discussed
next
the
responsible
for
listening
on
the
dev
socket
netd
socket
for
commands
issued
by
the
framework
specifically
described
in
detail
in
the
next
chapter
and
sending
notifications
broadcasts
to
connected
clients
as
with
the
emulator
includes
a
simple
utility
which
can
be
used
as
a
client
to
issue
commands
to
and
listen
on
events
using
as
shown
in
output
5
9
output
5
9
the
output
generated
by
connecting
to
a
wi
fi
network
internally
the
dispatches
the
commands
to
one
of
several
internal
controller
classes
each
responsible
for
a
specific
aspect
of
functionality
shown
in
table
5
8
table
5
8
controllers
and
their
subcommands
controller
commands
provided
by
used
for
bandwidthcontroller
system
bin
ip
6
tables
network
quota
control
clatdcontroller
system
bin
clatd
464xlat
ipv4
over
ipv6
control
firewallcontroller
system
bin
iptables
firewalling
idletimercontroller
system
bin
ip
ip
6
tables
idle
timer
on
interfaces
interfacecontroller
proc
sys
net
network
interfaces
natcontroller
system
bin
ip
ip
6
tables
network
address
translation
pppcontroller
system
bin
pppd
vpns
softapcontroller
system
bin
hostapd
wi
fi
tethering
p2p
tethercontroller
system
bin
dnsmasq
proc
sys
net
ipv4
ip_forward
usb
and
wi
fi
tethering
kdswhu
9
dhprqv
root
htc_m8wl
ndc
monitor
connected
to
netd
600
iface
linkstate
wlan0
up
614
address
updated
10.100.1.192
21
wlan0
128
0
614
address
updated
fe80
522e
5cff:fef3
9da6
64
wlan0
128
253
file
users
morpheus
documents
android
book
services.html
f5
6
file
users
morpheus
documents
android
book
services
ii.html
nms
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
from
the
figure
you
can
see
that
the
controllers
for
the
most
part
don't
actually
provide
any
functionality
rather
controllers
hide
external
commands
by
calling
to
spawn
the
respective
daemons
or
in
effect
taking
a
shortcut
a
full
discussion
of
controller
internals
along
with
the
daemon
they
spawn
and
the
framework
interface
is
left
for
volume
ii
table
5
9
provides
a
quick
reference
to
the
command
set
expected
by
the
various
controllers
table
5
9
commands
understood
by
the
various
controllers
controller
subcommand
purpose
bandwidth
enable
bandwidth
quota
control
iface
qbytes
set
quota
on
iface
not
to
exceed
qbytes
iface
remove
any
quota
previously
set
on
iface
iface
qbytes
generate
alert
if
bandwidth
on
iface
exceeds
qbytes
iface
remove
an
alert
previously
set
by
alertbytes
generate
alert
if
any
interface
exceeds
alertbytes
get
statistics
for
device
tethering
bytes
set
an
alert
on
bandwidth
bytes
spanning
all
interfaces
uid
uid
add
nice
allowed
apps
by
uid
uid
uid
add
naughty
misbehaving
apps
by
uid
enable
disable
firewall
globally
toggle
the
firewall
functionality
apply
an
iptables
rule
on
an
interface
addr
rule
set
rule
for
outgoing
traffic
by
source
addr
port
rule
set
rule
for
outgoing
traffic
by
destination
uid
rule
apply
an
iptables
rule
for
a
specific
uid
idletimer
list
all
interfaces
iface
enable
idletimer
mechanism
starts
and
flushes
iptables
chains
iface
timeout
classlabel
add
or
remove
a
timer
on
iface
interface
list
all
interfaces
iface
default
secondary
dest
prefix
gateway
add
a
routing
table
entry
iface
mtu
set
maximum
transferrable
unit
size
on
iface
to
mtu
iface
enable
disable
toggle
ipv6
support
on
iface
iface
remove
ip
addresses
of
iface
iface
display
configuration
of
iface
iface
ifconfig
args
set
configuration
of
iface
firewall
marking
l
moved
to
fwmarkd
kdswhu
9
dhprqv
table
5
10
commands
understood
by
the
various
controllers
controller
subcommand
purpose
nat
int_iface
ext_iface
toggle
network
address
translation
ppp
tty
local
remote
dns1
dns2
attach
pppd
to
tty
to
set
up
a
point
to
point
connection
between
local
and
remote
ip
addresses
specifying
optional
name
server
ips
tty
execs
list
ttys
used
by
the
ppp
daemon
as
interfaces
tether
starts
the
dns
masquerading
stop
tethering
kills
using
a
signal
set
list
set
or
list
dns
settings
add
remove
iface
add
remove
tethering
on
iface
enable
disable
status
toggle
ip
forwarding
proc
sys
net
ipv4
ip_forward
or
query
status
resolver
iface
assign
iface
to
be
default
for
dns
lookups
flush
default
interface's
dns
cache
iface
flush
iface
dns
cache
iface
pid
assign
iface
for
process
id
pid
to
use
pid
remove
iface
assignment
for
process
id
pid
iface
low
high
assign
iface
for
aids
low
high
softap
toggle
access
point
by
exec
ing
or
kill
ing
or
query
status
iface
ap
p2p
sta
reload
firmware
iface
ssid
hidden
channel
security
key
set
access
point
parameters
if
any
other
word
but
hidden
is
specified
ap
will
be
broadcast
is
the
responsible
for
listening
on
the
dev
socket
dnsproxyd
socket
for
name
resolution
commands
the
commands
are
shown
in
the
following
table
table
5
11
s
dns
proxying
command
subset
cmd
arguments
purpose
getaddrinfo
name
service
ai_flags
ai_family
ai_socktype
ai_protocol
iface
call
for
the
interface
iface
gai
is
a
more
advanced
and
forward
compatible
alternative
to
the
other
getxxxbyyyy
functions
gethostbyname
iface
name
af
perform
a
forward
lookup
a
aaaa
according
to
af
of
an
ip
address
by
its
hostname
gethostbyaddr
addrstr
addrlen
addrfamily
iface
perform
a
reverse
lookup
ptr
of
a
hostname
by
its
ip
address
android's
libc
implementation
bionic
provides
all
processes
with
library
calls
matching
those
in
5
11
and
implements
them
by
opening
the
unix
domain
socket
connection
to
dev
socket
dnsproxy
in
this
way
all
clients
both
native
and
dalvik
are
redirected
through
the
dns
proxy
functionality
can
then
enforce
restrictions
on
dns
functionality
based
the
calling
process
uid
since
each
uid
represents
a
different
application
this
translates
to
fine
grained
control
of
dns
functionality
on
a
per
app
basis
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
mdnsd
multicast
dns
mdns
is
a
popular
discovery
protocol
first
adopted
by
apple
as
its
bonjour
service
standardized
in
rfc6762
it
is
used
extensively
in
ios's
family
of
air
protocols
e.g
airplay
and
allows
devices
to
find
one
another
by
sending
a
multicast
request
to
group
224.0.0.253
or
ipv6
s
ff02
fc
and
udp
port
5353
unsurprisingly
android
chose
to
adopt
this
vwdqgdug
as
well
and
it
serves
as
the
basis
for
wifi
direct
beginning
with
jellybean
init.rc
defines
the
mdns
service
as
follows
listing
5
11
the
service
defition
in
init.rc
because
of
its
multicast
capabilities
the
service
is
granted
membership
in
both
the
group
allowing
general
tcp
ip
capabilities
and
the
group
allowing
advanced
capabilities
such
as
raw
sockets
and
crafting
non
standard
ip
packets
the
service
listens
on
dev
socket
mdnsd
for
requests
and
has
another
socket
dev
socket
mdns
connected
to
the
frameworks
wrap
the
mdns
functionality
with
the
network
service
discovery
classes
as
of
api
level
16
this
is
discussed
in
greater
detail
in
volume
ii
in
a
chapter
dealing
with
connectivity
the
mdns
implementation
itself
found
in
the
external
mdnsresponder
directory
is
largely
the
same
as
the
open
source
mdns
project
with
the
android
specific
modifications
such
as
the
unix
domain
socket
and
android
logging
clearly
marked
by
blocks
mtpd
though
the
acronym
mtp
is
normally
associated
in
android
and
elsewhere
with
the
media
transfer
protocol
the
couldn't
be
further
from
it
it
is
the
daemon
responsible
for
ppp
and
l2tp
but
not
ipsec
it
is
defined
in
init.rc
as
follows
listing
5
12
the
service
defition
in
init.rc
the
group
permissions
granted
to
mtpd
reflect
its
need
for
network
access
inet
setting
up
a
network
interface
net_admin
and
tunneling
ip
net_raw
as
a
and
service
the
must
be
started
manually
by
setting
the
property
indeed
the
does
so
in
its
inner
class
there
is
no
programming
interface
for
vpn
functionality
which
is
meant
to
be
started
or
stopped
from
the
android
system
gui
kdswhu
9
dhprqv
racoon
racoon
is
a
de
facto
standard
vpn
daemon
as
an
external
project
it
is
not
part
of
android
per
se
but
is
used
extensively
in
both
android
and
ios
to
provide
vpn
services
vpn
connectivity
is
discussed
in
volume
ii
listing
5
13
the
service
defition
in
init.rc
note
that
starts
as
root
in
order
to
bind
the
isakmp
well
known
port
which
is
a
privileged
port
but
then
drops
privileges
this
is
why
it
requires
the
extra
group
memberships
which
as
we
discuss
in
chapter
8
allow
network
connectivity
from
a
strict
security
standpoint
it
would
have
been
better
to
relinquish
root
altogether
and
use
capabilities
in
particular
instead
this
is
especially
important
considering
racoon
has
had
a
history
of
exploits
and
was
in
fact
used
to
jailbreak
ios
5
before
rild
if
your
android
device
is
a
phone
or
3g
lte
connected
tablet
is
undoubtedly
one
of
the
more
important
system
processes
the
radio
interface
layer
daemon
provides
virtually
all
the
telephony
capabilities
for
these
devices
by
interfacing
with
the
baseband
it
is
defined
in
init.rc
as
follows
listing
5
14
the
service
defition
in
init.rc
the
daemon
supplied
by
the
aosp
is
an
empty
shell
after
parsing
its
arguments
it
seeks
out
the
vendor
supplied
ril
library
which
can
be
defined
by
the
argument
specified
in
the
property
the
library
is
dynamically
loaded
and
its
initializer
exported
as
is
called
the
initializer
returns
the
library's
exported
ril
handlers
which
are
then
registered
before
the
daemon
goes
into
its
event
loop
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
paranoid
though
most
users
don't
give
this
a
passing
thought
the
telephony
apis
used
in
today's
mobile
devices
aren't
that
far
from
the
modems
employed
in
the
previous
millenium
in
fact
the
low
level
call
control
is
still
carried
out
with
the
same
set
of
commands
used
by
modems
the
at
commands
which
may
be
familiar
to
anyone
who's
ever
used
minicom
and
kermit
back
in
the
day
the
is
responsible
for
opening
the
telephony
device
which
is
basically
a
serial
port
and
generating
these
commands
the
daemon
also
listens
on
the
device
for
unsolicited
commands
which
are
events
generated
by
the
baseband
for
example
an
incoming
call
figure
5
9
a
bird's
eye
view
of
the
radio
interface
layer
architecture
as
shown
in
the
figure
and
definition
the
daemon
uses
the
dev
socket
rild
to
provide
the
interface
by
means
of
which
the
phone
application
can
connect
to
the
daemon
and
issue
various
phone
related
solicited
requests
e.g
dialing
answering
hanging
up
to
the
baseband
the
also
uses
the
socket
to
propagate
baseband
generated
events
e.g
incoming
text
calls
to
the
application
as
unsolicited
requests
the
socket
is
not
meant
to
be
used
directly
and
is
wrapped
by
the
java
ril
implementation
package
the
daemon
also
listens
on
another
un
x
domain
socket
dev
socket
rild
debug
as
the
name
implies
this
socket
is
intended
for
use
in
debugging
and
is
undocumented
save
for
the
source
of
the
of
it
defines
a
set
of
codes
which
will
cause
requests
to
be
artificially
injected
into
the
ril
you
can
find
a
detailed
discussion
of
the
codes
in
volume
ii
additionally
also
has
its
own
debug
facility
radio
which
results
in
a
dedicated
logging
device
dev
log
radio
inspecting
this
log
file
using
will
dump
plentiful
amounts
of
debug
information
which
may
in
some
versions
of
android
show
the
at
commands
used
by
to
dial
numbers
and
establish
codes
the
radio
interface
layer
is
described
in
greater
detail
in
volume
ii
along
with
the
java
telephony
frameworks
and
the
reference
ril
code
from
the
aosp
kdswhu
9
dhprqv
graphics
and
media
services
android's
graphics
and
media
services
are
integral
to
provide
the
best
user
experience
possible
this
section
provides
a
cursory
glance
with
a
far
more
detailed
discussion
of
their
internals
deferred
to
volume
ii
for
both
audio
and
graphics
surfaceflinger
the
provides
the
heart
of
the
android
graphics
stack
the
notion
of
a
flinger
or
in
other
words
a
compositor
is
a
component
which
merges
one
or
more
layers
of
input
into
a
single
layer
of
output
in
the
case
of
the
components
are
graphics
surfaces
instances
of
which
are
either
rendered
by
the
framework
as
the
user
lays
out
various
views
or
by
the
developer
in
the
case
of
raw
or
gl
surfaces
to
communicate
with
the
the
framework
looks
up
the
surfaceflinger
service
using
the
flinger
therefore
needs
no
sockets
and
its
definition
in
init.rc
is
simple
listing
5
17
surfaceflinger
definition
in
init.rc
though
certainly
deserving
of
a
deeper
discussion
and
the
focus
of
the
graphics
chapter
in
volume
ii
s
place
in
the
android
graphics
architecture
can
be
conceptually
grasped
at
a
high
level
in
the
following
somewhat
simplified
diagram
figure
5
10
a
high
level
view
of
s
functionality
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
bootanimation
the
service
is
a
small
binary
in
which
is
exclusive
used
by
as
a
placeholder
while
it
and
the
media
frameworks
are
loading
it
is
defined
in
init.rc
thus
listing
5
18
definition
in
init.rc
the
binary
is
essentially
a
very
simple
one
it
starts
up
and
looks
for
one
of
three
zip
files
system
media
bootanimation
encrypted.zip
used
if
the
property
is
set
indicating
the
file
system
is
encrypted
data
local
bootanimation.zip
allowing
the
advanced
user
to
drop
their
own
animation
file
via
if
present
this
will
override
the
system
boot
animation
system
media
bootanimation.zip
system
default
animation
usually
supplied
by
vendor
the
three
files
are
tried
in
order
and
if
none
of
them
can
be
found
defaults
to
alternating
between
two
images
android
logo
mask
shine
png
both
hidden
in
the
assets
images
folder
in
the
system
framework
framework
res.apk
you
can
easily
see
the
png
files
yourself
if
you
pull
the
framework
res.apk
to
your
host
and
unzip
the
file
what
makes
interesting
is
its
raw
i.e
non
framework
graphics
capability
since
it
is
one
of
the
first
services
to
load
the
frameworks
have
yet
to
initialize
leaving
to
fend
for
itself
using
low
level
opengl
and
skia
calls
these
result
in
direct
access
to
the
device's
frame
buffer
dev
graphics
fb0
which
is
why
is
iw
run
under
uid
graphics
the
owner
of
the
device
node
we
take
a
closer
look
at
the
low
level
graphics
calls
in
volume
ii
using
low
level
calls
and
direct
write
operations
to
the
framebuffer
also
enables
wr
override
even
when
it
is
active
as
you
can
verify
by
running
via
adb
shell
on
your
device
the
device
likely
has
it
by
default
wkrxjk
rx
fdq
dozd
v
xsordg
lw
iurp
wkh
hpxodwru
lpdjh
running
when
your
device
is
active
will
hide
your
display
behind
the
boot
animation
either
completely
in
portrait
mode
or
partially
in
landscape
mode
touch
screen
input
will
still
work
but
you'll
olnho
qrw
eh
deoh
wr
vhh
zkdw
rx
uh
grlqj
xqwlo
rx
hxit
by
using
most
device
vendors
will
provide
a
bootanimation.zip
with
their
logo
or
in
some
cases
the
carrier's
logo
likewise
cyanogen
and
other
android
mods
deploy
a
zip
of
their
own
such
zip
files
must
contain
a
desc.txt
and
an
assortment
of
images
which
will
cycle
through
the
first
frame
can
be
made
to
overlap
with
the
rom
bootup
image
if
any
ensuring
a
smooth
transition
into
the
animation
note
that
some
vendors
may
drop
the
default
binary
in
favor
of
their
own
animation
and
accompanying
sound
e.g
as
samsung
has
done
with
system
bin
samsungani
and
proprietary
qmg
files
alternatively
they
may
change
the
implementation
to
look
at
other
directories
e.g
htc
one
m8
looking
for
htc_bootup_one.zip
and
vendor_boot.zip
in
system
customize
resource
the
kindle's
fireos
is
somewhere
in
between
retaining
the
bootanimation
binary
but
modifying
it
to
display
the
kindle
fire
logo
rather
than
that
of
android
kdswhu
9
dhprqv
the
book's
website3
contains
miscellaneous
boot
animations
you
can
experiment
with
on
your
device
try
dropping
them
into
data
local
searched
before
system
media
and
see
how
easy
it
is
to
replace
the
boot
animation
make
sure
the
zip
file
is
readable
if
running
bootanimation
from
adb
as
user
shell
or
else
the
animation
will
default
to
the
a
n
d
r
o
i
d
console
text
experiment
determining
files
used
by
bootanimation
in
devices
like
the
nexus
5
boot
animation
is
in
system
media
bootanimation.zip
you
can
pull
it
to
a
host
using
and
inspect
its
contents
like
so
output
5
10
bootanimation.zip
example
the
first
line
of
the
desc.txt
specifies
in
order
the
width
height
and
frames
per
second
fps
of
the
boot
animation
note
this
is
consistent
with
the
dimensions
of
the
individual
png
files
on
other
devices
however
figuring
out
the
bootanimation
files
might
require
a
little
bit
of
reverse
engineering
on
your
part
fortunately
using
even
the
most
complicated
binaries
will
yield
their
secrets
for
example
consider
the
following
output
from
an
htc
one
m8
output
5
11
figuring
out
files
used
by
htc's
as
the
above
shows
the
htc
one's
animation
is
customized
per
carrier
in
this
example
a
verizon
phone
replacing
the
system
customize
resource
vzw_bootup.zip
or
adding
system
etc
customer
bootanimation.zip
searched
first
will
modify
the
boot
animation
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
morpheus
forge
adb
pull
system
media
bootanimation.zip
1275
kb
s
1068873
bytes
in
0.818s
morpheus
forge
unzip
t
bootanimation.zip
archive
bootanimation.zip
ok
testing
desc.txt
ok
testing
part0
ok
testing
part0
000
png
ok
testing
part0
001
png
testing
part1
059
png
ok
after
unzipping
morpheus
forge
cat
desc.txt
1080
230
24
p
1
0
part0
p
0
0
part1
morpheus
forge
file
part1
000
png
000
png
png
image
data
1080
x
230
8
bit
color
rgb
non
interlaced
using
strace
f
to
follow
forks
and
threads
since
binary
may
be
multi
threaded
o
to
save
output
to
a
local
file
shell
htc_m8wl
strace
f
o
data
local
tmp
out
system
bin
bootanimation
let
the
bootanimation
run
watch
logo
then
hit
ctrl
c
and
sift
through
output
shell
htc_m8wl
grep
open
data
local
tmp
out
grep
v
dev
grep
v
proc
grep
v
lib
21217
open
system
etc
customer
bootanimation.zip
o_rdonly
1
enoent
21217
writev
4
5
1
zipro
0
6
unable
to
open
system
etc
88
3
95
21217
open
data
data
com.htc.customizationsetup
files
boot_anim_mns
o_rdonly
1
enoent
21217
open
system
customize
cid
default.xml
o_rdonly
10
21217
open
system
customize
resource
vzw_bootup.zip
o_rdonly
10
http
newandroidbook.com
files
bootanimations
mediaserver
the
is
one
of
android's
most
important
components
it
serves
as
a
focal
point
for
multimedia
handling
controlling
both
playback
and
recording
it
is
defined
in
init.rc
as
follows
listing
5
19
mediaserver
definitions
in
init.rc
as
can
be
seen
from
the
group
membership
requires
permissions
for
audio
camera
network
services
and
the
drm
framework
described
next
the
however
is
really
just
a
container
for
the
actual
services
somewhat
like
the
concept
of
a
service
host
svchost.exe
in
windows
table
5
12
shows
the
services
hosted
table
5
12
the
services
service
published
name
provides
audioflinger
media.audio_flinger
audio
playback
the
service
gets
one
or
more
pcm
audio
streams
as
input
and
flings
them
into
a
merged
stream
audiopolicyservice
media.audio_policy
audio
policy
informs
of
the
volume
setting
and
target
audio
device
cameraservice
media.camera
camera
services
its
main
client
is
the
camera
app
whether
the
android
supplied
one
or
the
vendor's
mediaplayerservice
media.player
playing
audio
and
video
kitkat's
lays
the
groundwork
for
extensions
by
providing
a
function
though
at
present
no
extensions
are
defined
we
discuss
the
services
in
more
detail
in
volume
ii
experiment
debugging
through
the
service
a
useful
debugging
feature
in
is
that
upon
startup
it
checks
the
value
of
the
property
if
set
it
forks
the
instance
as
a
child
of
the
process
which
by
virtue
of
parenthood
collects
resource
usage
statistics
on
the
itself
this
can
be
shown
in
the
following
annotated
output
output
5
12
starting
the
service
using
you
can
then
view
the
lifecycle
and
resource
usage
using
and
call
kdswhu
9
dhprqv
make
sure
property
check
exists
in
the
binary
note
crude
may
yield
false
positive
root
htc_m8wl
grep
ro.test_harness
system
bin
mediaserver
binary
file
system
bin
mediaserver
matches
set
the
property
root
htc_m8wl
setprop
ro.test_harness
1
kill
the
media
server
root
htc_m8wl
kill
9
mediaserver_pid
et
voila
media.log
is
now
the
parent
of
mediaserver
root
htc_m8wl
ps
grep
media
media
19122
1
20548
6444
ffffffff
b6edaab0
s
media.log
media
19123
19122
59876
9520
ffffffff
b6edb26c
s
system
bin
mediaserver
root
htc_m8wl
service
list
grep
media.log
0
media.log
android.media.imedialogservice
drmserver
android
provides
a
digital
rights
management
drm
framework
for
copy
protected
content
and
the
is
the
component
responsible
for
being
the
focal
point
of
all
drm
requests
it
is
defined
in
init.rc
like
so
listing
5
20
drmserver
definitions
in
init.rc
in
truth
to
say
that
android
provides
a
framework
is
somewhat
of
a
misnomer
since
it
defines
just
the
apis
but
not
any
actual
content
verification
logic
the
actual
work
is
left
for
vendors
to
implement
by
a
plug
in
architecture
the
plug
ins
are
shared
object
files
loaded
by
enumerating
vendor
lib
drm
and
system
lib
drm
the
is
thus
quite
small
consisting
only
of
a
main
with
a
few
lines
which
register
a
with
the
servicemanager
and
call
on
its
internal
class
to
service
incoming
drm
calls
from
the
framework
by
finding
the
appropriate
plug
in
for
the
content
output
5
13
viewing
drm
plugins
on
a
galaxy
s3
to
be
considered
valid
and
called
by
the
drmmanager
a
plug
in
must
conform
to
the
interface
specification
defined
in
idrmengine.h
a
more
detailed
explanation
of
the
specification
including
an
examination
of
drm
message
flow
using
a
passthru
module
can
be
found
in
volume
ii
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
shell
android
ls
l
vendor
lib
drm
vendor
lib
drm
no
such
file
or
directory
no
vendor
specific
drm
modules
1
shell
android
ls
l
system
lib
drm
root
root
root
48336
2012
05
2
root
rw
r
r
root
root
117224
2012
05
21
root
root
root
root
root
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
rw
r
r
root
root
root
68944
2012
05
root
root
48604
2012
05
21
1
root
root
65312
2012
05
root
root
48212
2012
05
2
root
root
65012
2012
05
21
17
root
root
64836
2012
05
2
file
users
morpheus
documents
android
book
android_src_root
l
frameworks
av
drm
libdrmframework
plugins
common
include
idrmengine.h
other
services
the
remaining
services
in
the
main
class
are
somewhat
difficult
to
group
as
they
provide
different
facets
of
system
support
nonetheless
that
does
not
make
them
any
less
important
installd
the
daemon
is
responsible
for
package
installation
and
removal
whichever
way
a
package
is
installed
by
downloading
the
apk
directly
via
google
play
or
via
installd
gets
involved
in
the
process
the
daemon
itself
however
is
passive
listening
on
a
socket
set
up
by
init
over
which
commands
generated
by
the
android
framework
are
delivered
the
socket
is
defined
in
the
daemon's
init.rc
service
definition
listing
5
21
installd
definition
in
init.rc
startup
startup
of
proceeds
as
shown
in
figure
5
11
figure
5
11
startup
of
the
daemon
initialize_globals
read
environment
variables
and
deduce
directory
structure
from
them
initialize_directories
set
up
directory
structure
migrate
to
multi
user
drop_privileges
give
up
uid
gid
0
but
maintain
some
capabilities
android_get_control_socket
acquire
socket
from
init
listen
put
into
listening
mode
backlog
of
5
accept
block
until
a
client
requests
a
connection
readx
read
a
request
from
a
client
execute
fulfill
client's
bidding
no
questions
asked
upon
startup
the
is
charged
with
setting
up
and
maintaining
the
directory
structure
where
apps
are
to
be
installed
the
base
name
is
obtained
from
the
environment
variable
set
up
by
init
to
be
data
to
this
base
appends
app
app
private
app
lib
and
media
kdswhu
9
dhprqv
also
obtains
two
other
environment
variables
pointing
to
system
and
pointing
to
data
asec
once
it
has
deduced
its
directory
structure
it
proceeds
to
initialize
the
directories
making
sure
they
exist
as
data
initially
starts
up
empty
on
factory
default
as
of
jellybean
is
also
charged
with
migrating
the
directory
structure
to
allow
multi
user
the
steps
taken
are
as
follows
create
the
data
user
directory
with
ownership
and
mode
create
a
symbolic
link
from
data
user
0
to
data
data
upgrade
data
media
to
data
media
0
moving
any
preexisting
media
there
create
a
data
media
directory
for
any
other
existing
users
move
obbs
from
data
media
0
android
obb
to
data
media
obb
so
they
can
be
shared
amongst
users
and
reduce
overall
filesystem
usage
ensure
user
media
folders
data
media
exist
and
are
though
it
is
started
as
root
as
of
jellybean
the
employs
the
principle
of
least
privilege
one
of
the
first
calls
it
makes
is
to
which
sets
the
uid
gid
to
it
also
makes
use
of
linux
capabilities
q.v
chapter
8
to
maintain
and
dac
override
as
it
needs
them
to
deploy
and
remove
packages
owned
by
different
user
and
group
ids
finally
installd
acquires
the
control
socket
dev
socket
installd
and
enters
an
accept
loop
waiting
for
connections
from
client
once
a
client
forms
a
connection
an
inner
read
execute
loop
handles
this
connection
until
it
closes
meaning
that
can
only
handle
only
one
client
at
any
given
time
an
interesting
observation
is
the
doesn't
perform
any
verification
of
caller
id
on
the
socket
and
relies
on
the
socket
being
chmod
ed
to
because
only
one
client
can
be
served
at
a
time
there
is
the
implicit
assumption
that
it
is
held
by
the
note
also
that
performs
no
signature
verification
on
apks
assuming
that
its
caller
has
done
so
already
commands
the
framework
uses
the
via
the
undocumented
class
to
provide
a
dalvik
level
api
trusted
applications
can
use
in
order
to
install
or
remove
the
various
apps
the
api
methods
are
mapped
to
the
commands
sent
over
the
socket
as
strings
preceded
by
a
two
byte
binary
length
which
are
shown
in
table
5
13
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
security.html
capabilities
table
5
13
installd
commands
l
commands
in
green
command
arguments
use
ping
null
command
used
for
connectivity
install
pkgname
uid
gid
seinfo
install
package
specified
by
pkgname
under
uid
gid
with
selinux
context
specified
by
seinfo
dexopt
apk_path
uid
is_public
optimize
dex
file
of
apk
creating
an
odex
file
movedex
src
dst
rename
dex
file
specified
by
src
to
dst
rmdex
pkg
remove
dex
file
of
package
specified
by
pkg
remove
pkgname
userid
remove
package
specified
by
pkg
installed
under
uid
rename
oldname
newname
rename
package
from
oldname
to
newname
fixuid
pkgname
uid
gid
fix
package
pkgname
so
it
is
owned
by
uid:gid
freecache
free_size
free
cache
so
it
has
free_size
bytes
left
rmcodecache
pkgname
uid
remove
code
cache
of
package
pkgname
owned
by
uid
from
cache
rmcache
pkgname
uid
remove
package
pkgname
owned
by
uid
from
cache
getsize
pkgdir
uid
apkpath
return
the
size
of
the
directory
specified
by
apkpath
rmuserdata
pkgname
uid
remove
user
data
used
by
package
pkgname
owned
by
uid
movefiles
execute
scripts
in
system
etc
updatecmds
linklib
pkgname
aseclibdir
uid
link
native
library
to
its
real
location
mkuserdata
pkgname
uid
userid
creates
data
directory
for
package
owned
by
id
for
user
userid
and
installs
symlinks
mkuserconfig
uid
ensure
that
data
misc
user
uid
directory
exists
rmuser
uid
remove
user
uid
idmap
target
overlay
runs
system
bin
idmap
restorecondata
pkgname
seinfo
uid
restore
seinfo
on
pkgname
owned
by
uid
patchoat
apk_path
uid
is_public
pkgname
instruction_set
vm_safe_mode
should_relocate
patch
oat
file
to
relocate
it
in
memory
the
phases
of
package
installation
along
with
the
service
are
both
discussed
in
volume
ii
kdswhu
9
dhprqv
code
constant
1
state_
no_error
2
state_
locked
3
state_
uninitialized
4
system_error
5
protocol_error
code
constant
6
permission_denied
7
key_not_found
8
value_corrupted
10
13
wrong_password_
0123
14
signature_invalid
keystore
the
keystore
service
is
as
its
name
implies
provides
a
storage
service
for
keys
by
design
it
can
provide
storage
for
any
arbitrary
name
value
pairs
though
in
practice
it
is
only
used
for
key
storage
it
is
defined
in
init.rc
as
follows
listing
5
22
installd
definition
in
init.rc
the
argument
to
the
keystore
daemon
data
misc
keystore
is
the
directory
used
to
hold
the
various
keystore
files
as
of
jellybean
each
user
has
its
own
keystore
directory
with
the
primary
user
using
data
misc
keystore
0
the
keystore
password
of
the
user
is
stored
encrypted
with
a
derivative
of
the
lock
screen
authenticator
in
a
masterkey
file
and
per
app
keystores
are
in
files
following
the
aid_xxxxx
convention
unlike
other
daemons
and
as
of
4.4
keystore
no
longer
uses
a
socket
it
is
accessible
only
via
wherein
it
is
published
using
the
name
the
framework
client
of
the
service
is
the
class
this
is
a
developer
accessible
class
modeled
after
the
java
standard
and
is
reasonably
documented4
but
not
fully
so
there
are
quite
a
few
other
public
methods
available
which
the
android
documentation
chooses
to
omit
the
command
allows
partial
command
line
native
level
access
to
the
keystore
table
5
14
shows
the
commands
exposed
by
the
class
and
service
showing
the
commands
not
implemented
by
the
cli
as
grayed
response
codes
are
defined
in
system
security
keystore
include
keystore
keystore.h
and
mapped
to
error
strings
by
as
follows
table
5
14
keystore
error
codes
access
to
keys
is
governed
by
uid
hence
its
use
as
an
argument
so
each
application
effectively
has
its
own
private
store.in
addition
similar
to
the
acls
hard
coded
in
the
daemon
maintains
a
array
of
permissions
with
specific
exclusions
for
all
access
and
get
sign
and
verify
only
the
user
is
actually
the
most
restricted
with
get
being
the
only
operation
allowed
in
practice
though
it's
a
simple
matter
to
to
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
developer.android.com
reference
java
security
keystore.html
table
5
15
keystore
commands
exported
by
1
test
keystore
daemon
is
active
2
get
value
corresponding
to
name
3
insert
a
name
value
combination
into
keystore
belonging
to
uid
with
flags
4
delete
name
and
value
from
keystore
belonging
to
uid
5
check
if
name
exists
in
keystore
belonging
to
uid
6
list
all
keys
beginning
with
prefix
in
uid's
keystore
7
reset
wipe
keystore
8
change
keystore
password
to
password
9
lock
keystore
requiring
password
to
unlock
10
unlock
previously
locked
keystore
by
supplying
password
11
check
if
keystore
is
empty
12
generate
a
private
public
keypair
in
keystore
owned
by
uid
under
name
the
key
can
then
be
used
to
sign
and
verify
or
retrieve
the
public
key
but
the
private
key
will
remain
inaccessible
13
import
key
specified
in
data
blob
into
keystore
owned
by
uid
into
key
name
14
sign
data
with
key
corresponding
to
name
without
actually
retrieving
key
15
verify
signature
on
data
using
key
specified
by
name
16
get
a
public
key
associated
with
name
17
delete
key
identified
by
name
in
keystore
belonging
to
uid
18
grant
uid
access
to
key
name
19
revoke
access
to
key
name
to
uid
20
get
modification
time
of
name
21
copy
the
key
specified
by
srckey
in
keystore
belonging
to
srcuid
to
keystore
owned
by
destuid
under
name
destkey
22
return
integer
specifying
whether
or
not
keytype
is
backed
by
a
hardware
keystore
implementation
23
clear
keystore
for
user
uid
24
reset
keystore
for
uid
25
sync
keystore
for
uid
26
set
password
for
uid
kdswhu
9
dhprqv
experiment
interfacing
with
the
following
experiment
if
carried
out
incorrectly
can
potentially
lock
you
out
of
your
keystore
it's
therefore
recommended
to
try
it
on
an
emulator
image
rather
than
on
a
real
device
at
least
until
you
feel
confident
you
can
call
on
the
the
keystore
service
either
through
the
utility
or
directly
through
considering
not
all
of
its
commands
are
at
the
time
of
writing
implemented
it
can
make
more
sense
to
use
with
the
specific
numeric
codes
and
arguments
instead
output
5
14
demonstrates
this
in
a
split
screen
like
view
output
5
14
using
and
to
interact
with
the
keystore
service
as
table
5
16
shows
however
there
is
a
large
command
subset
you
cannot
call
through
you
can
the
grayed
commands
in
the
table
by
invoking
them
through
their
numeric
code
passing
arguments
using
the
utility's
and
specifiers
output
5
15
generating
a
key
directly
through
the
keystore
implementation
over
a
hardware
abstraction
module
and
or
possibly
a
hardware
component
is
discussed
in
volume
ii
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
note
root
is
not
allowed
access
to
the
keystore
keystore_cli
test
service
call
android.security.keystore
1
test
permission
denied
6
result
parcel
00000000
00000006
su
to
system
to
gain
full
control
su
system
keystore_cli
test
service
call
android.security.keystore
1
test
no
error
1
result
parcel
00000000
00000001
set
keystore
password
to
be
123
then
lock
keystore
keystore_cli
password
123
service
call
android.security.keystore
8
s16
123
password
no
error
1
result
parcel
00000000
00000001
keystore_cli
lock
service
call
android.security.keystore
9
lock
no
error
1
result
parcel
00000000
00000001
attempt
to
unlock
with
bad
password
system
will
count
down
attempts
errors
13,12,11,10
then
reset
return
uninitialized
followed
by
system_error
keystore_cli
unlock
bad
service
call
android.security.keystore
10
s16
bad
unlock
wrong
password
4
tries
left
13
result
parcel
00000000
0000000d
system
generic
service
call
android.security.keystore
12
s16
name1
name
i32
13
len
s16
hello
value
i32
1
i32
uid
1
caller
result
parcel
00000000
00000001
attempt
to
retrieve
value
from
keystore
system
generic
service
call
android.security.keystore
2
s16
name1
result
parcel
0x00000000
00000000
0000000d
00000005
00650068
h.e
0x00000010
006c006c
0000006f
l.l.o
debuggerd
64
try
as
hard
as
developers
will
their
applications
will
inevitably
face
bugs
which
will
result
in
crashes
in
order
to
fix
those
bugs
there
must
be
an
efficient
mechanism
to
collect
the
crash
data
on
a
desktop
system
the
crash
results
in
a
core
dump
but
that
is
simply
not
an
option
in
a
mobile
device
core
dumps
are
often
very
large
in
the
hundreds
of
mb
and
sometimes
more
and
space
is
limited
what
more
even
if
the
core
dump
were
saved
it's
not
a
trivial
matter
to
move
such
large
files
out
of
the
device
similar
to
ios's
crashreporter
android
introduces
this
small
daemon
is
normally
dormant
sleeping
on
its
socket
until
an
application
crashes
all
processes
on
android
wkdqnv
wr
wkh
qgurlg
olqnhu
automatically
install
a
signal
handler
for
the
lethal
signals
shown
in
table
5
16
table
5
16
signals
caught
by
debuggerd
signal
full
name
ample
illegal
instruction
illegal
machine
opcode
debugger
trap
breakpoint
voluntary
abort
assertion
failure
bus
error
mmu
fault
floating
point
exception
division
by
zero
segmentation
violation
null
pointer
dereference
broken
pipe
termination
of
process
on
read
end
of
pipe
all
signals
use
the
same
action
which
establishes
a
connection
to
over
its
socket
and
sends
it
a
message
the
message
wakes
up
the
daemon
and
causes
it
to
engrave
a
tombstone
a
tombstone
is
essentially
a
crash
report
which
generates
by
attaching
to
the
failing
process
using
linux's
apis
catching
its
signal
for
it
and
inspecting
its
memory
this
way
rather
than
a
full
core
dump
a
tombstone
can
hopefully
capture
the
essence
of
a
crash
and
perform
the
basic
crash
processing
tombstones
are
created
in
data
tombstones
if
the
property
is
set
to
the
uid
of
the
crashing
process
freezes
the
process
in
its
final
death
throes
and
waits
for
user
to
start
it
logs
a
message
which
can
be
easily
seen
in
listing
5
21
android
log
messages
emitted
by
pid
pid
the
uses
the
low
level
linux
apis
discussed
in
volume
ii
to
wait
until
the
user
presses
one
of
the
keys
and
lights
up
the
debug
red
led
on
the
device
to
draw
the
user's
attention
on
64
bit
systems
an
instance
of
is
also
spawned
in
order
to
handle
the
different
instruction
set
memory
layout
and
abi
we
discuss
debugging
in
general
and
tombstones
in
particular
in
volume
ii
kdswhu
9
dhprqv
file
users
morpheus
documents
android
book
2
do
file
users
morpheus
documents
android
book
2do
sdcard
not
all
android
devices
necessarily
support
sdcards
but
in
those
which
do
the
sdcard
daemon
provides
the
user
mode
support
including
the
enforcement
of
permissions
on
the
otherwise
permission
less
fat
filesystem
this
is
accomplished
by
using
a
mechanism
known
as
fuse
file
systems
in
user
mode
the
mechanism
registers
a
stub
filesystem
in
the
kernel
and
passes
all
of
its
calls
to
the
user
space
daemon
in
this
case
using
fuse
allows
for
much
more
flexibility
and
stability
than
implementing
a
filesystem
in
kernel
mode
the
complexity
involved
with
filesystem
code
coupled
with
the
untrustworthiness
of
possibly
potentially
maliciously
corrupted
structures
make
fuse
a
good
choice
for
relatively
infrequently
accessed
filesystems
there
is
a
significant
performance
impediment
involved
in
a
kernel
to
user
mode
and
back
to
kernel
mode
traversal
which
makes
fuse
somewhat
of
a
poor
performer
in
other
cases
figure
5
12
shows
the
flow
of
a
file
system
request
from
a
user
mode
client
to
the
kernel
its
redirection
via
fuse
to
the
sd
card
daemon
and
back
to
the
originating
client
figure
5
12
to
there
and
back
again
the
sdcard
daemon
and
its
operation
via
fuse
the
daemon
accepts
the
command
line
parameters
shown
in
the
following
table
switch
purpose
u
uid
specify
user
id
to
run
as
for
ownership
of
the
filesystem
usually
1023
g
gid
specify
jurxs
id
to
run
as
for
ownership
of
the
filesystem
usually
1023
l
path
specify
path
to
real
mountpoint
of
the
filesystem
t
specify
number
of
threads
default
is
2
l
specifies
mount
is
a
legacy
emulated
mount
d
derive
permissions
from
path
s
split
permissions
for
media
av
etc
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
after
processing
the
command
line
parameters
opens
the
dev
fuse
node
to
communicate
with
the
kernel
driver
and
then
calls
the
system
call
to
perform
a
fuse
mount
specifying
hard
coded
options
to
the
system
call
dev
fuse
fd
gid
once
privileges
are
dropped
to
the
specified
gids
the
daemon
calls
the
aptly
named
and
enters
a
message
loop
to
handle
incoming
requests
from
the
dev
fuse
fd
the
sd
card
filesystem
as
provided
by
the
daemon
was
discussed
in
chapter
2
the
following
experiment
further
exemplifies
the
flow
of
the
sd
card
filesystem
requests
via
fuse
experiment
observing
android
devices
use
the
daemon
whether
or
not
they
have
an
actual
sdcard
the
data
media
directory
is
mounted
via
an
daemon
instance
as
mnt
shell
emulated
if
the
device
also
has
a
physical
sdcard
its
filesystem
is
also
mounted
though
this
requires
an
additional
instance
of
the
daemon
as
shown
in
the
following
output
output
5
16
viewing
fuse
filesystems
mounted
with
observing
in
action
is
a
tad
trickier
however
the
method
demonstrated
time
and
again
in
this
chapter
the
all
powerful
can
be
used
in
this
case
as
well
but
tracing
the
main
thread
will
likely
show
nothing
any
one
of
s
threads
may
be
serving
the
fuse
requests
which
means
you'll
first
need
to
see
which
threads
were
created
via
proc
sdcard_pid
task
and
then
use
on
them
the
handy
won't
be
of
use
here
since
the
threads
were
created
prior
to
the
attachment
a
good
experiment
is
to
use
two
adb
sessions
one
to
trace
the
threads
in
and
another
to
try
operations
on
the
fuse
mount
e.g
doing
so
will
show
you
data
passing
to
and
from
the
file
descriptor
as
the
client's
requests
are
in
effect
proxied
by
the
daemon
which
translates
them
into
the
underlying
system
calls
for
example
in
the
following
output
demonstrating
the
trace
of
executing
output
5
17
tracing
through
kdswhu
9
dhprqv
use
mount
to
view
all
mounted
file
systems
but
isolate
only
fuse
ones
shell
htc_m8wl
mount
grep
fuse
dev
fuse
mnt
shell
emulated
fuse
rw
nosuid
nodev
relatime
user_id
1023
group_id
1023
dev
fuse
storage
ext_sd
fuse
rw
nosuid
nodev
relatime
user_id
1023
group_id
1023
busybox's
ps
applet
will
show
you
the
full
command
line
or
you
can
cat
tv
proc
cmdline
shell
htc_m8wl
busybox
ps
grep
sdcard
844
1023
0
02
system
bin
sdcard
u
1023
g
1023
l
data
media
mnt
shell
emulated
1599
1023
0
10
system
bin
sdcard
u
1023
g
1023
w
1023
d
mnt
media_rw
ext_sd
storage
ext_sd
get
stat
request
from
client
read
3
8
0
0
0
3
0
0
0
p
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
262224
56
perform
stat
on
underlying
file
system
lstat64
mnt
media_rw
ext_sd
st_mode
s_ifdir
0770
st_size
32768
0
relay
to
client
writev
3
x
0
0
0
0
0
0
0
p
1
0
0
0
0
0
16
120
get
getdents64
request
from
client
read
3
p
0
0
0
34
0
0
0
p
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
262224
80
perform
request
lseek
5
0
seek_set
0
getdents64
5
60
entries
4200
2216
relay
to
client
writev
3
0
0
0
0
0
0
0
0
p
1
0
0
0
0
0
16
0
0
0
0
n
0
0
0
0
0
0
0
7
0
0
0
4
0
0
0android
0
32
2
48
file
users
morpheus
documents
android
book
filesystems.html
sdcard
zygote
64
though
last
both
alphabetically
and
in
this
chapter
the
is
hardly
the
least
of
all
services
it
provides
the
core
support
for
all
of
the
android
framework
runtime
services
in
the
form
of
an
initialized
empty
dalvik
virtual
machine
stopped
just
shy
of
the
main
class
loading
the
init.rc
definition
is
as
follows
listing
5
22
zygote
definitions
in
init.rc
as
the
listing
shows
zygote's
true
name
is
the
name
zygote
however
is
far
more
apt
as
this
process
mimics
in
some
senses
its
namesake
just
like
the
biological
zygote
this
process
is
full
of
unlimited
potential
it
can
load
any
dalvik
class
specified
and
can
become
any
user
this
however
is
a
one
way
process
again
just
like
the
biological
parallel
the
rest
of
the
command
line
provides
the
arguments
all
of
which
but
the
double
dashed
get
passed
directly
to
the
dalvik
vm
the
last
two
arguments
get
processed
by
app_process
itself
and
result
in
the
vm
loading
the
class
and
ing
to
start
the
process
the
process
discussed
in
detail
in
next
chapter
goes
on
to
load
all
of
the
android
runtime
frameworks
whereas
the
binds
its
socket
dev
socket
zygote
to
listen
for
incoming
requests
when
such
requests
will
arrive
they
will
contain
a
class
name
to
load
and
zygote
will
similarly
and
load
the
classes
which
will
result
in
the
creation
of
a
new
app
a
new
life
will
be
born
but
all
these
apps
and
indeed
zygote
itself
are
from
the
linux
perspective
merely
instances
of
which
renames
itself
accordingly
and
you
can
verify
with
an
pid
because
can
specialize
into
potentially
any
process
it
must
leave
all
its
options
open
because
of
that
it
maintains
its
root
privileges
and
an
unlimited
set
of
capabilities
prior
to
forking
however
zygote
drops
all
privileges
and
then
calls
to
assume
the
aid
of
the
app
in
question
because
all
this
happens
prior
to
loading
any
app
code
both
vm
and
native
this
setup
is
considered
secure
it
has
however
suffered
in
the
past
from
vulnerabilities
e.g
froyo's
zysploit
due
to
not
checking
s
return
value
and
more
recently
2013
from
a
fork
bomb
denial
of
service
attack
further
it
follows
that
all
apps
must
be
spawns
of
zygote
the
only
exception
to
that
are
direct
invocations
of
from
the
command
line
for
example
by
the
upcall
scripts
mentioned
in
chapter
2
you
can
verify
that
for
yourself
by
looking
at
the
output
of
on
your
device
processes
will
either
be
offspring
of
pid
1
as
holds
for
all
the
daemons
discussed
in
this
chapter
or
zygote
spawn
in
which
case
some
other
pid
will
be
the
ppid
and
you
can
bet
the
pid
is
that
of
zygote
the
rationale
behind
zygote
at
this
point
you
might
be
asking
yourself
why
go
to
all
this
trouble
just
in
order
to
load
a
new
app
but
it
turns
out
that
the
effort
invested
yields
plentiful
dividends
in
not
one
but
two
ways
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services
ii.html
system_server
file
users
morpheus
documents
android
book
filesystems.html
application
startup
time
is
greatly
decreased
regardless
of
actual
app
all
virtual
machines
need
to
be
initialized
in
the
same
deterministic
way
the
class
loading
of
the
app
is
the
final
stage
of
this
process
but
the
real
overhead
is
in
the
loading
of
the
multitude
of
runtime
classes
which
make
up
android's
rich
frameworks
if
you
imagine
the
app
loading
to
be
a
race
of
sorts
using
zygote
enables
android
to
camp
by
the
finish
line
and
run
the
last
leg
of
the
race
which
is
relatively
short
reducing
load
time
by
orders
of
magnitude
memory
sharing
is
optimized
because
all
virtual
machines
fork
from
zygote
they
can
take
advantage
of
implicit
memory
sharing
performed
by
the
kernel
specifically
though
each
instance
of
has
its
own
virtual
memory
the
majority
of
that
memory
being
read
only
class
code
can
be
backed
by
only
one
physical
copy
in
ram
the
rest
of
the
memory
class
data
read
write
can
be
backed
by
additional
pages
only
when
absolutely
necessary
a
technique
known
as
copy
on
write
thus
most
of
android's
apps
implicitly
share
80
90
of
their
memory
with
other
apps
and
with
which
is
the
first
real
instance
of
a
full
vm
this
maximizes
memory
usage
and
allows
quite
a
few
apps
to
fit
in
ram
even
on
relatively
low
memory
devices
you
can
see
an
example
of
this
if
you
skip
ahead
to
output
7
14
in
a
hands
on
experiment
showing
the
use
of
the
and
utilities
which
provide
memory
usage
diagnostics
it
is
zygote's
unique
design
which
has
enabled
it
to
triumph
where
java
has
failed
there
are
additional
optimizations
in
the
virtual
machine
architecture
itself
for
example
keeping
reference
counts
separate
from
objects
but
those
merit
a
deeper
discussion
from
the
programmatic
perspective
which
is
left
for
volume
ii
likewise
the
step
by
step
walk
through
of
application
startup
can
be
found
there
the
approach
is
not
without
some
drawbacks
as
we
discuss
in
chapter
8
forking
all
the
applications
from
the
same
binary
effectively
undermines
address
space
layout
randomization
aslr
which
is
an
important
layer
of
security
against
code
injection
attacks
that
said
the
needs
of
the
many
outweigh
those
of
the
few
and
so
performance
trumps
security
recent
academic
research
has
proposed
morula5
another
biological
term
resulting
from
zygote
division
as
an
alternative
architecture
which
may
address
aslr
shortcomings
but
that
has
yet
to
make
its
way
to
android
with
the
move
to
the
android
runtime
art
zygote's
architecture
becomes
even
more
efficient
as
all
of
the
preloaded
classes
are
also
precompiled
that
however
complicates
matters
somewhat
because
32
and
64
bit
layouts
are
not
compatible
zygote
32
and
zygote
64
with
the
move
to
64
bit
computing
on
the
one
hand
and
the
need
to
retain
32
bit
compatibility
on
the
other
android
now
has
to
maintain
not
one
but
two
versions
of
zygote
in
a
64
bit
architecture
the
secondary
zygote
is
a
32
bit
process
which
is
started
by
an
instance
of
because
the
primary
i.e
64
bit
zygote
instance
holds
the
zygote
socket
the
secondary
zygote
requires
an
additional
socket
this
is
shown
in
listing
5
23
listing
5
23
zygote32
definitions
in
init.zygote64_32
rc
user
applications
are
entirely
oblivious
to
which
instance
of
zygote
they
are
using
though
this
makes
a
difference
in
terms
of
which
libraries
are
loaded
and
therefore
jni
32
bit
zygote
instances
use
system
lib
whereas
64
bit
ones
uses
system
lib64
inspecting
the
process
address
space
maps
by
using
pid
will
reveal
the
different
mappings
as
further
discussed
in
chapter
7
kdswhu
9
dhprqv
https
taesoo.gtisc.gatech.edu
pubs
2014
morula
morula.pdf
file
users
morpheus
documents
android
book
linuxlens.html
maps
summary
this
chapter
covered
the
native
services
of
android
which
are
the
daemon
processes
spawned
by
init
through
the
various
entries
in
the
init.rc
files
the
native
processes
are
responsible
for
various
housekeeping
operations
as
well
as
providing
the
basic
level
of
support
for
the
system
frameworks
the
framework
services
however
are
another
matter
in
entirety
due
to
the
large
number
of
services
and
the
detail
required
we
leave
that
discussion
for
volume
ii
nonetheless
the
next
chapter
provides
the
preliminaries
by
providing
an
overview
of
the
service
architecture
through
an
elaboration
on
and
it
is
the
latter
process
which
serves
as
the
container
for
all
services
and
the
one
which
takes
over
the
ui
from
the
files
discussed
in
this
chapter
section
file
directory
contains
adb
system
core
adb
implementation
of
adb
both
client
and
server
f
b
s
ja
com
and
ser
usb
usbdebuggingmanager.java
usb
debugging
manager
server
used
by
vold
f
b
s
ja
com
and
ser
mountservice.java
the
mount
service
manager
used
by
debuggerd
system
core
debuggerd
source
of
debuggerd
installd
f
native
cmds
installd
source
of
installd
bootanimation
f
base
cmds
bootanimation
bootanimation.cpp
bootanimation
source
sdcard
sys
core
sdcard
sdcard.c
source
of
sdcard
references
1
android
full
disk
encryption
http
source.android.com
devices
tech
encryption
android_crypto_implementation.html
2
android
explorations
http
nelenkov.blogspot.com
2012
08
changing
androids
disk
encryption.html
3
bootanimation
collection
http
www.newandroidbook.com
bootanimations
4
android
developer
keystore
documentation
http
developer.android.com
reference
java
security
keystore.html
5
georgia
tech
from
zygote
to
morula
https
taesoo.gtisc.gatech.edu
pubs
2014
morula
morula.pdf
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
source.android.com
devices
tech
encryption
android_crypto_implementation.html
http
nelenkov.blogspot.com
2012
08
changing
androids
disk
encryption.html
http
www.newandroidbook.com
bootanimations
http
developer.android.com
reference
java
security
keystore.html
https
taesoo.gtisc.gatech.edu
pubs
2014
morula
morula.pdf
vi
the
framework
service
architecture
the
previous
chapter
painted
only
a
partial
picture
of
the
runtime
services
in
android
the
services
detailed
therein
were
all
native
level
processes
implemented
in
c
c
and
with
no
direct
programmatic
interface
from
the
java
layer
as
such
they
can
be
classified
as
services
which
support
the
operating
system
itself
applications
however
make
use
of
an
entirely
different
set
of
services
provided
by
the
dalvik
level
frameworks
with
special
interfaces
these
services
have
a
java
language
interface
and
most
of
which
run
in
the
context
of
one
process
system_server
and
are
reachable
with
the
help
of
both
and
were
introduced
throughout
the
previous
chapter
in
the
section
dealing
with
core
services
and
as
a
subset
of
zygote
i.e
started
by
zygote
when
the
argument
is
provided
both
however
deserve
a
much
more
in
depth
investigation
as
together
they
provide
the
support
and
the
context
of
the
entire
android
framework
service
architecture
which
is
what
this
chapter
discusses
we
begin
by
revisiting
the
service
manager
which
provides
the
role
of
an
endpoint
mapper
that
is
allows
service
location
and
invocation
the
services
make
themselves
visible
to
clients
by
registering
with
and
from
that
point
on
clients
may
approach
the
and
request
a
connection
or
a
handle
to
the
service
all
framework
services
are
invoked
in
the
same
way
and
this
service
calling
pattern
is
discussed
next
in
particular
two
key
components
are
introduced
the
android
interface
definition
language
or
aidl
providing
the
interface
or
set
of
apis
exported
by
the
services
and
the
utility
which
allows
the
testing
and
debugging
of
those
interfaces
from
the
command
line
the
underlying
transport
for
service
and
indeed
all
inter
app
communication
is
android
is
the
binder
mechanism
which
is
accessible
to
applications
via
dev
binder
what
looks
like
a
simple
device
node
is
in
fact
an
elaborately
designed
ipc
framework
which
is
charged
with
not
only
dispatching
messages
but
also
with
passing
around
objects
descriptors
and
more
as
well
as
providing
reliability
and
security
this
is
discussed
as
we
take
a
a
closer
look
at
service
internals
lastly
we
take
a
look
at
system_server
itself
which
functions
as
the
service
host
process
wherein
most
services
are
implemented
as
threads
we
detail
the
startup
operation
and
internals
of
this
important
process
as
for
the
services
themselves
they're
detailed
in
the
next
volume
of
this
work
a
few
notable
exceptions
are
surfaceflinger
and
the
media
services
note
that
application
3rd
party
services
run
in
their
own
process
file
users
morpheus
documents
android
book
services.html
file
users
morpheus
documents
android
book
services.html
servicemanager
file
users
morpheus
documents
android
book
services.html
zygote
file
users
morpheus
documents
android
book
systemserver.html
servicepattern
file
users
morpheus
documents
android
book
systemserver.html
aidl
file
users
morpheus
documents
android
book
systemserver.html
binder
file
users
morpheus
documents
android
book
systemserver.html
system_server
revisiting
servicemanager
if
you
recall
from
the
previous
chapter
one
of
the
services
classified
by
init
in
the
core
class
is
the
the
other
key
services
are
dependent
on
it
and
must
be
restarted
with
it
if
it
crashes
further
is
designated
as
critical
which
means
that
init
will
agressively
attempt
to
restart
it
or
boot
to
recovery
if
it
fails
to
do
so
the
reason
behind
the
utmost
importanfh
of
the
is
its
function
it
serves
as
the
locator
or
directory
for
all
other
operating
system
services
if
any
application
or
system
component
needs
to
use
another
service
be
it
what
may
it
must
first
consult
the
to
obtain
a
handle
similarly
services
cannot
expect
clients
until
they
register
their
presence
with
it
it
is
for
this
reason
that
if
the
manager
is
restarted
so
must
all
of
its
dependents
after
all
restarting
implies
the
service
directory
must
be
rebuilt
from
scratch
and
services
thus
need
to
register
it
likewise
follows
that
if
cannot
operate
inter
process
communication
ipc
cannot
subsist
the
ipc
model
of
android
is
discussed
later
in
this
chapter
for
the
moment
however
suffice
it
to
say
that
it
is
provided
by
a
dedicated
kernel
component
the
binder
user
mode
services
access
the
binder
for
ipc
via
a
character
device
node
dev
binder
which
is
readily
accessible
readable
writable
to
all
processes
only
one
user
mode
process
at
a
time
however
can
request
to
register
as
a
context
manager
with
the
binder
however
and
from
that
point
on
it
becomes
the
focal
point
for
all
other
processes
both
clients
and
servers
the
servers
must
register
their
service
name
and
interface
with
the
context
manager
and
the
clients
must
consult
the
context
manager
in
order
to
lookup
and
find
the
service
the
is
therefore
a
pretty
small
binary
with
a
simple
operation
a
call
to
binder_open
obtains
the
dev
binder
descriptor
and
a
call
to
establishes
its
position
thereafter
the
enters
an
endless
which
blocks
on
the
descriptor
until
a
transaction
i.e
request
from
a
client
occurs
this
wakes
process
and
calls
its
callback
which
processes
the
transaction
the
service
lookup
must
somehow
be
bootstrapped
in
other
words
the
should
be
globally
accessible
so
that
services
can
register
with
it
and
clients
can
look
them
up
at
the
native
level
services
and
clients
alike
can
call
on
to
get
a
handle
to
the
service
manager
technically
to
its
interface
as
a
the
interface
defined
in
iservicemanager.h
exposes
a
simple
set
of
transaction
request
codes
table
6
1
shows
the
requests
as
well
as
the
native
level
calls
which
implement
them
note
that
there
is
no
api
to
remove
the
service
services
are
automatically
removed
when
their
proceeses
die
because
binder
can
detect
that
and
send
a
death
notification
table
6
1
requests
and
the
programmatic
methods
to
invoke
them
request
code
api
notes
used
by
servers
to
register
themselves
with
the
service
manager
servers
can
decide
whether
or
not
they
want
to
allow
isolated
sandboxed
processes
to
connect
name
get
a
handle
to
the
service
specified
by
name
return
a
vector
list
of
all
services
not
used
by
the
framework
but
used
by
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
servicemanager
the
functionality
is
considered
sensitive
uid
0
or
000
aid_system
can
freely
register
services
but
other
system
services
are
restricted
up
to
and
including
kitkat
this
is
done
by
a
hard
coded
list
restricting
registration
as
shown
in
table
6
2
table
6
2
hardcoded
service
registration
restrictions
aid_media
media.audio_flinger
media.log
media.player
media.camera
media_audio_policy
aid_drm
drm.drmmanager
aid_nfc
nfc
aid_bluetooth
bluetooth
aid_radio
radio.phone
radio.sms
radio.phonesubinfo
radio.simphonebook
aid_radio
phone
sms
iphonesubinfo
simphonebook
aid_media
common_time.clock
common_time.config
aid_keystore
android.security.keystore
these
are
legacy
service
names
deprecated
by
their
radio
counterparts
in
lollipop
the
hard
coded
list
is
moved
into
the
service_contexts
file
of
selinux
which
provides
a
far
more
scalable
way
to
control
services
system_server.c
code
is
simplified
by
a
call
to
which
then
calls
on
in
this
manner
service
registration
and
lookup
can
be
enforced
for
all
services
further
allowing
the
device
vendor
to
add
their
own
services
without
the
need
to
recompile
any
code
listing
6
1
the
vhuylfhbfontexts
selinux
policy
file
the
programmatic
apis
are
wrapped
by
the
framework
class
which
is
further
encapsulated
in
apps
aren't
expected
to
use
this
directly
and
instead
call
on
in
order
to
look
up
system
services
and
use
intents
for
third
party
services
either
way
communication
with
services
both
system
and
third
party
is
performed
over
binder
messages
with
the
serving
as
the
service
directory
as
shown
in
figure
6
1
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
figure
6
1
registering
and
accessing
android
framework
services
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
using
the
command
to
interface
with
service
manager
android
provides
the
command
line
utility
as
a
simple
interface
for
the
service
manager
this
simple
utility
also
demonstrates
how
to
use
the
programmatic
apis
to
query
services
using
you
can
display
all
registered
services
as
well
as
their
published
interfaces
discussed
later
in
this
chapter
and
using
see
if
a
given
service
can
be
contacted
output
6
1
shows
an
output
of
on
a
nexus
5
android
l
because
you
can
easily
run
this
command
on
any
device
the
output
is
partial
highlighting
only
those
services
which
are
new
in
l
or
are
not
present
in
the
emulator
output
6
1
using
on
an
android
l
nexus
5
the
output
from
the
command
may
vary
considerably
between
devices
some
differences
are
obvious
for
example
the
phone
service
will
not
be
found
on
tablets
while
others
may
be
less
so
vendor
specific
services
or
android
version
specific
the
interface
defines
a
method
which
is
used
by
the
command
to
provide
diagnostics
on
services
when
invoked
without
arguments
iterates
over
all
services
in
the
same
manner
as
and
dumps
each
in
turn
in
some
cases
additional
arguments
may
be
supplied
which
vary
with
each
service
some
services
also
expose
a
checkin
method
which
can
be
used
by
or
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
root
generic
service
list
found
93
services
emulator
shows
only
87
services
75
in
kk
11
not
in
emulato
sip
android.net.sip.isipservice
22
33
44
55
66
77
88
99
1010
1111
1212
1313
1414
1515
1616
phone
com.android.internal.telephony.itelephony
iphonesubinfo
com.android.internal.telephony.iphonesubinfo
simphonebook
com.android.internal.telephony.iiccphonebook
isms
com.android.internal.telephony.isms
nfc
android.nfc.infcadapter
not
in
emulato
telecomm
com.android.internal.telecomm.itelecommservice
l
launcherapps
android.content.pm.ilauncherapps
trust
android.app.trust.itrustmanager
media_router
android.media.imediarouterservic
tv_input
android.media.tv.itvinputmanager
hdmi_control
android.hardware.hdmi.ihdmicontrolservice
media_session
android.media.session.isessionmanager
print
android.print.iprintmanage
assetatlas
android.view.iassetatla
dreams
android.service.dreams.idreammanage
2020
0
21
22
voiceinteraction
com.android.internal.app.ivoiceinteractionmanagerservice
2
appwidget
com.android.internal.appwidget.iappwidgetservice
backup
android.app.backup.ibackupmanager
jobscheduler
android.app.job.ijobscheduler
l23
3838
39
40
41
42
43
44
45
ethernet
android.net.iethernetmanager
not
in
emulat
wifiscanner
android.net.wifi.iwifiscanner
l
wifipasspoint
android.net.wifi.passpoint.iwifipasspointmanager
l
wifi
android.net.wifi.iwifimanager
wifip2p
android.net.wifi.p2p.iwifip2pmanager
netpolicy
android.net.inetworkpolicymanager
netstats
android.net.inetworkstatsservice
network_score
android.net.inetworkscoreservice
l
bluetooth_manager
android.bluetooth.ibluetoothmanager
not
in
emulator55
display.qservice
android.display.iqservice
owned
by
sf
not
in
emulator87
use
service
check
with
one
of
above
names
to
see
if
service
is
alive
root
generic
service
check
media.camera
service
media.camera
found
file
users
morpheus
documents
android
book
systemserver.html
callsvcs
the
service
calling
pattern
android's
framework
services
are
implemented
in
threads
applications
thus
need
to
rely
on
inter
process
communication
ipc
in
order
to
invoke
them
this
is
where
the
binder
android's
properietary
ipc
mechanism
comes
into
play
applications
need
to
call
on
the
binder
in
their
own
process
to
obtain
an
endpoint
descriptor
which
is
then
connected
to
the
remote
service
methods
can
then
be
invoked
through
ipc
messages
through
a
pattern
known
as
remote
procedure
call
rpc
ipc
rpc
the
terms
ipc
and
rpc
are
often
used
interchageably
though
not
often
correctly
because
both
terms
are
fundamental
in
the
context
of
android
services
it's
worth
clarifying
the
difference
inter
process
communication
ipc
is
a
blanket
term
for
all
forms
of
communication
between
processes
these
include
various
forms
of
message
passing
but
also
shared
resources
most
notably
shared
memory
along
with
synchronization
objects
mutexes
and
the
like
meant
to
ensure
safety
in
concurrent
access
to
shared
resources
i.e
prevent
data
corruption
which
occurs
when
two
writers
attempt
to
modify
the
same
data
item
or
race
conditions
between
readers
and
writers
remote
procedure
call
rpc
is
a
specific
term
for
a
method
of
ipc
which
hides
the
actual
communication
inside
procedure
method
calls
the
client
calls
a
local
method
which
in
turn
is
responsible
for
transparently
handling
the
ipc
with
the
remote
server
which
may
at
times
be
on
a
different
machine
the
method
serializes
its
arguments
into
a
message
which
is
then
transported
to
the
server's
method
where
the
arguments
are
deserialized
acted
upon
and
the
same
occurs
in
reverse
for
passing
the
return
values
of
the
method
if
any
thus
any
rpc
mechanism
is
also
an
ipc
mechanism
the
former
being
a
special
case
of
the
latter
but
not
vice
versa
android's
service
calling
pattern
implements
rpc
as
we
discuss
and
detail
in
this
section
table
6
3
compares
the
rpc
mechanisms
used
in
contemporary
oses
6
3
comparison
of
rpc
mechanisms
in
common
operating
systems
os
mechanism
scope
directory
preprocessor
transport
un
x
sunrpc
local
remote
portmapper
rpcgen
udp
tcp
os
x
ios
mach
local
remote
launchd
mach_init
mig
mach
messages
android
binder
local
servicemanager
aidl
dev
binder
as
shown
in
the
table
all
rpc
mechanisms
have
common
denominators
specifically
scope
denoting
whether
the
rpcs
are
used
in
between
hosts
remote
or
only
on
the
local
host
directory
the
server
providing
the
lookup
functionality
for
locating
services
preprocessor
the
tool
used
to
generate
the
serialization
and
deserialization
code
for
messages
transport
the
medium
for
message
passing
we
revisit
rpc
and
discuss
it
in
far
more
detail
when
dealing
with
binder
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
android
developers
remain
blissfully
oblivious
to
the
underlying
implementation
of
service
invocation
instead
as
most
android
developers
are
familiar
with
they
are
required
to
call
on
the
method
of
the
object
which
accepts
the
name
of
an
android
system
service
and
returns
an
opaque
object
the
object
returned
can
then
be
type
cast
into
the
specific
service
object
and
the
service
methods
can
be
invoked
through
it
figure
6
2
shows
the
general
pattern
followed
by
most
service
method
calls
the
figure
is
somewhat
simplified
for
example
the
system
service
handles
are
cached
but
still
presents
the
flow
services
are
registered
a
priori
by
the
server
process
commonly
or
a
3rd
party
process
through
a
call
to
recall
this
class
provides
a
java
interface
to
the
service
manager
figure
6
2
android
system
service
call
pattern
advantages
and
disadvantages
the
system
service
architecture
of
android
follows
a
generic
local
client
server
pattern
common
to
other
oses
such
as
ios
though
ios
has
no
binder
it
uses
its
own
implementation
of
a
message
passing
architecture
called
mach
messages
the
role
of
i.e
the
endpoint
matter
is
assumed
by
s
process
which
among
other
things
also
handles
the
traditional
pid
1
roles
that
android's
init
does
a
disadvantage
which
quickly
stands
out
in
this
architecture
is
the
overhead
of
ipc
particularly
the
need
to
serialize
and
deserialize
messages
as
well
as
the
context
switch
required
when
alternating
between
the
processes
this
disadvantage
does
have
a
noticeable
performance
impact
android's
binder
is
by
design
limited
to
a
local
scope
it's
a
fairly
simple
hack
to
set
up
a
local
proxy
process
to
further
serialize
and
deserialize
requests
over
a
tcp
or
udp
socket
thus
extending
binder's
scope
a
highly
useful
capability
for
a
remote
access
tool
rat
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
given
such
a
considerable
disadvantage
it
must
be
offset
by
advantages
greater
or
equal
in
magnitude
and
indeed
it
is
aside
from
the
cleaner
design
and
separation
of
privileges
which
follows
a
client
server
architecture
gains
security
as
a
corollary
the
client
process
which
is
by
definition
an
untrusted
user
app
is
entirely
devoid
of
any
permissions
and
therefore
relies
entirely
on
service
calls
to
perform
any
operations
at
the
native
level
this
means
that
an
app
can
be
run
sandboxed
without
any
access
to
devices
and
datastores
if
any
indeed
this
is
the
case
in
ios
wherein
apps
are
jailed
though
android
relies
for
most
processes
on
filesystem
permissions
to
deny
access
the
server
processes
are
trusted
and
expected
to
perform
all
security
checks
ensuring
the
client
has
the
necessary
permissions
before
agreeing
to
serve
the
request
once
again
the
two
arch
rivals
are
similar
here
with
ios
relying
on
entitlements
embedded
in
the
binary's
code
signature
and
android
on
the
application's
manifest
file
in
both
cases
the
permissions
are
declared
outside
of
the
application's
runtime
scope
i.e
they
can
be
verified
when
installed
or
in
ios's
case
when
apple
vets
the
app
but
cannot
be
modified
by
the
app
specifically
ios's
entitlements
are
stored
in
kernel
space
as
part
of
the
cached
code
signature
blob
whereas
android's
permissions
are
maintained
by
the
serialization
and
the
android
interface
definition
language
aidl
in
design
pattern
parlance
the
object
obtained
from
serves
as
a
proxy
internally
it
holds
a
reference
to
the
actual
service
which
it
obtains
over
a
binder
call
the
methods
exported
by
the
object
are
for
the
most
part
merely
stubs
which
take
their
arguments
and
serialize
them
into
a
binder
message
referred
to
as
a
the
methods
and
objects
serializable
in
this
way
are
specified
using
aidl
aidl
isn't
really
a
language
per
se
it's
essentially
a
derivative
of
java
which
is
understood
by
the
sdk
utility
which
is
invoked
in
the
build
process
when
aidl
files
are
encountered
the
automatically
generates
the
java
source
code
required
to
serialize
any
parameters
into
a
binder
message
and
extract
the
return
value
from
it
the
code
is
boilerplate
i.e
it
can
be
automatically
generated
from
the
definition
files
and
is
guaranteed
to
compile
cleanly
a
sample
aidl
file
is
shown
in
listing
6
2
listing
6
2
a
sample
aidl
file
as
you
can
see
an
aidl
is
somewhat
similar
to
a
header
file
in
that
it
defines
methods
and
possibly
objects
but
not
their
implementation
as
we
explore
the
individual
framework
services
later
in
the
book
you'll
be
able
to
see
many
more
examples
of
actual
aidls
from
the
aosp
the
tool
does
a
marvelous
job
of
hiding
the
implementation
details
of
android's
ipc
from
the
developers
so
great
a
job
in
fact
that
most
developers
remain
blissfully
ignorant
of
the
role
of
binder
or
its
very
existence
this
work
however
recognizes
the
role
of
binder
providing
an
introduction
to
it
later
in
this
chapter
and
discussing
internals
in
volume
ii
power
users
can
remain
equally
oblivious
to
binder
especially
with
a
powerful
tool
like
the
utility
which
enables
the
invocation
of
android
service
methods
right
from
the
command
line
this
is
shown
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
using
the
command
to
call
services
a
previous
experiment
demonstrated
the
basic
usage
of
the
command
line
utility
as
a
method
of
interfacing
with
the
process
the
true
power
of
however
lies
in
its
ability
to
call
the
services
themselves
calling
a
service
is
a
simple
enough
matter
using
and
specifying
the
service
name
and
method
number
internally
methods
are
assigned
numbers
in
order
of
their
appearance
in
the
service's
aidl
file
depending
on
the
method
optional
arguments
may
be
supplied
the
utility
supports
two
types
of
arguments
which
are
integer
values
and
which
are
used
for
unicode
strings
in
practice
however
integers
can
be
used
for
any
32
bit
value
e.g
and
strings
being
unicode
can
be
used
to
serialize
any
object
any
service
retrieved
by
output
6
1
with
an
interface
specified
in
brackets
can
be
called
on
in
this
manner
each
interface
has
a
corresponding
aidl
file
in
the
aosp
wherein
its
methods
and
their
arguments
are
clearly
defined
once
you
have
the
definitions
you
can
invoke
any
method
of
your
choice
by
figuring
out
its
call
number
and
passing
the
appropriate
arguments
a
few
of
the
interesting
ones
are
shown
in
table
6
4
table
6
4
commands
service
call
interface
method
action
phone
2
s16
foo
s16
555
1234
call
string
callingpackage
string
number
place
a
call
to
the
specified
number
statusbar
1
expandnotificationspanel
brings
up
notifications
statusbar
9
expandsettingspanel
brings
up
settings
statusbar
2
collapsepanels
hides
all
panels
dream
1
dream
screensaver
if
configured
power
10
4.4.1
power
11
4.4.2
isscreenon
returns
0
if
screen
is
off
else
1
the
low
level
call
numbers
assigned
to
methods
can
change
between
android
versions
even
within
the
same
api
version
for
example
and
within
kitkat
it's
rare
but
could
happen
beware
in
general
it's
a
bad
idea
to
rely
on
hard
coded
numbers
if
creating
a
tool
or
app
to
use
these
private
apis
compile
them
alongside
the
updated
aidl
files
invoking
calls
in
this
way
will
return
a
result
in
a
parcel
the
binder
term
for
a
message
each
parcel
contains
at
a
minimum
a
32
bit
return
value
0x00000000
indicating
success
otherwise
some
error
value
commonly
or
if
a
call
number
is
outside
the
defined
range
depending
on
the
aidl
definition
what
follows
is
either
an
integer
value
i32
or
a
length
specification
followed
by
an
opaque
object
usually
but
not
necessarily
a
string
because
like
binder
has
no
idea
of
what
the
opqaue
object
is
it
will
display
the
result
in
a
manner
not
unlike
the
command
with
a
hex
dump
of
the
message
contents
alongside
an
ascii
dump
of
it
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
experiment
using
the
command
to
call
services
cont
only
services
with
a
published
interface
specified
in
brackets
can
be
invoked
note
not
all
services
will
blindly
lend
themselves
to
this
type
of
invocation
depending
on
the
security
policy
which
is
implemented
differently
by
individual
services
your
service
call
request
may
be
denied
if
that
is
the
case
the
output
of
will
contain
a
unicode
error
message
like
so
output
6
2
error
messages
returned
from
once
you
get
past
permissions
however
for
example
by
running
as
root
the
possibilities
of
using
in
this
manner
are
nearly
endless
spanning
all
the
features
and
capabilities
of
the
android
frameworks
as
we
cover
the
framework
services
in
this
work
one
by
one
we'll
be
showing
their
respective
aidl
definitions
and
number
the
calls
accordingly
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
attempt
to
call
cancelmissedcallsnotification
which
requires
modify_phone_state
you
can
get
past
this
as
well
as
most
other
permission
checks
by
running
as
root
shell
htc_m8wl
service
call
phone
13
result
parcel
0x00000000
ffffffff
00000050
0065004e
00740069
p
n.e.i.t
0x00000010
00650068
00200072
00730075
00720065
h.e.r
u.s.e.r
0x00000020
00320020
00300030
00200030
006f006e
2.0.0.0
n.o
0x00000030
00200072
00750063
00720072
006e0065
r
c.u.r.r.e.n
0x00000040
00200074
00720070
0063006f
00730065
t
p.r.o.c.e.s
0x00000050
00200073
00610068
00200073
006e0061
s
h.a.s
a.n
0x00000060
00720064
0069006f
002e0064
00650070
d.r.o.i.d
p.e
0x00000070
006d0072
00730069
00690073
006e006f
r.m.i.s.s.i.o.n
0x00000080
004d002e
0044004f
00460049
005f0059
m.o.d.i.f.y
0x00000090
00480050
004e004f
005f0045
00540053
p.h.o.n.e
s.t
0x000000a0
00540041
002e0045
00000000
a.t.e
0x00
the
binder
the
discussion
so
far
has
mentioned
the
binder
several
times
but
kept
it
a
very
high
level
overview
indeed
at
a
high
level
suffice
it
to
consider
the
binder
as
a
special
type
of
a
file
descriptor
which
through
a
dedicated
kernel
driver
is
connected
to
the
service
this
is
also
how
linux
sees
it
when
the
process
is
viewed
through
the
proc
pid
fd
directory
virtually
every
process
in
the
system
with
the
exception
of
a
few
native
processes
opens
a
handle
to
dev
binder
much
of
binder's
inner
workings
however
are
shrouded
in
darkness
probably
because
for
most
developers
ignorance
is
bliss
for
those
who
want
to
know
the
details
there
is
after
all
always
the
source
for
the
scope
of
this
work
however
it's
benhilcial
to
elucidate
some
of
these
dark
cornerv
and
provide
a
closer
view
of
binder
explaining
its
functionality
without
going
into
the
not
so
well
documented
source
a
little
history
the
android
binder
mechanism
traces
its
root
back
to
the
binder
of
another
mobile
operating
system
beos
binder
served
as
the
underlying
support
interconnecting
beos's
rich
set
of
frameworks
once
heralded
as
the
next
generation
operating
system
beos
never
gained
much
traction
save
for
a
few
fans
and
was
eventually
acquired
by
palm
if
the
name
doesn't
ring
a
bell
that's
fine
palm
pilots
were
all
the
rage
back
at
the
end
of
the
last
millenium
catapulting
3com
to
great
heights
before
palm
was
split
off
and
spiraled
back
to
earth
palm
was
eventually
acquired
by
hp
and
its
os
served
as
the
basis
for
webos
another
venture
that
fell
far
short
of
its
promise
binder
however
survived
besides
being
ported
to
palmos
and
integrated
into
their
cobalt
architecture
it
was
also
ported
to
other
operating
systems
including
of
course
linux
the
linux
port
was
open
sourced
at
http
openbinder.org
and
though
the
website
seems
to
have
died
since
some
mirrors1
survived
the
original
developers
left
palm
to
join
android
and
brought
binder
with
them
chief
amongst
them
was
dianne
hackborn
a
well
renowned
developer
and
still
one
of
the
major
figures
driving
android
today
an
interview
she
gave
to
osnews2
back
in
2006
explained
the
fundamentals
of
openbinder
android's
implementation
of
binder
is
more
specific
than
openbinder
and
just
like
as
originally
intended
in
beos
serves
as
the
fulcrum
for
all
of
its
frameworks
so
what
exactly
is
binder
binder
is
a
remote
procedure
call
mechanism
allowing
applications
to
communicate
programmatically
but
without
having
to
worry
about
how
to
send
and
receive
messages
from
the
application's
perspective
server
or
client
all
it
needs
to
do
is
either
call
a
method
client
or
provide
a
method
service
when
the
client
calls
the
method
the
corresponding
method
is
magically
invoked
in
the
service
with
all
the
details
handled
transparently
by
binder
these
minutiae
include
locating
the
service
process
in
most
cases
the
client
and
the
service
are
two
different
processes
notwithstanding
the
binder
needs
to
locate
the
service
process
for
the
client
so
as
to
be
able
to
deliver
the
message
this
location
service
also
known
as
endpoint
mapping
is
technically
handled
by
as
explained
previously
but
the
is
only
responsible
for
maintaing
the
service
directory
mapping
an
interface
name
to
a
binder
handle
the
handle
is
an
opaque
identifier
which
was
given
to
the
by
binder
and
which
only
binder
knows
the
true
meaning
of
that
is
the
underlying
pid
wherein
the
service
is
located
delivering
the
message
as
discussed
previously
aidl
is
used
to
generate
the
code
which
takes
the
parameters
of
the
called
method
and
serializes
them
i.e
packs
them
into
a
structure
in
memory
or
deserializes
them
unpacks
the
structure
back
to
individual
parameters
the
passing
of
the
serialized
structure
from
one
process
to
another
however
is
handled
by
binder
itself
clients
call
the
which
sends
the
message
over
binder
and
blocks
until
a
reply
is
returned
hence
the
code
first
write
then
read
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
http
openbinder.org
http
www.angryredplanet.com
hackbod
openbinder
docs
html
http
www.osnews.com
story
13674
introduction_to_openbinder_and_interview_with_dianne_hackborn
file
users
morpheus
documents
android
book
systemserver.html
ipcrpc
delivering
objects
binder
can
be
used
to
pass
around
objects
the
service
handles
mentioned
previously
are
one
such
type
of
an
object
but
so
are
file
descriptors
just
like
unix
domain
sockets
passing
around
descriptors
is
an
especially
important
feature
as
it
allows
a
trusted
process
such
as
to
natively
open
a
device
or
socket
for
an
untrusted
process
such
as
a
user
app
assuming
the
untrusted
process
has
the
required
permission
as
specified
in
the
app's
manifest
supporting
credentials
inter
process
communication
naturally
has
significant
security
aspects
a
recipient
of
a
message
has
to
be
able
to
verify
the
identity
of
the
sender
so
as
not
to
be
tricked
into
compromising
overall
system
security
binder
is
aware
of
its
users
credentials
pid
and
uid
and
securely
embeds
them
in
messages
so
peers
can
operate
with
a
reasonable
level
of
security
using
binder
binder
is
used
in
all
applications
whether
or
not
the
developers
themselves
realize
it
the
code
involved
in
binder
operates
on
no
less
than
three
levels
as
shown
in
figure
6
3
figure
6
3
message
flow
between
client
and
server
using
binder
in
an
effort
to
be
true
to
the
power
user's
view
adopted
in
this
work
figure
6
3
is
as
far
as
we
go
for
now
more
detail
on
the
various
levels
from
the
java
objects
through
aidl
native
and
kernel
can
be
found
in
volume
ii
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
tracing
binder
the
dev
binder
connection
multiplexes
any
number
of
service
connections
over
the
same
file
descriptor
this
means
that
a
process
will
hold
that
descriptor
irrespective
of
whether
it
is
connected
to
one
service
or
to
many
indeed
a
process
can
hold
this
descriptor
and
not
be
connected
yet
to
any
services
at
all
it
follows
then
that
there's
no
simple
way
to
see
exactly
which
services
a
given
handle
is
connected
to
if
the
binder
debug
functionality
is
enabled
through
the
linux
debugfs
filesystem
sys
kernel
debug
binder
however
you
can
use
the
tool
on
the
book's
companion
website
to
figure
out
who's
connected
to
what
as
shown
in
the
following
experiment
experiment
using
the
tool
to
view
open
binder
handles
the
tool
which
you
can
find
on
the
book's
companion
website
is
nothing
more
than
a
simple
derivative
of
the
command
which
obtains
a
handle
to
the
system
service
of
choice
as
does
and
then
inspects
its
own
entry
in
the
sys
kernel
debug
binder
proc
directory
each
process
using
binder
has
a
pseudo
file
containing
various
statistics
and
the
entries
contained
therein
reveal
the
pids
connected
on
the
other
end
because
all
the
binder
debug
data
is
world
readable
you
can
run
this
tool
on
unrooted
devices
as
well
output
6
3
revealing
binder
endpoints
using
the
utility
the
book's
companion
website
also
provides
a
special
version
of
the
linux
system
call
tracing
tool
with
augmented
functionality
that
includes
parsing
of
binder
messages
i.e
deciphering
codes
and
payloads
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
inquire
about
wallpaper
service
shell
htc_m8wl
data
local
tmp
bindump
wallpaper
service
wallpaper
node
ref
2034
com.htc.launcheruser
pid
1377
user
pid
1194
owner
pid
1008
user
pid
368
com.android.systemui
system_server
system
bin
servicemanager
who
owns
the
batterypropreg
service
shell
htc_m8wl
data
local
tmp
bindump
owner
batterypropreg
service
batterypropreg
node
ref
105785
owner
pid
8153
sbin
healthd
http
newandroidbook.com
files
bindump.tar
system_server
android
devices
have
dozens
of
services
and
along
with
vendor
and
user
installed
apps
this
number
can
exceed
one
hundred
fortunately
the
vast
majority
of
framework
services
are
simple
enough
that
they
do
not
require
their
own
process
and
can
instead
run
as
threads
these
threads
however
need
a
host
process
to
run
in
and
that
is
exactly
what
system_server
provides
similar
to
windows
svchost.exe
the
provides
nothing
more
than
a
shell
a
container
process
the
two
can
also
be
compared
in
the
sense
that
svchost.exe
loads
services
through
dynamically
linked
libraries
dlls
whereas
loads
java
classes
in
android
however
this
is
even
more
important
a
function
though
the
dalvik
vm
is
optimized
for
sharing
running
services
alongside
one
another
in
the
same
vm
provides
an
even
greater
savings
in
resources
this
does
not
come
without
a
bit
of
risk
however
as
a
misbehaving
service
can
thus
affect
its
siblings
for
the
most
part
though
this
isn't
much
of
a
concern
as
only
android's
system
services
and
not
those
of
the
vendor
or
additional
apps
are
allowed
to
run
inside
system_server
the
is
not
a
native
app
it
is
implemented
mostly
in
java
with
some
jni
calls
in
places
where
it
must
start
native
services
the
services
it
loads
are
similarly
implemented
in
java
though
a
great
deal
of
them
also
rely
on
jni
to
escape
the
virtual
machine
and
interact
with
hardware
components
zygote
automatically
starts
the
system_server
when
it
itself
is
started
by
the
init.rc
q.v
figure
5
22
with
the
switch
the
switch
makes
zygote
invoke
in
which
are
hardcoded
the
arguments
capabilities
group
memberships
the
nice
name
system_server
and
the
class
to
load
the
does
not
execute
with
root
privileges
but
comes
pretty
close
uid:gid
of
enhanced
capabilities
and
a
host
of
secondary
group
memberships
the
security
perspective
of
gids
and
capabilties
is
shown
in
chapter
8
startup
and
flow
for
such
an
important
fulcrum
of
the
entire
system
system_server
has
a
rather
simple
flow
once
it
has
forked
off
from
zygote
the
child
process
drops
its
privileges
and
toggles
the
capabilities
as
discussed
above
it
then
proceeds
to
load
the
class
whose
performs
basic
initialization
notably
lifting
its
vm
limits
and
loading
the
to
perform
jni
component
initialization
before
instantiating
the
framework
services
once
all
services
have
been
created
and
their
corresponding
threads
spun
with
nothing
else
to
do
the
main
thread
enters
a
looper
to
loop
hopefully
endlessly
unless
the
system
is
shut
down
the
high
level
flow
is
shown
in
figure
6
4
on
the
next
page
there
are
numerous
system
services
to
start
however
and
needs
to
instantiate
them
one
by
one
android
l
takes
great
steps
in
refactoring
this
flow
even
though
much
work
remains
the
flow
is
significantly
simplified
from
previous
version
by
grouping
services
of
similar
classification
there
are
currently
three
classes
bootstrap
services
these
include
the
and
additionally
a
check
is
performed
if
the
device's
data
partition
is
encrypted
or
in
the
process
of
encryption
which
affects
startup
by
starting
only
apps
designated
as
core
apps
core
services
these
include
the
and
the
the
last
is
a
new
service
in
l
which
periodically
checks
the
browser
component
for
any
updates
other
services
basically
everything
else
there
are
dozens
of
services
in
this
class
which
the
source
admits
is
a
miscellaneous
grab
bag
of
stuff
that
has
yet
to
be
refactored
and
organized
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
f5
22
file
users
morpheus
documents
android
book
security.html
ss
figure
6
4
the
flow
of
system
server
not
all
the
services
are
visible
to
applications
some
like
the
are
internal
and
thus
invisible
both
to
apps
as
well
as
we
discuss
all
the
services
internal
and
app
facing
one
by
one
in
the
next
chapters
once
the
services
are
started
has
nothing
more
to
do
in
its
main
thread
the
thread
therefore
enters
its
looper
which
hopefully
loops
indefinitely
we
say
hopefully
since
the
looper
is
not
expected
to
exit
and
will
throw
a
runtime
exception
if
it
does
internally
the
loop
blocks
polling
its
file
descriptors
and
in
particular
its
binder
handle
for
incoming
messages
when
messages
arrive
they
are
dispatched
to
their
respective
targets
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
file
users
morpheus
documents
android
book
services
ii.html
modifying
startup
behavior
the
flow
of
and
the
classes
of
services
it
starts
can
be
modified
by
setting
certain
system
properties
a
key
parameter
is
the
system
property
which
defines
whether
or
not
the
device
is
configured
for
a
factory
test
mode
affecting
the
startup
of
according
to
the
following
values
table
6
5
factory
test
values
and
their
impact
on
startup
value
define
implies
0
default
factory_test_none
normal
startup
1
factory_test_low_level
2
factory_test_high_level
another
important
parameter
is
the
system
property
which
if
set
disables
the
wallpaper
service
and
the
system
ui
services
the
family
of
properties
can
also
be
used
to
selectively
disable
subsystems
as
shown
in
table
6
6
table
6
6
properties
affecting
system
services
property
disables
disable_storage
mountservice
disable_media
audioservice
wiredaccessorymanager
commontimemanagementservice
disable_bluetooth
bluetoothmanagerservice
disable_telephony
unused
disable_location
locationmanagerservice
countrydetectorservice
disable_systemui
statusbarmanagerservice
disable_noncore
updatelockservice
locksettingsservice
textservicesmanager
searchmanagerservice
wallpapermanagerservice
dockobserver
usbservice
disable_network
networkstatsservice
networkpolicymanagerservice
wifip2pservice
wifiservice
connectivityservice
nsdservice
networktimeupdateservice
certblacklister
thanks
to
the
linux
proc
filesystem
you
can
examine
system_server
and
its
many
threads
looking
at
its
file
descriptors
is
somewhat
futile
it's
impossible
to
tell
which
descriptors
belong
to
which
thread
and
most
of
them
are
sockets
and
pipes
anyways
enumerating
the
threads
however
can
be
useful
this
is
shown
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
no
bluetooth
input
accessibility
lock
settings
uid
0
for
factory
test
applications
experiment
unraveling
the
threads
of
system_server
dalvik's
thread
objects
may
be
named
when
created
naming
a
thread
calls
the
underlying
system
call
a
little
known
but
highly
useful
api
which
allows
the
renaming
of
threads
and
processes
at
the
kernel
level
the
name
is
then
visible
through
the
proc
filesystem
in
the
status
proc
entry
of
the
thread
the
method
is
not
perfect
as
it
allows
for
only
16
characters
in
a
name
but
it
sure
beats
rummaging
through
random
thread
identifiers
trying
to
figure
out
which
does
what
using
a
basic
script
which
even
android's
olplwhg
shell
supports
you
can
easily
enumerate
the
threads
and
get
their
individual
names
this
works
on
any
process
so
as
long
as
the
iterates
over
its
task
subdirectory
which
contains
a
directory
entry
for
each
thread
binder
threads
and
thread
pools
are
omitted
from
this
output
output
6
4
iterating
through
threads
tids
aren't
normally
predictable
but
a
large
part
of
system_server's
are
started
incrementally
and
so
looking
at
the
ids
can
give
you
a
sense
as
to
the
system's
framework
startup
kdswhu
9
7kh
udphzrun
6huylfh
ufklwhfwxuh
root
flounder
proc
507
task
for
t
in
do
echo
thread
t
grep
name
t
status
done
507
name
system_server
the
main
thread
same
as
pid
512
name
heap
thread
poo
l
art
heap
thread
pool
514
name
signal
catcher
dalvik
signal
catcher
515
name
referencequeued
dalvik
reference
queue
daemon
516
name
finalizerdaemon
dalvik
object
finalizer
517
name
finalizerwatchd
dalvik
finalizer
watchdog
518
name
heaptrimmerdaem
l
art
heap
trimmer
daemon
519
name
gcdaemon
garbage
collector
l
gcdaemon
for
art
524
name
sensorservice
525
name
sensoreventackr
526
name
android.bg
527
name
activitymanager
529
name
fileobserver
fileobserver
thread
530
name
android.fg
531
name
android.ui
532
name
android.io
533
name
android.display
534
name
cputracker
created
by
activitymanager
535
name
powermanagerser
created
by
powermanagerservice
537
name
batterystats_wa
562
name
packagemanager
created
by
594
name
packageinstalle
packagemanage
596
name
alarmmanager
created
by
alarmmanagerservice
597
name
inputdispatcher
started
by
inputmanager
started
by
inputmanager598
name
inputreader
599
name
mountservice
600
name
voldconnector
602
name
netdconnector
created
by
mountservice
created
by
mountservice
created
by
connectivitymanager
603
name
networkstats
604
name
networkpolicy
605
name
wifip2pservice
606
name
wifistatemachin
607
name
wifiservice
608
name
connectivityser
created
by
connectivitymanager
neighbor
services
discovery
state
machine
thread
609
name
nsdservice
610
name
mdnsconnector
611
name
ranker
613
name
audioservice
622
name
ueventobserver
623
name
backup
created
by
nsdservice
created
by
notificationmanagerservice
created
by
audioservice
audiosystemthread
kernel
uevent
observer
shared
by
many
services
created
by
backupmanagerservice
626
name
wifiwatchdogsta
627
name
wifimanager
628
name
wifiscanningser
629
name
wifirttservice
630
name
ethernetservice
634
name
lazytaskwritert
activitymanager's
taskpersister
635
name
usbservice
host
844
name
watchdog
845
name
soundpool
audioservice
soundpoollistenerthread
846
name
soundpoolthread
audioservice
soundpoollistenerthread
906
name
networktimeupda
networktimeupdateservice's
handlerthread
984
name
ipc
thread
1009
name
wifimonitor
1507
name
synchandler
0
1513
name
usbdebuggingman
summary
this
chapter
discussed
the
android
framework
service
architecture
explaining
the
underlying
mechanisms
of
inter
process
communication
ipc
through
remote
procedure
call
rpc
in
android
focusing
on
the
role
of
the
and
the
utility
it
then
focused
on
the
process
which
serves
as
a
host
to
android's
myriad
frameworks
all
implemented
in
java
this
naturally
begs
much
more
discussion
specifically
of
the
dozens
of
services
and
of
binder
the
transport
that
facilitates
rpc
this
discussion
however
is
left
for
volume
ii
files
discussed
in
this
chapter
component
file
contains
servicemanager
f
native
cmds
servicemanager
service_manager.c
body
of
service
manager
frameworks
native
cmds
servicemanager
binder
ch
binder
interface
systemserver
f
b
services
java
com
android
server
systemserver.java
the
class
references
1
openbinder
documentation
mirror
http
www.angryredplanet.com
hackbod
openbinder
docs
html
2
osnews
interview
with
dianne
hackborn
http
www.osnews.com
story
13674
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
www.angryredplanet.com
hackbod
openbinder
docs
html
http
www.osnews.com
story
13674
introduction_to_openbinder_and_interview_with_dianne_hackborn
vii
android
through
a
linux
lens
android
developers
are
accustomed
to
thinking
about
their
applications
in
terms
of
the
android
lifecycles
described
in
the
previous
chapter
from
the
linux
perspective
however
android
applications
are
linux
processes
and
aren't
much
different
from
any
other
process
on
the
system
this
chapter
puts
that
very
perspective
in
focus
we
first
discuss
the
facilities
linux
provides
for
process
monitoring
and
tracing
through
the
proc
filesystem
which
was
touched
on
briefly
in
chapter
2
but
is
now
explored
in
the
detail
it
deserves
we
discuss
the
per
process
and
per
thread
entries
in
proc
pid
which
allow
you
to
poll
for
real
time
on
the
fly
statistics
first
we
discuss
the
symbolic
links
that
report
working
directories
we
next
focus
on
the
highly
useful
fd
and
fdinfo
subdirectories
which
provides
accurate
representations
of
open
file
descriptors
next
up
is
the
status
entry
which
gives
a
high
level
view
of
the
process
and
in
particular
thread
state
and
virtual
memory
virtual
memory
is
an
important
metric
for
diagnosing
performance
so
the
next
section
focuses
on
the
basics
of
user
memory
management
going
into
theoretical
concepts
but
also
presenting
the
smaps
proc
entry
and
two
tools
procrank
and
librank
which
you
can
use
to
get
accurate
memory
statistics
we
then
explain
the
dreaded
out
of
memory
condition
the
bane
of
android's
application
lifecycle
forcing
the
app
to
live
in
the
shadow
of
ever
looming
and
very
unpredictable
death
lastly
we
explain
system
calls
showing
the
tool
the
proc
entries
of
wchan
and
syscall
and
the
all
powerful
strace
tool
which
you
can
use
for
active
tracing
the
chapter
relies
heavily
on
concepts
from
operating
system
theory
and
is
full
of
hands
on
experiments
meant
to
further
elucidate
these
concepts
which
are
far
from
trivial
the
methods
and
experiments
shown
in
this
chapter
are
all
based
on
linux
kernel
features
which
makes
them
just
as
applicable
on
a
linux
system
as
they
are
in
android
so
you
might
consider
referring
to
this
chapter
for
linux
debugging
tips
a
subject
on
which
there
is
a
surprising
dearth
of
books
on
file
users
morpheus
documents
android
book
anatomy.html
lifecycle
file
users
morpheus
documents
android
book
filesystems.html
proc
file
users
morpheus
documents
android
book
linuxlens.html
symlinks
file
users
morpheus
documents
android
book
linuxlens.html
fd
file
users
morpheus
documents
android
book
linuxlens.html
fdinfo
file
users
morpheus
documents
android
book
linuxlens.html
status
file
users
morpheus
documents
android
book
linuxlens.html
threadstate
file
users
morpheus
documents
android
book
linuxlens.html
hlmem
file
users
morpheus
documents
android
book
linuxlens.html
memmgmt
file
users
morpheus
documents
android
book
linuxlens.html
oom
file
users
morpheus
documents
android
book
linuxlens.html
syscalls
proc
revisited
the
proc
filesystem
was
touched
on
in
chapter
2
the
touch
was
hardly
a
graze
however
as
it
has
not
begun
to
scratch
the
surface
of
this
extremely
important
filesystem
in
particular
the
per
process
and
thread
directories
in
proc
with
their
plethora
of
real
time
diagnostic
information
about
the
inner
workings
of
applications
to
understand
the
per
process
directories
think
of
a
process
as
in
object
oriented
terms
a
process
can
be
thought
of
as
an
instance
of
a
process
class
all
instances
of
which
have
the
same
properties
though
naturally
property
values
may
differ
the
pseudo
files
in
the
per
process
directory
simply
show
you
the
values
of
the
properties
and
in
some
cases
if
they
are
writable
allow
you
to
modify
these
properties
output
7
1
shows
the
entries
the
android
shell
would
see
in
its
own
directory
using
as
the
process
id
of
the
current
shell
note
we
don't
use
proc
self
because
would
see
itself
the
filter
is
optional
and
is
used
only
to
improve
readability
output
7
1
annotated
per
process
entries
in
l
3.10
kernel
remember
none
of
these
are
actually
files
this
means
two
things
the
exact
listing
of
the
file
may
change
according
to
your
kernel
version
in
general
the
newer
the
kernel
the
more
likely
you
are
to
have
more
pseudofiles
though
support
for
some
of
them
may
be
disabled
when
compiling
the
kernel
kdswhu
9
6hfxulw
file
users
morpheus
documents
android
book
filesystems.html
proc
the
files
aren't
really
there
until
you
ask
for
them
which
means
that
every
time
you
display
the
files
you're
likely
to
get
different
content
when
using
the
kernel
doesn't
even
bother
reporting
file
sizes
which
is
why
if
you
try
the
above
command
without
the
filter
all
file
sizes
are
shown
as
0
the
last
point
is
a
very
important
one
to
consider
because
the
files
are
purely
virtual
there
is
no
overhead
in
maintaining
the
proc
entries
the
kernel
maintains
all
these
statistics
anyway
during
normal
operation
all
it
takes
is
faking
the
existence
of
these
files
and
when
the
user
asks
for
any
collecting
the
statistics
in
real
time
and
providing
them
in
pseudo
file
form
this
makes
the
proc
filesystem
an
extremely
powerful
mechanism
for
system
and
process
tracing
provided
the
method
used
is
that
of
polling
tracing
by
polling
means
that
the
tracing
program
or
script
has
to
keep
on
explicitly
asking
for
specific
proc
entries
periodically
because
proc
entries
do
not
support
on
change
callbacks
at
least
not
yet
this
does
have
certain
disadvantages
if
the
polling
granularity
is
too
coarse
you
may
end
up
missing
the
exact
event
you
were
trying
to
intercept
but
the
advantage
zero
overhead
clearly
outweighs
the
disadvantage
the
human
readability
and
ease
of
parsing
of
the
pseudofiles
is
another
clear
advantage
as
we
demonstrate
in
this
chapter
because
kernels
change
so
frequently
this
unfortunately
has
the
side
effect
of
leaving
the
documentation
on
linux
systems
with
installed
somewhat
outdated
and
not
all
these
are
properly
documented
we
next
turn
our
attention
to
some
of
the
more
important
of
these
pseudo
files
which
you
can
readily
use
when
profiling
or
debugging
the
system
the
symlinks
cwd
exe
root
looking
at
output
7
1
three
entries
immediately
stand
out
those
of
cwd
exe
and
root
the
reason
they
are
different
is
because
they
are
shown
as
symbolic
links
whereas
other
entries
are
shown
as
pseudo
files
the
rationale
behind
displaying
these
entries
as
symbolic
links
is
readability
all
three
entries
point
to
files
or
directories
and
by
using
symbolic
links
it
makes
it
easier
for
the
user
to
apply
a
file
operation
e.g
on
the
target
of
the
link
which
most
commands
follow
automatically
rather
than
have
to
first
display
the
contents
of
a
pseudo
file
then
embed
the
output
into
the
next
command
the
three
entries
give
you
the
most
important
high
level
statistics
for
the
process
namely
cwd
which
displays
the
current
working
directory
in
output
7
1
you
could
see
from
the
prompt
that
the
shell's
present
working
directory
is
data
and
that
is
exactly
what
the
cwd
link
is
pointing
to
a
fun
experiment
is
to
to
any
directory
of
your
choice
then
repeat
the
you
will
see
that
you
can
run
but
youcan't
hide
any
time
you
use
the
query
the
cwd
entry
the
kernel
retrieves
the
working
directory
at
that
moment
which
means
you
will
always
get
the
right
directory
exe
which
displays
the
full
path
to
the
executable
used
to
start
this
process
that
is
the
one
loaded
by
the
system
call
this
is
useful
because
many
processes
can
change
their
name
as
displayed
in
during
their
lifetime
but
they
cannot
change
this
entry
root
which
displays
the
root
directory
normally
this
will
be
the
real
root
directory
if
an
application
is
ed
that
is
confined
to
a
subdirectory
which
is
defined
as
its
new
root
this
will
be
clearly
visible
from
this
entry
the
cwd
and
root
entries
are
used
by
tools
such
as
fuser
and
lsof
which
find
open
files
and
directories
by
patname
fuser
or
by
process
lsof
knowing
this
it
becomes
a
simple
matter
to
implement
both
these
utilities
as
shell
scripts
which
could
become
quite
useful
on
systems
which
do
not
have
these
tools
pre
installed
the
following
experiment
shows
how
a
similar
shell
script
trick
can
be
used
with
the
seemingly
less
useful
exe
entry
experiment
determining
the
32
64
bitness
of
android
apps
at
first
glance
an
entry
such
as
exe
seems
somewhat
useless
after
all
in
most
cases
the
executable
name
isn't
really
expected
to
change
during
the
process
lifetime
or
is
it
it
turns
out
that's
not
always
the
case
a
good
example
in
android
are
the
various
dalvik
apps
spawns
of
zygote
all
changing
their
name
to
that
of
the
loaded
class
they
are
executing
this
is
done
by
changing
the
value
of
argv
0
using
the
system
call
the
real
name
of
all
these
apps
is
still
system
bin
app_process
which
is
the
true
instance
of
the
vm
which
loaded
them
in
l
this
is
even
more
useful
because
32
bit
apps
will
be
clearly
visible
as
app_process32
whereas
64
bit
ones
will
be
app_process64
the
following
example
shows
how
you
can
use
that
to
your
advantage
in
a
shell
script
output
7
2
using
the
exe
proc
entry
to
figure
out
32
64
bitness
of
an
app
to
understand
the
script
better
note
the
pattern
used
1
to
the
proc
directory
because
everything
starts
here
2
iterate
over
0
9
entries
the
root
of
proc
contains
additional
files
alongside
the
per
process
entries
we
want
just
the
per
process
directories
so
we
isolate
only
those
entries
beginning
with
a
digit
this
will
run
a
loop
with
set
to
the
pid
iterator
3
perform
check
by
looking
at
the
exe
proc
entry
note
the
use
of
with
output
discarded
we're
only
interested
in
whether
or
not
there
was
output
s
implicit
return
value
which
is
what
the
will
branch
by
because
there
are
actually
three
cases
here
or
neither
we
don't
use
and
construct
but
two
separate
statements
4
print
out
the
user
facing
output
using
taking
advantage
of
its
nul
separation
when
employing
only
argv
0
is
printed
this
is
better
than
the
comm
entry
since
the
latter
is
truncated
at
16
bytes
note
also
the
use
of
our
iterator
which
holds
the
pid
which
shows
the
initial
was
like
chekhov's
gun
at
first
glance
the
idea
of
running
a
script
inline
might
deter
some
readers
that's
understandable
especially
when
considering
the
rigid
syntax
of
shell
scripting
which
is
why
this
is
an
experiment
you're
urged
to
try
this
at
least
once
for
yourself
remember
however
that
every
inline
script
like
that
can
easily
be
put
into
a
file
ed
thereby
becoming
a
new
tool
for
you
to
add
to
your
arsenal
the
exact
same
pattern
iterating
and
ping
albeit
with
different
proc
entries
can
be
adapted
to
create
custom
reusable
tools
which
will
work
correctly
both
on
android
and
linux
systems
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
fd
a
process
performs
all
of
its
i
o
through
file
descriptors
the
files
pipes
and
sockets
opened
irrespective
of
language
java
c
or
other
all
map
to
numbered
file
descriptors
with
three
default
ones
standard
input
and
standard
error
numbered
0
1
and
2
respectively
when
a
process
opens
or
creates
a
file
or
socket
pipe
etc
the
created
object
is
linked
to
the
next
available
descriptor
what
appears
to
the
process
as
a
number
is
in
fact
a
handle
to
an
opaque
object
that
only
has
true
meaning
in
the
kernel
wherein
that
handle
is
deciphered
as
an
index
to
an
array
of
objects
it
is
therefore
of
the
utmost
importance
to
be
able
to
figure
out
which
descriptors
a
process
is
using
in
real
time
there
are
quite
a
few
tools
for
that
most
notably
list
open
files
which
dumps
open
files
per
process
along
with
other
mappings
rather
than
rely
on
however
which
may
or
may
not
be
present
in
a
given
distribution
it
often
makes
sense
to
get
the
information
straight
from
the
horse's
mouth
that
is
from
proc
pid
fd
the
fd
subdirectory
follows
the
same
symlink
convention
as
the
cwd
exe
and
root
entries
described
in
the
previous
section
this
makes
it
extremely
useful
to
just
a
given
pid's
fd
directory
in
order
to
figure
out
which
files
are
in
use
so
useful
in
fact
that
this
work
demonstrated
the
technique
several
times
by
now
in
previous
chapters
it
couldn't
be
simpler
but
be
aware
that
listing
descriptors
does
require
root
privileges
if
you
are
not
the
owner
of
the
process
and
by
corollary
the
proc
pid
fd
directory
output
7
3
showing
the
file
descriptors
of
a
process
zygote
through
proc
pid
fd
for
regular
files
this
works
perfectly
the
convention
isn't
as
useful
however
when
it
gets
to
sockets
since
sockets
have
no
filesystem
representation
some
un
x
sockets
notwithstanding
there
is
nothing
to
symlink
to
it
would
be
trivial
to
add
a
fake
symlink
which
would
contain
a
string
of
the
ip
or
domain
socket
in
question
but
at
the
time
of
writing
the
linux
kernel
opts
instead
to
take
the
path
of
least
resistance
and
simply
spit
out
the
inode
number
associated
with
the
socket
you
can
see
the
socket
numbers
above
for
descriptors
7
10
11
and
13
but
where
do
these
sockets
connect
to
fortunately
there
are
other
pseudofiles
in
procfs
which
will
resolve
this
data
for
you
the
following
experiment
shows
how
to
figure
out
sockets
both
un
x
and
ip
kdswhu
9
7kurxjk
d
lqx
hqv
experiment
resolving
inodes
to
socket
names
through
proc
net
it's
always
possible
to
cheat
and
use
a
tool
like
but
not
the
toolbox
tool
to
automatically
resolve
all
descriptors
including
sockets
for
you
but
with
a
little
bit
more
knowledge
of
linux
procfs
files
it's
not
that
hard
to
do
so
on
your
own
the
sockets
in
linux
and
android
are
usually
one
of
the
following
types
un
x
domain
sockets
used
for
local
only
communication
some
of
these
sockets
are
named
i.e
they
have
a
filesystem
representation
in
practice
these
are
not
really
files
domain
sockets
are
in
memory
kernel
constructs
and
the
filename
is
used
to
ensure
system
wide
uniqueness
in
android
these
sockets
are
located
in
dev
socket
with
an
additional
type
of
sockets
using
naming
conventions
which
do
not
appear
on
the
filesystem
other
sockets
may
remain
unnamed
the
kernel
keeps
the
domain
socket
statistics
in
proc
net
unix
ip
based
sockets
over
ipv4
and
or
ipv6
linux
and
android
differentiates
between
the
two
address
families
and
further
differentiates
by
protocol
type
udp
or
tcp
as
a
consequence
there
are
thus
no
less
than
four
files
to
consult
tcp6
udp6
tcp
and
udp
netlink
sockets
used
as
an
efficient
kernel
user
space
notification
mechanism
these
are
unique
to
linux
and
are
also
favored
because
of
their
multicast
capabilities
i.e
it
is
possible
to
share
a
socket
between
members
of
a
group
sending
messages
to
all
of
them
at
once
statistics
are
kept
at
proc
net
netlink
for
ip
based
sockets
a
simple
method
is
to
look
for
the
inode
number
in
the
various
proc
net
statistics
files
since
there
are
four
files
it's
quicker
to
do
so
by
using
as
shown
in
the
following
output
output
7
4
figuring
out
ip
sockets
from
proc
net
tools
such
as
or
but
not
those
of
can
parse
the
output
but
if
you
do
it
manually
all
it
takes
is
a
bit
of
hex
juggling
the
format
of
the
lines
is
which
gives
you
the
details
you
need
mappings
for
un
x
domain
sockets
are
unfortunately
not
always
this
easy
sometimes
using
will
yield
the
socket
name
from
proc
net
unix
but
often
times
the
socket
is
unnamed
which
makes
it
difficult
to
figure
out
which
peer
is
connected
to
it
in
some
cases
it's
possible
to
recover
the
other
end
by
trying
one
number
lower
or
higher
which
may
still
be
an
unnamed
socket
but
using
and
looking
for
it
often
reveals
the
other
end
point's
holder
this
is
not
a
fool
proof
method
because
at
times
sockets
are
not
created
in
pairs
but
it's
the
simplest
way
of
deducing
the
number
in
absence
of
kernel
symbols
and
proc
kcore
there
are
less
often
encountered
types
such
as
raw
sockets
which
naturally
maintain
statistics
in
other
files
technically
it's
more
accurate
to
read
proc
pid
net
family
since
sockets
may
be
contained
in
a
namespace
proc
net
offers
the
global
namespace
however
so
this
works
well
too
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
fdinfo
at
first
glance
the
fdinfo
directory
looks
unimpressive
just
like
fd
but
without
symbolic
links
or
fancy
colors
the
information
contained
in
fdinfo
however
is
just
as
important
as
fd
if
not
more
so
for
every
open
file
descriptor
the
corresponding
fdinfo
entry
holds
metadata
about
the
file
device
drivers
and
filesystem
implementors
may
use
this
file
to
convey
information
about
the
current
state
of
the
file
descriptor
back
to
user
space
though
in
practice
few
do
leaving
only
the
default
information
maintained
by
the
kernel
itself
specifically
flags
the
flags
used
in
the
system
call
when
creating
or
opening
the
file
these
are
defined
in
the
fcntl.h
header
file
pos
the
current
position
of
the
file
pointer
i.e
the
offset
of
the
next
byte
to
be
read
or
written
from
the
file
the
pos
statistic
in
a
real
gem
because
it
can
let
you
monitor
a
process
and
figure
out
roughly
where
along
its
timeline
it
presently
is
all
entirely
unobtrusively
with
a
little
bit
of
shell
scripting
you
can
harness
this
functionality
to
create
custom
tools
to
conditionally
operate
on
a
process
as
shown
in
the
following
listing
listing
7
1
a
small
script
to
watch
and
act
on
a
file
position
in
a
process
the
one
drawback
of
the
above
script
is
that
it
relies
on
polling
rather
than
notification
simply
put
the
results
will
potentially
change
in
between
executions
and
depending
on
when
you
choose
to
execute
it
you
might
end
up
missing
the
precise
offset
you
were
looking
for
this
can
be
assuaged
by
running
the
script
at
regular
intervals
and
or
changing
the
offset
parameter
to
allow
for
more
leeway
i.e
set
the
offset
to
a
little
bit
before
the
actual
required
offset
and
use
conventional
debugging
from
the
point
on
the
script
shown
above
is
really
an
example
of
a
pattern
which
can
be
used
all
over
procfs
to
harvest
data
and
perform
operations
based
on
values
collected
because
procfs
exports
its
data
as
pseudo
files
it
just
takes
knowing
the
right
filename
and
a
mastery
of
the
un
x
filters
cut
grep
sort
and
their
ilk
to
create
any
number
of
customized
tools
in
fact
most
of
the
tools
you
probably
know
and
love
or
at
least
respect
can
be
implemented
in
script
form
by
iterating
over
procfs
and
the
useful
per
process
thread
entries
especially
stat
or
status
shown
next
kdswhu
9
7kurxjk
d
lqx
hqv
status
the
status
proc
entry
is
a
one
stop
shop
for
all
the
things
you'd
want
to
know
at
a
high
level
on
the
process
being
inspected
and
not
just
what
you
would
like
to
know
so
much
as
what
the
kernel
would
the
status
is
effectively
a
human
readable
dump
of
the
which
is
a
mammoth
structure
in
the
linux
kernel
serving
as
the
process
control
block
pcb
this
is
what
the
kernel
sees
at
a
glance
when
handling
a
process
output
7
5
the
annotated
proc
pid
status
entry
there
is
copious
output
here
so
it
makes
sense
to
go
over
the
non
obvious
fields
step
by
step
sorting
out
the
pid
tid
tgid
and
ppid
confusion
it's
tempting
to
think
that
pid
would
stand
for
process
id
right
well
tough
it
doesn't
originally
linux
did
actually
use
pid
as
process
ids
but
ever
since
the
turn
of
the
millenium
linux
joined
other
modern
operating
systems
in
scheduling
threads
and
not
processes
as
such
correctly
describes
the
thread
and
not
the
process
id
of
the
entry
being
inspected
a
process
is
therefore
a
group
of
threads
sharing
the
same
resources
virtual
memory
file
descriptors
etc
and
that
is
what
is
shown
by
the
field
some
readers
may
first
balk
at
this
especially
when
in
the
above
example
the
fields
and
fields
hold
the
same
value
there's
no
contradiction
here
though
for
the
of
a
process
the
and
the
values
will
always
match
this
is
in
fact
how
one
can
easily
determine
this
is
the
main
thread
of
the
process
in
other
words
the
first
thread
in
the
thread
group
for
child
threads
however
the
pid
will
change
while
the
tgid
will
remain
constant
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
by
the
same
reasoning
the
ppid
field
parent
process
identifier
is
therefore
more
correctly
the
parent
thread
group
identifier
somehow
ptgid
just
doesn't
sound
as
catchy
so
it's
still
referred
to
as
ppid
it's
important
to
know
one's
lineage
because
parents
are
responsible
for
collecting
their
children's
return
code
returned
from
or
a
call
to
some
parents
also
drag
all
their
offspring
when
they
die
killing
the
entire
process
group
most
un
x
tools
are
conditioned
to
only
show
statistics
for
main
threads
and
so
the
notion
or
illusion
or
processes
still
works
pretty
well
and
thus
merits
this
section
for
explanation
the
command
in
an
effort
to
maintain
backward
compatibility
with
days
of
yore
maintains
the
lie
by
calling
as
and
when
displaying
threads
as
in
linux's
will
actually
refer
to
the
as
android's
which
displays
threads
with
the
switch
doesn't
bother
and
still
calls
the
field
the
threads
in
any
thread
group
can
be
seen
by
looking
at
the
task
subdirectory
as
shown
in
the
following
experiment
experiment
viewing
threads
and
processes
in
proc
it
often
benefits
an
administrator
or
debugger
to
sift
through
the
threads
of
multi
threaded
processes
the
proc
filesystem
offers
per
thread
statistics
unlike
linux
which
offers
the
l
state
to
denote
multi
threaded
processes
in
bsd
mode
android's
tool
only
provides
to
list
all
threads
you
can
use
the
android
tool
to
display
the
number
of
threads
output
7
6
using
to
show
number
of
threads
you
can
extend
the
pattern
of
iterating
over
processes
from
the
previous
experiment
to
also
iterate
over
a
given
thread
group's
threads
you
can
to
proc
tgid
task
to
find
numbered
subdirectories
corresponding
to
all
threads
in
the
group
including
the
main
one
if
you
then
to
the
individual
task
subdirectories
you'll
see
they
are
similar
to
the
main
thread's
entry
proc
tgid
task
tgid
in
fact
being
the
same
the
per
process
and
per
thread
entries
are
essentially
the
same
recall
linux
sees
threads
not
processes
with
nearly
all
process
level
attributes
maps
fd
etc
remaining
the
same
but
a
few
syscall
wchan
and
a
few
others
potentially
different
per
thread
kdswhu
9
7kurxjk
d
lqx
hqv
experiment
viewing
threads
and
processes
in
proc
cont
the
status
entry
can
be
particularly
confusing
because
most
of
its
entries
apply
to
the
thread
group
and
are
thus
identical
across
threads
whilst
others
do
change
on
a
per
thread
basis
the
for
example
can
indeed
be
corroborated
to
be
the
real
process
id
by
the
following
output
7
7
tgid
vs
pid
hands
on
thanks
to
android's
best
practice
of
naming
individual
threads
you
can
iterate
over
individual
threads
of
most
multi
threaded
processes
and
actually
tell
them
apart
this
is
especially
useful
for
dalvik
apps
such
as
system
server
q.v
output
6
4
or
even
for
zygote
itself
for
example
output
7
8
showing
named
threads
a
little
known
fact
is
that
you
can
directly
into
a
thread
while
listing
proc
will
only
show
main
threads
or
kernel
threads
invoking
with
a
valid
tid
will
simply
switch
into
the
per
thread
statistics
which
are
the
same
as
what
you
would
get
through
proc
tgid
task
tid
when
you
perform
the
list
procfs
gets
picky
and
filters
out
child
threads
when
you
directly
procfs
doesn't
care
if
you
specified
a
valid
thread
child
main
or
kernel
you
got
it
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
shell
flounder
proc
211
task
for
t
in
do
echo
n
pid
t
grep
tgid
t
status
done
pid
19130
tgid
211
211
211
211
pid
19131
tgid
pid
19132
tgid
pid
19133
tgid
pid
19134
tgid
211
pid
211
tgid
211
shell
flounder
proc
211
task
for
t
in
do
echo
n
pid
t
grep
name
t
status
done
referencequeuedpid
19130
name
pid
19131
name
pid
19132
name
pid
19133
name
pid
19134
name
finalizerdaemon
finalizerwatchd
heaptrimmerdaem
gcdaemon
pid
211
name
main
thread
states
and
context
switches
while
a
thread
would
optimally
want
to
always
be
running
more
often
than
not
it
doesn't
need
to
threads
spend
their
lifecycle
executing
every
now
and
then
but
more
often
than
not
they
are
waiting
for
an
event
for
user
input
for
i
o
maybe
a
mutex
or
maybe
just
a
chance
to
execute
because
all
cpus
or
cores
are
presently
occupied
by
other
threads
at
any
given
time
the
kernel
maintains
the
list
of
threads
and
for
each
it
records
the
state
the
process
itself
is
not
a
runnable
entity
thus
the
state
and
context
switching
statistics
you
see
in
the
per
process
entry
is
in
reality
that
of
the
main
thread
the
field
in
proc
status
shows
the
same
state
shown
in
android's
tool
or
linux's
in
bsd
syntax
the
states
used
are
quite
similar
to
states
in
other
un
x
such
as
darwin
and
other
bsd
and
in
fact
not
unlike
those
of
all
operating
systems
including
windows
though
the
nomenclature
is
obviously
different
the
following
state
diagram
depicts
the
transitions
between
states
figure
7
1
the
linux
thread
state
machine
kdswhu
9
7kurxjk
d
lqx
hqv
as
shown
in
the
diagram
there
is
no
clear
distinction
between
running
i.e
presently
executing
in
a
core
or
hyperthread
and
runnable
that
is
on
the
run
queue
but
waiting
for
an
available
cpu
both
are
from
the
kernel's
perspective
the
same
state
a
thread
will
actually
run
for
as
long
as
it
can
until
one
of
two
occur
preemption
occurs
when
due
to
an
external
interrupt
the
kernel
realizes
that
either
the
thread
quantum
allotted
timeslice
has
expired
or
some
higher
priority
thread
has
become
runnable
in
both
these
cases
while
the
thread
would
no
doubt
benefit
from
prolonging
execution
it
is
kicked
out
in
favor
of
another
thread
which
takes
its
place
in
what's
known
as
a
context
switch
this
is
obviously
contrary
to
what
the
thread
would
have
wanted
if
it
had
a
will
or
a
say
and
is
therefore
considered
nonvoluntary
sleep
wait
occurs
when
the
thread
simply
has
nothing
to
do
at
the
present
moment
this
can
occur
because
of
one
of
several
reasons
namely
the
user
stopped
the
thread
by
using
the
signal
un
x
users
are
likely
familiar
with
the
ctrl
z
combination
which
causes
the
terminal
driver
to
send
the
signal
to
the
main
thread
thereby
stopping
the
entire
thread
group
or
what
they
know
as
the
process
a
thread
or
group
thus
stopped
can
only
be
resumed
with
the
signal
which
is
usually
what
or
send
you
can
of
course
stop
and
resume
threads
manually
by
using
pid
and
pid
respectively
the
terminal
driver
stopped
the
thread
because
of
an
attempt
to
run
a
full
screen
command
e.g
vi
more
in
the
background
or
any
background
command
on
input
or
on
output
when
the
setting
is
set
the
signal
sent
here
is
but
otherwise
behaves
similarly
to
the
thread
actually
yielded
the
cpu
which
occurs
when
the
thread
calls
or
other
forms
of
delayed
execution
or
more
commonly
when
the
thread
is
waiting
for
an
ipc
object
e.g
a
mutex
this
can
also
occur
implicitly
when
the
thread
makes
an
i
o
call
that
cannot
be
immediately
serviced
i.e
is
not
present
in
the
buffer
or
page
caches
such
i
o
requires
storage
or
human
user
input
both
of
which
are
orders
of
magnitude
slower
than
the
cpu
the
i
o
system
call
therefore
chooses
the
greater
good
which
is
to
suspend
the
thread
and
put
it
on
an
i
o
wait
queue
when
the
i
o
is
complete
via
an
interrupt
the
thread
can
be
rescheduled
possibly
preempting
another
thread
in
any
of
these
cases
however
the
thread
agrees
or
at
least
acquiesces
the
context
switch
which
is
why
it
is
referred
to
as
a
voluntary
context
switch
the
distinction
between
voluntary
and
nonvoluntary
context
switches
is
an
important
one
which
is
why
you
can
find
those
statistics
as
fields
in
the
status
entry
a
thread
with
an
unusually
high
number
of
nonvoluntary
context
switches
keeps
getting
kicked
out
of
the
cpu
when
it
still
needs
it
which
implies
it
might
benefit
from
an
increased
priority
or
is
just
a
plain
cpu
hog
the
last
two
states
shown
in
the
diagram
zombie
and
dead
are
non
states
a
un
x
process
has
a
very
clear
raison
d'etre
its
return
code
which
it
is
supposed
to
provide
in
an
system
call
or
as
a
return
value
from
its
this
code
however
must
be
picked
up
by
the
parent
process
this
requires
responsible
parenting
in
the
form
of
calling
one
of
the
system
calls
usually
after
obtaining
the
child's
sigchld
death
notification
to
collect
the
return
code
a
main
thread
briefly
enters
the
zombie
state
when
it
exits
or
returns
from
in
the
hopes
of
being
put
out
of
its
misery
by
its
parent
if
the
parent
fails
to
live
up
to
its
obligations
however
by
ignoring
the
signal
or
forgetting
after
as
some
programmers
do
the
child
is
condemned
to
a
walking
dead
state
fortunately
un
x
zombies
are
quite
benign
and
don't
actually
consume
any
resources
memory
cpu
or
other
aside
from
a
process
table
entry
the
zombies
pd
also
find
peace
when
their
recalcitrant
parent
dies
or
is
killed
leading
to
an
adoption
by
pid
1
which
is
always
happy
to
call
and
provide
requiem
the
choice
of
whether
to
enter
which
still
accepts
signals
or
which
pends
signals
is
left
up
to
the
system
call
or
more
accurately
the
driver
in
charge
of
servicing
said
call
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
high
level
memory
statistics
the
proc
pid
status
entry
also
offers
valuable
high
level
insights
into
process
memory
utilization
note
here
we
use
process
rather
than
thread
because
resources
are
handled
at
the
process
not
thread
level
the
various
statistics
are
shown
in
table
7
1
table
7
1
high
level
memory
statistics
in
proc
pid
status
metric
meaning
vmpeak
virtual
memory
high
water
mark
the
highest
value
obtained
by
vmsize
over
the
lifetime
of
this
process
vmsize
virtual
memory
size
at
the
present
moment
vmlck
memory
locked
by
mlock
2
apis
for
most
applications
this
is
0
vmpin
pinned
memory
for
most
applications
this
is
0
vmhwm
resident
memory
footprint
high
water
mark
the
highest
value
obtained
by
vmrss
over
the
lifetime
of
this
process
vmrss
resident
memory
footprint
at
the
present
moment
vmdata
size
of
data
segment
this
is
the
size
of
the
process
heap
memory
vmstk
size
of
process
thread
stacks
vmexe
size
of
executable
vmlib
memory
used
by
shared
library
so
files
vmpte
memory
used
by
page
table
entries
vmswap
memory
used
by
process
in
swap
in
android
no
swap
ergo
always
0
unless
using
swap
to
zram
looking
at
the
high
level
statistics
can
often
provide
a
quick
diagnosis
as
to
memory
hogging
problems
particularly
high
levels
of
to
gain
more
insights
into
memory
problems
however
we
need
to
consider
the
more
fine
grained
statistics
of
proc
smaps
and
memory
management
in
general
kdswhu
9
7kurxjk
d
lqx
hqv
user
mode
memory
management
programmers
don't
normally
pay
attention
to
memory
it's
a
given
that
each
process
gets
its
own
address
space
wherein
it
can
allocate
memory
freely
according
to
need
and
be
assured
that
the
kernel
will
handle
all
the
minutiae
the
address
space
is
private
that
is
belonging
only
to
this
process
and
virtual
i.e
abstracted
from
the
actual
ram
by
the
kernel
and
memory
management
unit
in
practice
however
memory
is
one
of
the
most
critical
bottlenecks
an
application
can
face
improper
memory
management
not
only
has
an
adverse
effect
on
the
mismanaging
process
but
also
on
the
entire
system
the
effect
is
further
exacerbated
on
android
whereas
on
linux
memory
allocations
which
would
deplete
the
ram
could
be
backed
by
swap
leading
to
excessive
swapping
and
performance
degradation
but
still
being
satisfied
android
has
no
swap
and
as
a
consequence
it's
simply
not
possible
to
deplete
the
ram
without
triggering
a
global
out
of
memory
condition
at
that
point
the
only
way
to
recover
ram
would
involve
killing
a
victim
process
to
recover
its
ram
android
does
a
remarkable
job
of
optimizing
the
available
memory
to
compensate
for
the
lack
of
swap
the
very
design
of
the
dalvik
virtual
machine
emphasized
sharing
as
much
virtual
memory
as
possible
indeed
multiple
instances
of
the
traditional
java
vm
such
as
that
of
sun's
j2me
simply
could
not
be
satisfied
without
100
mb
of
ram
per
instance
dalvik
vms
instances
by
contrast
are
nearly
all
shareable
resulting
in
a
fairly
low
memory
footprint
for
individual
apps
virtual
memory
classification
and
lifecycle
it's
tempting
to
think
that
all
virtual
memory
is
the
same
but
that
is
far
from
true
virtual
memory
can
be
classified
by
no
less
than
four
types
which
impact
its
usage
and
even
more
importantly
its
release
pages
have
their
own
lifecycle
depicted
in
the
following
figure
figure
7
2
the
page
lifecycle
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
named
mmapped
vs
anonymous
the
first
classification
of
a
memory
page
denotes
its
source
mapped
pages
are
pages
taken
from
files
on
the
storage
disk
flash
or
network
file
system
the
pages
are
loaded
from
a
file
via
the
kernel's
page
cache
contiguously
into
the
process
virtual
memory
the
file
name
serves
as
a
name
for
the
memory
itself
which
is
why
mapped
pages
are
often
also
referred
to
as
named
memory
by
contrast
some
memory
is
not
file
backed
and
is
created
ad
hoc
for
the
process
immediate
need
this
includes
memory
used
by
the
stack
or
the
heap
when
the
program
sets
up
a
stack
frame
or
calls
this
memory
has
no
backing
in
a
file
and
therefore
has
no
name
which
is
why
it
is
often
referred
to
as
anonymous
memory
the
maps
per
process
proc
entry
will
show
you
all
memory
mappings
named
mappings
are
easy
to
see
because
the
device
and
inode
number
along
with
the
corresponding
filename
are
clearly
listed
anonymous
file
mappings
have
a
no
numbers
but
special
anonymous
mappings
such
as
the
stack
or
heap
are
clearly
shown
dirty
vs
clean
once
a
page
is
loaded
into
memory
it
may
remain
unaltered
used
as
read
only
memory
or
it
may
be
modified
by
the
process
for
whatever
reason
unaltered
memory
is
referred
to
as
clean
memory
whereas
modifying
memory
makes
it
dirty
this
distinction
is
more
than
just
cleanliness
the
system
needs
to
know
if
a
page
is
dirty
or
clean
for
several
reasons
including
knowing
what
to
do
when
the
page
has
spent
too
much
time
in
memory
and
how
it
affects
sharing
which
brings
us
to
the
next
classifications
active
referenced
vs
inactive
virtual
memory
pages
when
mapped
to
ram
have
an
age
the
kernel
and
mmu
work
together
to
maintain
a
reference
mechanism
tracking
the
least
recently
used
lru
pages
when
a
page
is
accessed
it
is
immediately
marked
as
active
if
left
unused
for
more
than
a
given
period
the
status
is
changed
to
inactive
the
activity
indication
is
important
for
purposes
of
purging
and
writeback
purging
refers
to
the
process
of
discarding
a
page
when
it
is
no
longer
required
if
the
page
is
both
inactive
and
clean
it
implies
that
it
has
either
a
zeroed
page
or
it
has
been
backed
up
to
storage
in
either
case
it
can
be
rid
of
immediately
to
make
room
for
another
process
virtual
memory
paging
request
writeback
refers
to
the
process
of
taking
dirty
pages
and
writing
them
back
to
storage
commonly
the
files
whence
they
came
but
in
the
case
of
anonymous
memory
to
swap
mapped
pages
are
especially
important
to
write
back
within
reasonable
time
because
the
system
could
face
power
lrss
or
a
crash
unpredictably
mapped
pages
not
written
will
result
in
data
loss
the
kernel
therefore
maintains
page
expiration
paramhters
in
proc
sys
vm
anonymous
pages
are
written
to
swap
compressed
ram
in
android
systems
which
support
it
if
there's
no
swap
or
compressed
ram
to
write
back
to
the
system
faces
an
out
of
memory
condition
as
we
describe
later
private
vs
shared
memory
that
is
unique
to
the
process
is
considered
private
this
implies
that
only
the
process
has
access
to
the
memory
page
and
no
other
process
can
physically
access
the
memory
normally
this
is
when
a
process
requests
a
file
mapping
using
with
the
flag
or
more
commonly
allocates
anonymous
memory
using
or
memory
can
also
be
shared
in
between
two
or
more
processes
this
is
usually
the
result
of
a
deliberate
sharing
done
by
the
programmer
using
memory
sharing
calls
such
as
with
the
flag
or
other
mechanisms
such
as
system
v
apis
or
in
android
this
is
known
as
because
the
process
specifically
tells
the
kernel
i
want
this
memory
to
be
shareable
with
others
kdswhu
9
7kurxjk
d
lqx
hqv
shared
memory
may
be
mapped
in
different
virtual
addresses
in
process
a
and
process
b
but
both
will
eventually
get
to
the
same
physical
page
this
means
that
there
is
only
one
physical
copy
of
shared
memory
in
the
system
after
all
why
waste
two
ram
pages
with
exactly
the
same
content
this
also
has
the
upside
of
relieving
the
kernel
from
having
to
maintain
the
sharing
by
updating
multiple
copies
of
memory
on
change
if
there's
only
one
copy
mapped
to
all
processes
any
change
in
that
copy
is
instantly
reflected
among
all
processes
things
get
a
little
bit
more
complicated
sometimes
a
process
may
request
private
memory
but
the
system
may
decide
to
share
it
anyway
without
informing
the
process
in
what's
known
as
implicit
sharing
examples
of
this
abound
in
fact
most
memory
is
implicitly
shared
unless
otherwise
stated
for
example
consider
libraries
and
frameworks
each
process
certainly
needs
a
copy
of
them
but
the
vast
majority
of
the
processes
use
the
copies
verbatim
not
making
any
changes
library
and
framework
code
for
example
is
mapped
read
only
and
therefore
by
definition
cannot
change
it
doesn't
make
sense
then
to
map
individual
copies
of
libraries
especially
commonly
used
ones
like
bionic
when
all
copies
are
the
same
in
these
cases
even
though
the
process
may
request
the
kernel
basically
says
sure
sure
but
performs
sharing
anyway
outright
lying
to
the
process
which
remains
entirely
oblivious
to
maintain
this
elaborate
ruse
the
kernel
does
require
a
little
bit
more
overhead
if
memory
is
implicitly
shared
and
one
of
the
parties
tries
to
modify
it
anyway
the
kernel
will
have
to
allow
that
party
to
modify
the
memory
without
affecting
any
of
the
others
this
is
when
the
kernel
employs
copy
on
write
which
involves
intercepting
the
write
attempt
by
a
page
fault
then
creating
a
new
copy
which
can
be
written
to
and
remapping
that
copy
to
the
process
virtual
memory
instead
of
the
original
page
which
is
left
unmodified
and
mapped
to
all
other
parties
address
space
experiment
examining
address
space
mappings
through
proc
pid
maps
the
per
process
procfs
maps
entry
provides
a
full
layout
of
the
process
address
space
enabling
you
to
quickly
determine
which
files
have
been
mapped
alongside
the
anonymous
memory
regions
output
7
9
demonstrates
the
entry
for
the
shell
on
a
64
bit
system
with
annotations
output
7
9
examining
a
process
address
space
e.g
the
shell
through
proc
pid
maps
you
can
see
even
more
detail
by
examining
the
smaps
per
process
entry
this
provides
the
same
information
as
maps
did
but
with
the
additional
breakdown
by
classification
for
every
region
but
that
will
be
demonstrated
shortly
in
the
next
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
to
view
memory
statistics
on
a
system
wide
level
you
can
consult
the
proc
meminfo
file
the
file
used
by
utilities
like
top
and
vm_stat
uses
the
same
nomenclature
and
classifications
just
defined
output
7
10
examining
system
wide
memory
utilization
with
prc
meminfo
memory
metrics
to
calculate
memory
statistics
one
has
to
take
into
account
quite
a
few
factors
such
as
whether
or
not
memory
is
resident
shared
and
other
parameters
we
can
start
off
with
the
following
simple
formula
in
plain
english
this
means
that
the
virtual
memory
of
a
process
may
be
classified
into
four
disjoint
categories
vmrss
the
resident
set
size
are
those
pages
of
virtual
memory
which
are
presently
backed
by
physical
ram
pages
this
may
be
because
they
have
been
recently
active
or
in
some
cases
because
the
process
or
kernel
requires
them
to
be
locked
in
memory
the
resident
memory
may
further
be
subclassified
as
unique
private
to
this
process
or
shared
in
between
one
or
more
processes
vmfilemapped
pages
which
were
retrieved
from
files
by
means
of
the
system
call
may
be
written
back
to
the
files
at
any
time
to
free
memory
in
fact
in
most
cases
if
the
pages
remain
clean
unmodified
they
can
simply
be
discarded
as
if
need
arises
they
can
always
be
reloaded
from
the
files
which
are
still
on
flash
disk
the
size
of
pages
in
this
category
is
not
directly
reported
in
proc
pid
status
but
can
be
figured
out
from
proc
smaps
and
on
a
system
wide
level
from
proc
meminfo
vmswap
pages
which
resulted
from
memory
allocation
i.e
or
similar
do
not
have
any
file
backing
these
are
also
known
as
anonymous
pages
since
they
have
no
name
read
filename
to
back
them
up
it
follows
that
there
is
no
way
to
write
them
back
out
in
linux
swap
space
comes
to
the
rescue
as
a
portion
of
storage
set
aside
to
back
anonymous
pages
in
android
however
there
is
no
swap
this
value
is
therefore
almost
always
0
unless
the
system
swaps
to
compressed
ram
zram
kdswhu
9
7kurxjk
d
lqx
hqv
vmlazy
programmers
are
a
greedy
lot
often
allocating
far
more
memory
than
they
actually
need
the
kernel
takes
a
lazy
approach
to
allocation
preferring
to
set
aside
pages
on
paper
until
they
are
actually
required
or
written
to
these
pages
are
allocated
in
the
process
page
table
entries
visible
in
proc
pid
status
as
but
the
actual
allocation
is
deferred
until
a
pointer
to
the
page
is
actually
dereferenced
the
kernel
then
experiences
a
page
fault
from
the
mmu
which
reports
correctly
that
the
page
does
not
exist
the
kernel
then
proceeds
to
actually
allocate
the
page
using
lazy
allocation
saves
a
great
deal
of
memory
but
does
impact
performance
marginally
a
worse
scenario
occurs
when
the
page
fault
cannot
be
satisfied
due
to
no
available
physical
pages
and
no
way
to
write
back
any
to
disk
that's
when
an
out
of
memory
oom
condition
occurs
which
we
discuss
later
in
this
chapter
it's
tempting
to
sum
up
vmrss
over
all
processes
in
order
to
calculate
the
overall
ram
footprint
doing
so
however
would
be
wrong
because
some
of
the
resident
memory
of
the
process
may
in
fact
be
shared
with
others
in
which
case
a
simple
summation
would
end
up
overcounting
the
shared
regions
a
more
accurate
measure
is
needed
and
this
is
what
linux
offers
with
the
pss
proportional
set
size
statistic
in
mathematical
speak
pss
would
be
defined
as
if
like
most
non
math
types
you
find
the
equation
a
tad
alarming
or
promised
yourself
to
not
ever
use
sigma
notation
again
this
can
be
put
in
words
like
so
pss
will
count
1k
for
every
1k
of
private
memory
uss
that
is
if
a
process
has
a
private
memory
page
it
counts
in
full
for
purposes
of
calculating
the
pss
footprint
pss
will
only
count
1
n
k
for
every
1k
of
shared
memory
with
n
dependent
on
the
number
of
processes
sharing
this
region
because
there
may
be
more
than
one
regions
we
need
the
sigma
notation
which
basically
says
add
1
n1
for
the
first
region
found
then
add
another
1
n2
for
the
second
region
found
assuming
n2
sharers
etc
this
might
seem
odd
at
first
but
when
you
take
the
sum
of
pss
over
all
processes
in
the
system
mathematical
magic
adds
up
the
shares
in
a
way
that
every
shared
region
is
counted
in
full
and
exactly
once
for
the
purposes
of
determining
the
footprint
if
you
want
a
slight
challenge
you
can
work
out
the
double
sigma
notation
required
to
prove
the
correctness
of
this
claim
fortunately
pss
measurements
prove
far
more
useful
than
the
algebraic
equations
backing
them
and
are
readily
obtainable
with
virtually
no
need
for
math
directly
from
the
proc
smaps
file
this
is
best
exemplified
in
the
following
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
linuxlens.html
oom
experiment
observing
rss
uss
and
pss
through
proc
pid
smaps
the
per
process
smaps
entry
breaks
down
memory
regions
from
the
maps
entry
and
provides
detailed
information
on
each
for
this
experiment
find
a
binary
that
isn't
concurrently
executing
as
another
process
and
doesn't
terminate
quickly
a
good
candidate
for
that
is
which
is
an
actual
binary
not
a
tool
and
will
run
indefinitely
start
with
some
address
it
doesn't
even
matter
if
the
address
is
reachable
what
matters
is
that
will
run
if
you
choose
another
binary
that's
fine
too
the
choice
of
binary
is
entirely
inconsequential
for
this
experiment
what
matters
is
that
the
binary
loads
and
creates
a
process
instance
which
you
can
then
suspend
once
the
binary
is
running
possibly
paused
for
input
hit
to
suspend
it
and
go
back
to
a
prompt
or
leave
it
running
in
the
background
then
inspect
the
first
10
or
so
lines
of
its
smaps
entry
using
it
will
look
something
like
this
output
7
11
a
examining
the
uss
rss
and
pss
of
a
single
instance
of
a
given
binary
what
do
we
see
in
the
output
the
first
memory
region
is
loaded
from
usr
bin
ping
on
disk
no
surprise
here
the
region
is
readable
executable
and
seemingly
private
it
was
loaded
from
device
inode
463
the
vmsize
of
this
region
is
36kb
of
which
4k
have
been
immediately
freed
because
the
rss
is
32k
this
amounts
to
a
portion
of
the
elf
header
which
has
no
practical
use
in
memory
during
runtime
the
32k
of
rss
are
all
private
and
clean
private
implies
unique
to
this
process
i.e
uss
and
clean
implies
that
they
have
not
been
modified
since
their
loading
all
32k
are
also
recently
active
referenced
which
again
is
no
surprise
since
ping
is
executing
the
pages
are
not
anonymous
because
they
are
mapped
to
a
file
consequentially
the
pss
is
32k
with
no
shared
memory
every
4k
of
uss
map
to
4k
of
pss
so
far
hopefully
so
good
but
what
happens
when
we
start
another
instance
of
or
our
process
doing
so
we
then
inspect
the
smaps
entry
of
the
first
instance
not
the
second
and
see
that
it
has
changed
kdswhu
9
7kurxjk
d
lqx
hqv
experiment
observing
rss
uss
and
pss
through
proc
pid
smaps
cont
output
7
11
b
examining
the
uss
rss
and
pss
of
the
first
of
two
concurrent
instances
of
a
given
binary
comparing
the
two
outputs
you
can
see
that
most
metrics
in
the
original
process
have
not
changed
the
vmsize
is
still
36k
with
a
32k
rss
the
rss
however
is
now
all
shared
between
the
two
instances
of
the
binary
and
therefore
the
pss
has
dropped
by
half
to
16k
running
this
example
with
another
instance
of
the
process
will
bring
down
the
pss
to
10k
technically
10.6k
but
rounded
down
and
with
four
instances
to
8k
32k
divided
cleanly
by
four
killing
instances
reduces
the
number
of
sharers
and
brings
up
the
pss
value
note
that
throughout
the
example
the
region
remained
seemingly
private
in
both
outputs
this
is
obviously
false
since
smaps
clearly
shows
the
region
becomes
shared
this
paradox
is
resolved
by
explaining
p
not
as
private
but
as
i.e
the
argument
to
when
mapping
the
region
this
is
the
same
ruse
that
was
previously
discussed
when
explaining
private
shared
memory
stated
otherwise
the
process
mapped
this
region
as
private
and
the
operating
system
plays
along
but
if
another
process
maps
this
same
region
the
kernel
reserves
the
right
to
make
this
implicitly
shared
between
the
processes
so
long
as
neither
process
actually
writes
to
dirties
the
region
if
a
write
occurs
the
writing
process
triggers
a
copy
on
write
fault
which
forces
the
kernel
to
actually
allocate
another
copy
of
the
page
s
written
to
so
as
not
to
violate
the
existing
copy
this
is
in
contrast
to
s
in
the
permission
flags
which
means
explicitly
shared
i.e
in
the
arguments
denoting
that
the
region
can
be
dirtied
and
still
remain
shared
as
a
single
copy
the
experiment
hopefully
served
as
a
simple
example
of
how
pss
is
calculated
simple
because
this
was
a
simple
case
where
all
memory
was
shared
thereby
reducing
uss
to
zero
and
making
the
pss
calculation
straightforward
other
regions
may
be
mixed
both
private
and
shared
which
makes
pss
calculation
a
bit
more
challenging
but
fortunately
smaps
does
that
automatically
if
you're
not
a
fan
of
parsing
proc
smaps
manually
there's
a
tool
for
that
two
in
fact
this
is
shown
in
the
next
experiment
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
observing
rss
uss
and
pss
through
procrank
and
librank
the
aosp
provides
two
useful
tools
to
show
memory
statistics
procrank
and
librank
these
are
not
present
in
most
production
devices
but
it's
a
simple
enough
matter
to
copy
them
from
the
emulator
image
to
the
device
along
with
their
dependency
system
lib
libpagemap.so
this
is
shown
in
the
following
output
output
7
12
moving
binaries
from
the
emulator
to
a
real
device
on
the
device
you'll
need
to
make
the
binaries
executable
by
using
and
then
execute
them
because
the
library
dependency
is
also
in
data
local
tmp
and
libraries
are
searched
for
in
system
lib
64
you'll
need
to
alter
the
library
load
path
on
a
rooted
device
this
is
not
necessary
if
you
drop
the
library
dependency
in
system
lib
output
7
13
moving
binaries
from
the
emulator
to
a
real
device
once
you
have
procrank
and
librank
copied
or
if
you
just
run
them
on
the
emulator
you
can
turn
to
analyzing
their
output
both
tools
operate
by
iterating
over
the
per
process
smaps
statistics
newer
versions
work
with
the
pagemap
entry
but
they
differ
in
how
they
output
the
statistics
procrank
does
so
by
sorting
processes
in
descending
order
of
memory
usage
while
librank
sorts
regions
of
memory
by
the
processes
using
them
there's
a
lot
to
be
learned
from
the
output
about
memory
utilization
and
optimization
in
android
starting
with
pagemap
output
7
14
the
output
of
procrank
from
the
l
emulator
kdswhu
9
7kurxjk
d
lqx
hqv
experiment
observing
rss
uss
and
pss
through
procrank
cont
as
the
output
shows
processes
are
ranked
by
descending
order
of
vss
as
per
the
default
you
can
also
sort
by
ss
ss
or
ss
more
advanced
options
will
show
only
cached
or
non
cached
pages
try
for
more
options
in
the
output
however
something
stands
out
very
quickly
though
vss
sizes
are
humongous
565m
for
the
launcher
really
the
actual
rss
sizes
are
small
indicating
plenty
of
discarded
mappings
and
the
pss
sizes
are
smaller
still
as
you
can
see
the
average
unique
footprint
of
apps
is
no
more
than
a
few
mb
about
85
90
of
the
rss
of
the
average
app
is
all
shared
reducing
its
pss
dramatically
this
shareability
is
owed
to
the
structure
of
zygote
and
the
dalvik
vm
art
included
which
maximize
shared
memory
in
ways
java
never
could
but
still
not
as
efficiently
as
ios
some
would
argue
you
can
work
back
to
see
how
much
memory
is
shared
by
subtracting
the
uss
measure
from
the
rss
subtracting
the
uss
from
the
pss
will
give
you
the
weighted
average
of
the
shared
regions
and
dividing
the
shared
memory
size
by
this
amount
will
give
you
a
rough
idea
of
how
many
processes
are
sharing
the
same
regions
this
is
a
rough
idea
only
because
summing
up
pss
loses
some
granularity
different
regions
likely
have
a
different
number
of
sharers
the
tool's
output
is
slightly
different
as
it
is
sorted
by
memory
region
otherwise
however
the
terminology
remains
the
same
the
following
output
demonstrates
the
usage
of
the
boot.oat
shared
region
which
holds
precompiled
framework
classes
in
art
shows
yet
again
the
efficiency
of
sharing
the
vss
associated
with
the
boot.oat
is
some
48mb
in
practice
however
less
than
half
is
resident
and
in
most
processes
unique
memory
footprint
of
the
oat
is
in
the
low
kb
newer
versions
of
android
make
use
of
an
even
more
clever
forms
of
sharing
through
the
linux
kernel's
kernel
samepage
merging
ksm
mechanism
this
features
lets
the
kernel
auto
detect
identical
physical
pages
in
memory
by
comparing
hashes
even
if
they
are
not
memory
mapped
if
an
identity
is
detected
the
pages
can
be
merged
subject
to
the
usual
copy
on
write
restrictions
ksm
has
been
a
feature
in
the
linux
kernel
as
of
2.6.27
or
so
but
has
only
recently
entered
android
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
output
7
15
the
output
of
librank
demonstrating
sharing
on
the
art
precompiled
classes
root
generic
librank
rss
pss
uss
name
pid
rsstot
vss
27179k
data
dalvik
cache
arm
system
framework
boot.oat
6468k
system_server
354
3982k
3802k
3164k
1933k
1302k
48556k
19576k
48556k
13488k
48556k
13984k
48556k
14800k
48556k
11880k
48556k
10544k
958k
9268k48556k
861k
9048k
826k
8200k
759k
8628k
655k
7960k
7280k
588k
7220k
566k
6772k
474k
6132k
429k
5796k
405k
zygote
66
com.android.phone
538
com.android.systemui
709
com.android.launcher
581
com.android.inputmethod.latin
500
android.process.media
766
com.android.email
997
com.android.server.telecom
532
com.android.calendar
955
com.android.providers.calendar
843
com.android.deskclock
978
com.android.browser
1077
com.android.exchange
1037
com.android.dialer
1061
com.android.sharedstoragebackup
1096
3268k
2112k
2192k
744k
324k
160k
104k
64k
96k
20k
12k
24k
20k
0k
0k
4k
48556k
48556k
48556k
48556k
48556k
48556k
48556k
48556k
48556k
out
of
memory
conditions
despite
all
the
extensive
memory
sharing
in
android
along
with
tricks
like
ksm
or
zram
lack
of
real
swap
space
is
an
inherent
problem
android
is
not
at
fault
here
swap
and
flash
simply
do
not
go
well
together
due
to
flash
memory's
limited
program
erase
p
e
cycles
as
a
consequence
running
out
of
memory
at
any
given
time
is
a
clear
and
present
danger
the
linux
kernel
has
long
had
a
mechanism
to
deal
with
memory
shortage
this
mechanism
called
oom
out
of
memory
is
triggered
when
a
memory
request
cannot
be
satisified
in
linux
this
happens
rarely
if
the
system
is
low
on
ram
there
is
usually
ample
swap
space
to
fall
on
it's
only
when
the
system
is
both
out
of
ram
and
swap
space
that
oom
is
triggered
oom
isn't
a
thread
it's
implemented
as
a
code
path
following
the
page
fault
which
occurs
the
code
looks
through
the
list
of
processes
and
attempts
to
find
the
most
suitable
candidate
whose
sacrifice
will
result
in
the
best
memory
gain
for
the
system
all
processes
are
candidates
on
this
death
row
sorted
by
their
a
heuristically
devised
score
which
evolved
as
did
the
kernel
this
score
is
visible
in
the
per
process
proc
pid
oom_score
as
a
read
only
pseudofile
the
problem
with
the
heuristic
is
that
as
will
all
heuristics
it
doesn't
always
reliably
work
often
times
innocent
processes
are
sacrificed
just
for
being
with
the
wrong
score
at
the
wrong
time
execution
is
imminent
and
swift
with
no
saving
throw
essentially
a
and
there
is
nothing
the
victim
can
do
about
it
it
is
for
this
reason
that
the
android
application
lifecycle
exists
with
the
perpetual
fear
of
untimely
death
applications
are
not
guaranteed
persistence
in
any
way
and
are
instead
given
callbacks
to
save
their
state
as
an
opaque
with
the
only
promise
that
if
they
are
killed
they
will
be
reincarnated
with
that
bundle
an
application
has
no
way
to
predict
when
and
even
if
it
may
be
terminated
as
opposed
to
ios's
jetsam
a
mechanism
designed
for
a
similar
functionality
the
application
doesn't
even
leave
a
tombstone
though
some
detail
to
the
kernel
log
is
saved
in
an
effort
to
bring
a
bit
more
determinism
to
the
heuristic
linux
offered
a
method
to
adjust
the
score
from
user
space
first
as
proc
pid
oom_adj
and
in
later
kernels
as
proc
pid
oom_score_adj
these
files
enable
a
user
space
process
to
add
a
modifier
to
the
score
a
negative
modifier
to
reduce
the
score
thus
making
the
process
less
killable
or
a
positive
modifier
to
increase
the
score
effectively
giving
the
process
suicidal
tendencies
android's
system
processes
use
this
mechanism
to
make
themselves
unkillable
init
and
its
cohorts
from
the
various
rc
files
give
them
an
of
16
or
17
which
completely
disables
oom
for
the
task
in
newer
kernels
setting
the
to
1000
achieves
a
similar
result
which
effectively
makes
their
score
close
to
if
not
0
in
the
wrong
hands
this
could
have
also
been
abused
by
apps
after
all
who
wouldn't
resist
the
temptation
for
immortality
but
android's
automatically
resets
the
score
adjustment
along
various
stages
of
the
application's
lifecycle
as
we
discussed
in
volume
ii
as
of
android
l
the
relies
on
the
discussed
in
chapter
5
because
the
adjustment
files
are
owned
e
and
writable
to
root
only
android
takes
another
precautionary
measure
in
the
form
of
the
lowmemorykiller
lmk
this
is
an
androidism
which
enhances
oom
by
preemptively
killing
processes
before
a
real
oom
condition
is
triggered
in
previous
android
versions
init
would
set
the
module's
parameters
via
sysfs
on
startup
with
l
init
merely
ensures
file
permissions
on
the
sysfs
pseudofiles
leaving
the
task
to
lmkd
instead
kdswhu
9
7kurxjk
d
lqx
hqv
file
users
morpheus
documents
android
book
services.html
lmkd
experiment
oom
memory
adjustments
in
action
you
can
observe
the
oom
score
adjustments
in
real
time
by
examining
the
procfs
entries
during
application
lifecycle
for
this
experiment
open
an
adb
shell
while
using
an
app
for
example
if
you're
using
the
chrome
web
browser
you'll
see
output
7
16
a
viewing
an
active
application's
oom
scores
moving
the
application
to
the
background
by
simply
pressing
the
home
button
will
automatically
reflect
in
oom
the
oom
ad
increases
and
the
score
shoots
up
accordin
ly
output
7
16
b
viewing
an
active
application's
oom
scores
in
android
l
you
can
also
attach
a
trace
to
during
the
application
lifecycle
events
to
see
incoming
messages
from
to
in
order
to
adjust
the
scores
this
was
shown
in
the
experiment
in
chapter
5
specifically
output
5
6
suspending
by
will
prevent
any
oom
modifications
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
tracing
system
calls
virtually
any
meaningful
operation
performed
by
a
user
mode
thread
requires
some
kernel
involvement
whether
it
is
dealing
with
a
file
opening
a
socket
or
handling
any
type
of
resource
outside
one's
own
previously
allocated
virtual
memory
a
user
mode
thread
must
request
that
service
from
the
kernel
by
means
of
a
system
call
system
calls
require
the
user
mode
process
to
first
traverse
into
kernel
mode
the
method
of
doing
so
differs
with
each
architecture
but
always
involves
a
special
machine
instruction
arm's
a.k.a
or
intel's
or
these
instructions
set
the
processor
mode
to
privileged
supervisor
mode
and
are
setup
by
the
kernel
upon
boot
to
transfer
control
to
a
predefined
kernel
entry
point
all
system
calls
are
thus
funneled
to
one
function
the
system
call
number
passed
in
arm's
or
intel's
is
used
to
redirect
execution
to
the
specific
system
call
implementation
by
consulting
an
internal
table
given
all
the
above
it
should
be
clear
why
system
calls
deserve
special
focus
when
it
comes
to
debugging
and
tracing
processes
most
of
the
time
the
internal
operations
inside
a
process
changing
this
or
that
variable
aren't
of
too
much
interest
if
only
because
they
are
so
plentiful
and
hard
to
trace
operations
on
files
or
sockets
however
are
especially
interesting
and
tracing
system
calls
provides
a
simple
way
to
trace
these
operations
among
others
the
tool
toolbox's
tool
however
crude
does
offer
two
valuable
fields
pertaining
to
system
calls
and
the
first
denotes
the
wait
channel
which
is
the
kernel
address
the
entry
is
presently
in
or
1
0xfffffff
if
this
cannot
be
determined
recall
each
line
in
refers
to
a
kernel
thread
or
the
main
thread
of
a
process
unless
is
used
the
second
is
the
return
address
in
user
space
where
execution
resumes
after
the
system
call
resolving
the
kernel
address
requires
some
manual
work
as
shown
in
the
following
experiment
experiment
manually
resolving
s
value
when
faced
with
a
address
or
any
kernel
address
you
can
follow
the
simple
method
shown
here
to
use
proc
kallsyms
and
resolve
it
to
a
more
readable
symbol
you
start
at
the
exact
address
which
never
produces
a
match
since
entries
in
kallsyms
are
only
for
entry
points
and
the
is
inside
a
function
you
then
go
back
by
removing
the
least
significant
digits
taking
advantage
of
s
ability
to
match
the
prefix
at
some
point
will
match
one
or
more
addresses
and
the
closest
one
to
the
one
checked
is
the
name
of
the
function
the
kernel
is
in
output
7
17
resolving
a
kernel
address
using
proc
kallsyms
one
caveat
to
keep
in
mind
make
sure
to
find
the
closest
symbol
before
and
not
after
the
address
you're
looking
for
sometimes
like
in
this
example
the
closest
symbol
may
wrap
and
other
times
might
return
matches
which
are
after
your
symbol
and
therefore
incorrect
kdswhu
9
7kurxjk
d
lqx
hqv
the
toybox
in
android
m's
preview
automatically
maps
the
wcha
address
to
a
symbol
by
lookin
at
ro
ha
as
shown
next
the
experiment
is
ust
as
relevant
however
since
it
shows
the
techni
ue
for
resolvin
kernel
addresses
wchan
and
syscall
the
proc
filesystem
also
offers
system
call
tracing
mechanisms
the
wchan
per
thread
entry
like
the
output
shows
the
location
in
kernel
mode
where
a
thread
is
sleeping
or
0
if
the
thread
is
presently
active
but
also
resolves
it
to
the
closest
symbol
saving
you
the
hassle
of
the
previous
experiment
what
more
it
works
even
if
the
file
restricts
addresses
in
some
kernels
the
syscall
per
thread
entry
offers
even
more
detail
it
captures
the
system
call
number
along
with
arguments
that
the
thread
is
in
at
the
time
of
polling
the
format
of
this
is
demonstrated
through
output
7
18
output
7
18
the
syscall
and
wchan
procfs
entries
you
can
resolve
the
program_counter
value
which
is
also
the
value
quoted
by
s
using
the
method
shown
in
the
previous
experiment
a
caveat
with
system
call
numbers
however
is
that
they
are
not
guaranteed
to
remain
constant
across
architectures
the
system
call
numbers
of
intel
and
arm
are
understandably
different
but
more
surprisingly
those
of
32
bit
and
64
bit
are
sometimes
different
you
will
need
the
specific
system
call
file
for
your
architecture
which
you
can
find
in
the
android
ndk
under
platforms
android
apiversion
arch
arch
usr
include
asm
unistd.h
replacing
arch
with
arm
arm64
x86
or
x86_64
fortunately
kernels
with
syscall
procfs
entry
normally
have
wchan
as
well
so
you
can
resolve
the
syscall
number
via
wchan
as
demonstrated
above
most
kernels
also
have
a
stack
entry
which
details
the
kernel
stack
the
tool
the
methods
shown
so
far
all
used
polling
i.e
you
could
get
an
exact
reading
on
a
system
call
but
were
responsible
for
initiating
the
reading
and
could
only
capture
one
result
at
a
time
this
is
useful
in
case
of
diagnosing
a
hanging
or
unrespnsive
process
most
system
call
tracing
however
is
best
performed
as
an
on
going
operation
attaching
to
the
process
as
unobtrusively
as
possible
and
getting
notifications
on
every
system
call
it
performs
this
is
where
comes
into
play
this
powerful
binary
which
has
been
used
several
times
by
now
in
this
book
to
trace
and
explain
the
internals
of
processes
is
utterly
invaluable
as
a
tracing
tool
a
complete
example
of
its
usage
would
likely
take
up
a
chapter
by
itself
but
table
7
2
summarizes
some
of
the
more
useful
switches
table
7
2
the
more
useful
switches
of
switch
use
print
instruction
pointer
at
time
of
syscall
print
timestamp
with
without
usecs
follow
the
clone
syscall
auto
attaching
to
child
processes
threads
file
save
output
to
file
verbose
mode
for
various
syscall
arguments
is
exceptionally
good
at
understanding
the
system
call
arguments
even
more
so
when
is
used
at
the
time
of
writing
there
is
no
android
aware
version
of
the
tool
nor
is
there
an
arm64
compatible
version
the
tool
from
the
book's
companion
website
provides
an
clone
which
addresses
both
these
issues
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
newandroidbook.com
files
jtrace.tgz
summary
this
chapter
focused
on
the
usage
of
the
proc
file
system
in
particular
the
per
process
entries
in
proc
pid
and
per
thread
entries
in
proc
pid
task
tid
and
the
plethora
of
information
they
provide
to
allow
for
powerful
native
level
debugging
and
tracing
of
processes
the
methods
demonstrateg
apply
to
mainline
linux
in
the
same
ways
because
procfs
is
an
integral
part
of
the
linux
kernel
references
and
files
discussed
in
this
chapter
reference
provides
proc
pid
fd
proc
pid
fdinfo
information
about
open
file
descriptors
for
process
proc
pid
maps
address
space
of
process
as
list
of
mapped
and
anonymous
regions
proc
pid
smaps
as
per
proc
pid
maps
but
with
per
region
statistics
proc
pid
status
information
from
process
or
thread's
control
block
kernel's
1
www.kernel.org
doc
documentation
filesystems
proc.txt
documentation
about
the
procfs
filesystem
entries
kdswhu
9
7kurxjk
d
lqx
hqv
https
www.kernel.org
doc
documentation
filesystems
proc.txt
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
viii
android
security
as
with
other
operational
aspects
android
relies
on
the
facilities
of
linux
for
its
basic
security
needs
for
most
apps
however
an
additional
layer
of
security
is
enforced
by
the
dalvik
virtual
machine
android
security
is
therefore
an
amalgam
of
the
two
approaches
vm
and
native
which
allows
for
defense
in
depth
this
chapter
starts
by
providing
a
brief
insight
into
threat
modeling
a
practice
taken
by
security
experts
to
try
and
analyze
the
possible
attack
vectors
and
threats
which
may
compromise
a
device
malicious
apps
and
theft
are
just
two
of
the
possible
threats
considered
as
mobile
security
must
address
all
the
traditional
faults
of
desktop
security
and
then
some
we
continue
by
exploring
the
linux
user
model
and
its
adaptation
to
the
android
landscape
starting
with
the
native
linux
permissions
and
the
clever
usage
of
ids
for
apps
and
group
membership
we
then
proceed
to
highlight
capabilities
an
oft
overlooked
feature
of
linux
used
extensively
in
android
to
work
around
the
inherent
limitation
using
the
almighty
root
uid
in
the
classic
model
next
is
a
discussion
of
selinux
a
mandatory
access
control
mac
framework
introduced
in
4.3
and
enforced
in
4.4
lastly
we
consider
various
protections
against
code
injection
the
bane
of
application
security
at
the
dalvik
level
we
consider
the
simple
yet
effective
permission
model
enforced
by
the
virtual
machine
and
the
package
manager
as
well
as
the
bindings
to
the
linux
level
but
up
to
this
point
both
linux
and
dalvik
can
be
thought
of
as
aspects
of
application
level
security
we
therefore
next
consider
user
level
security
protecting
the
device
against
human
users
by
locking
the
device
no
longer
the
domain
of
simple
pins
and
patterns
device
locking
methods
get
ever
more
innovative
and
have
expanded
to
include
biometrics
as
well
as
of
jb
android
allows
multiple
users
to
coexist
each
with
his
or
her
own
private
data
and
set
of
installed
applications
and
so
the
implementation
of
multiple
users
is
covered
as
well
at
this
point
we
turn
to
a
discussion
of
encryption
on
android
beginning
with
aspects
of
key
management
we
explain
the
inner
workings
of
the
keystore
service
and
the
maintenance
of
cetificates
on
the
device
we
then
touch
on
android's
storage
encryption
feature
introduced
in
honeycomb
and
filesystem
authentication
using
linux's
dm
verity
as
introduced
in
kitkat
last
but
in
no
way
least
is
a
focus
on
device
rooting
without
which
no
discussion
about
security
would
be
complete
rooting
brings
with
it
tremendous
advantages
to
the
power
user
and
is
one
of
the
reasons
android's
popularity
has
exploded
in
hacker
and
modder
circles
but
also
woeful
dire
implications
on
application
and
system
security
the
two
primary
methods
boot
to
root
and
one
click
are
detailed
and
contrasted
file
users
morpheus
documents
android
book
security.html
selinux
file
users
morpheus
documents
android
book
security.html
lockscreen
file
users
morpheus
documents
android
book
security.html
multiuser
file
users
morpheus
documents
android
book
security.html
dataenc
file
users
morpheus
documents
android
book
security.html
diskver
file
users
morpheus
documents
android
book
security.html
rooting
threat
modeling
mobile
security
if
one
considers
the
evolution
of
hacking
a
logical
progression
can
be
seen
at
first
the
main
targets
were
servers
it
was
much
easier
to
hack
into
a
server
a
sitting
duck
in
terms
of
being
always
connected
to
the
internet
than
try
to
hack
into
a
desktop
which
only
sporadically
if
at
all
was
ever
connected
and
even
then
through
a
low
bandwidth
modem
this
changed
with
the
proliferation
of
broadband
connections
and
the
rise
of
local
area
networks
suddenly
millions
of
new
potential
targets
emerged
on
the
internet
as
desktop
machines
the
security
posture
was
off
to
a
much
weaker
start
than
a
server
insecure
defaults
and
the
overly
user
friendly
and
complex
operating
system
that
was
windows
provided
a
ripe
breeding
ground
for
hackers
and
brought
on
waves
of
worms
and
malware
attack
vectors
mobile
devices
while
similar
in
some
respects
to
desktops
have
an
entirely
different
threat
landscape
unlike
the
latter
their
very
mobility
exposes
them
to
far
more
risks
as
they
may
be
accidentally
misplaced
or
deliberately
stolen
this
effectively
negates
the
aspects
of
digital
security
one
could
enforce
on
a
desktop
by
restrictring
access
at
the
lock
and
key
or
keycard
level
opening
up
a
slew
of
attacks
an
adversary
could
try
once
physical
access
to
a
device
is
obtained
but
that
alas
is
only
half
of
it
unlike
desktops
mobile
devices
being
far
more
personal
are
more
likely
to
contain
personal
user
data
which
makes
them
more
lucrative
a
target
for
hacking
the
attack
profile
has
also
changed
rather
than
obtain
full
control
of
the
device
remotely
what
hackers
call
pwning
it
often
suffices
to
just
get
access
to
user
data
and
using
a
likely
always
on
internet
connection
smuggle
it
out
to
a
remote
server
the
rogue
app
the
primary
attack
vector
on
a
mobile
device
is
from
within
that
of
a
rogue
application
users
are
eager
to
expand
the
functionality
of
their
devices
by
installing
more
and
more
apps
but
a
misbehaving
or
deliberately
malicious
app
could
attempt
to
access
the
user's
information
or
even
take
over
phone
functionality
for
example
by
sending
premium
sms
messages
for
outrageous
prices
generally
this
is
classified
as
local
privilege
escalation
as
an
application
is
already
installed
and
running
on
the
local
device
but
with
a
restricted
set
of
privileges
which
is
wishes
to
elevate
to
prevent
this
android
must
treat
all
applications
as
suspect
by
default
applications
are
given
a
minimal
set
of
permissions
but
are
otherwise
restricted
the
minimal
set
however
does
not
include
anything
which
might
be
potentially
sensitive
even
if
it
is
vital
accessing
the
network
for
example
could
be
used
maliciously
to
funnel
out
information
from
the
device
for
this
reason
any
permission
outside
the
minimal
set
must
be
explicitly
requested
by
the
application
in
its
manifest
each
application
is
given
its
own
uid
which
isolates
it
from
others
and
needless
to
say
root
access
for
applications
is
out
of
the
question
android
took
a
step
up
in
application
restrictions
in
jellybean
with
the
introduction
of
selinux
a
mandatory
access
control
framework
which
effectively
sandboxes
all
processes
except
the
very
trusted
ones
in
android
l
the
frameworks
have
also
been
extended
to
support
package
restrictions
that
however
is
not
enough
android
must
also
protect
itself
as
it
is
likely
that
a
malicious
application
could
try
within
the
limited
subset
of
permissions
it
does
have
to
attack
vulnerable
components
of
the
operating
system
which
houses
it
this
is
not
without
precedent
it's
possible
to
exploit
such
vulnerabilities
and
trick
more
privileged
components
of
the
operating
system
particularly
those
running
as
root
to
perform
an
operation
on
behalf
of
the
application
due
to
the
vast
amount
of
code
in
the
android
frameworks
and
even
more
code
in
the
underlying
linux
kernel
this
is
a
serious
threat
most
past
vulnerabilities
have
in
fact
done
just
that
in
order
to
elevate
their
privilege
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
the
rogue
user
it's
hard
to
think
of
the
device
user
as
an
actual
threat
although
ios
certainly
seems
to
do
so
the
potential
of
device
theft
however
makes
it
unclear
as
to
just
who
the
valid
user
is
the
system
must
therefore
be
secure
at
all
times
especially
when
outside
the
user's
reach
the
first
line
of
defense
is
the
lock
screen
which
must
balance
the
need
for
strong
authentication
credentials
with
an
easy
to
use
and
quick
unlock
operation
after
all
you
wouldn't
want
to
type
in
a
20
character
case
sensitive
password
every
time
your
screen
blanks
it
therefore
falls
upon
the
user
to
decide
what
is
acceptable
security
in
choosing
the
authentication
mechanism
as
well
as
the
timeout
to
enforce
it
android
introduced
face
unlock
as
a
method
for
quick
albeit
not
too
safe
unlock
and
in
lollipop
has
followed
ios
with
built
in
support
for
fingerprint
authentication
as
well
lollipop
also
brings
unlocking
via
paired
devices
over
bluetooth
when
the
paired
device
usually
an
android
wear
device
is
near
there
is
also
the
potential
of
a
device
being
stolen
turned
off
and
rebooted
for
this
android
must
ensure
its
boot
process
is
secure
otherwise
someone
could
override
the
boot
loader
and
restart
the
device
in
an
alternate
configuration
which
could
be
less
secure
this
is
why
boot
loaders
are
often
locked
by
default
and
if
unlocked
will
first
efface
the
entire
data
partition
finally
the
user's
data
should
be
encrypted
else
a
sophisticated
attacker
can
simply
pry
it
open
and
access
the
raw
flash
storage
android
offered
encryption
as
early
as
honeycomb
but
once
again
trailed
ios
as
it
only
enabled
it
by
default
beginning
with
lollipop
the
encryption
key
must
not
rest
anywhere
on
the
device
and
be
derived
from
the
user's
unlock
code
for
maximum
usability
remote
code
injection
last
but
not
least
if
all
the
above
weren't
bad
enough
mobile
devices
are
still
subject
to
the
very
same
attack
vector
servers
and
desktops
were
remote
code
injection
the
same
class
of
vulnerabilities
which
plague
desktop
can
also
affect
mobile
devices
as
attackers
seek
to
target
devices
over
the
internet
either
as
random
drive
by
malware
spam
or
malicious
banners
or
through
targetted
attacks
usually
socially
engineered
email
webkit
which
served
as
the
basis
for
android's
browser
and
webviews
has
proven
to
be
an
inexhaustible
font
for
vulnerabilities
these
were
often
carried
out
by
a
combination
of
malforming
html
css
javascript
or
all
of
the
above
google
has
now
moved
to
chrome
as
the
default
browser
but
the
potential
of
a
vulnerability
in
such
a
frequently
used
code
based
is
so
great
that
lollipop
checks
and
automatically
updates
chrome
indepedently
of
the
rest
of
the
os
it's
worth
noting
that
code
injection
can
also
exist
in
the
boot
loader
phase
such
a
vulnerability
could
offer
the
same
effect
as
unlocking
the
bootloader
i.e
booting
into
any
configuration
desired
but
without
effacing
data
and
thereby
compromising
the
user's
data
the
android
approach
to
security
in
security
the
union
of
two
elements
does
not
necessarily
make
them
secure
quite
the
contrary
in
fact
as
it
suffices
that
one
of
the
elements
contains
a
vulnerability
in
order
for
the
entire
system
to
be
compromised
android
has
learned
this
oh
so
well
over
its
relatively
short
existence
as
its
security
has
been
broken
time
and
time
and
time
again
despite
significant
improvements
with
each
version
sometimes
the
vulnerability
lay
in
android
itself
and
other
times
in
the
underlying
linux
it
follows
therefore
that
android
security
must
incorporate
both
worlds
linux
and
its
own
and
combine
them
together
as
efficiently
and
as
securely
as
possible
kdswhu
9
6hfxulw
security
at
the
linux
level
android
builds
a
rich
framework
on
top
of
the
linux
substrate
but
at
its
core
relies
on
linux
for
virtually
all
operations
the
linux
inheritance
also
binds
android
to
use
the
same
security
features
as
those
offered
by
linux
the
permissions
capabilities
selinux
and
other
low
level
security
protections
linux
permissions
the
security
model
of
linux
is
a
direct
port
of
the
standard
un
x
security
model
this
model
which
has
remained
largely
unchanged
since
its
inception
some
40
years
ago
provides
the
following
primitives
every
user
has
a
numeric
user
id
the
actual
user
name
doesn't
matter
though
some
usernames
are
reserved
for
system
users
which
are
designated
the
owners
of
configuration
files
and
directories
two
users
may
share
the
same
user
id
but
this
in
effect
means
that
as
far
as
the
system
is
concerned
this
represents
a
single
user
with
two
username
password
combinations
every
user
has
a
numeric
primary
group
id
much
like
the
username
the
group
name
doesn't
matter
and
some
gids
are
reserved
for
system
use
users
may
hold
memberships
in
additional
groups
traditionally
additional
group
memberships
is
maintained
by
the
etc
group
file
it
lists
the
group
names
group
ids
and
any
members
who
are
not
already
in
a
group
by
virtue
of
the
primary
gid
permissions
on
file
are
granted
for
a
specified
user
group
and
other
this
is
the
familiar
output
of
which
maps
the
permissions
read
write
or
execute
to
the
user
and
group
and
the
rest
of
the
world
both
files
and
directories
follow
this
extremely
limited
model
for
which
un
x
has
been
duly
criticized
because
of
its
limitations
file
access
requirements
basically
force
the
creation
of
specialized
groups
almost
everything
in
un
x
can
be
accessed
as
files
it
thus
follows
that
access
to
system
resources
named
ipc
objects
unix
domain
sockets
and
devices
is
a
corrolary
of
file
permissions
in
other
words
since
the
resources
have
a
filesystem
representation
they
can
be
ed
just
as
files
can
be
and
have
the
same
type
of
permissions
uid
0
is
omnipotent
because
of
the
way
permission
checks
are
implemented
0
effectively
short
circuits
the
checks
and
grants
access
to
all
files
or
resource
what
follows
is
that
uid
0
the
root
user
wields
power
absolute
over
the
system
setuid
or
setgid
binaries
allow
assuming
another
uid
or
joining
another
group
during
their
execution
with
no
questions
asked
having
execute
permission
to
a
set
ug
id
binary
will
automatically
bestow
those
special
permissions
this
mechanism
which
rightfully
looks
like
a
gaping
design
flaw
is
actually
a
feature
used
to
work
around
privileged
operations
such
as
changing
one's
uid
or
password
such
operations
by
definition
are
only
possible
for
uid
0
but
can
be
enabled
if
the
root
user
empowers
specific
binaries
by
xxx
and
xxx
for
setuid
and
setgid
respectively
as
a
precaution
copying
or
moving
the
binaries
will
strip
those
bits
android
takes
the
classic
model
which
it
obtains
for
free
from
the
underlying
linux
system
and
naturally
employs
it
but
offers
a
different
somewhat
novel
interpretation
in
it
the
users
are
granted
to
individual
applications
not
human
users
suddenly
much
in
the
same
way
as
human
users
sharing
the
same
un
x
server
were
comparmentalized
from
one
another
applications
enjoy
and
are
limited
by
the
same
seclusion
a
user
cannot
access
another
user's
files
directories
or
processes
and
this
exact
isolation
enables
applications
to
run
alongside
eachother
but
with
no
power
to
influence
one
another
this
approach
is
quite
unique
to
android
ios
runs
all
applications
under
one
uid
mobile
or
501
and
relies
on
kernel
enforced
sandboxing
to
isolate
applications
from
one
another
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
when
an
application
is
installed
for
the
first
time
the
packagemanager
assigns
it
a
unique
user
id
which
is
understandably
referred
to
as
an
application
id
this
id
is
taken
from
the
range
of
10000
90000
and
bionic
the
android
c
runtime
library
automatically
maps
this
to
a
human
readable
name
app_xxx
or
u_xxxx
android
can't
get
rid
of
setuid
support
entirely
because
this
requires
recompilation
of
the
kernel
and
other
modifications
beginning
with
jb
4.3
however
no
setuid
binaries
are
installed
by
default
and
the
data
partition
is
mounted
with
the
option
system
defined
aids
android
maintains
the
lower
range
of
user
ids
1000
9999
exclusive
for
system
use
only
a
subset
of
this
range
is
actually
used
and
it
is
hardcoded
in
android_filesystem_config.h
table
8
1
shows
the
uids
defined
and
used
by
android
most
of
these
are
used
as
gids
as
well
by
joining
secondary
groups
system
processes
like
and
others
gain
the
ability
to
access
system
files
and
devices
which
are
owned
by
these
groups
a
simple
yet
effective
strategy
table
8
1
android
aids
and
their
default
holders
gid
define
members
permits
1001
dev
socket
rild
to
radio
interface
layer
daemon
access
net
radio
properties
1002
bluetooth
configuration
files
1003
dev
graphics
fb0
the
framebuffer
1004
dev
input
the
device
nodes
for
input
devices
1005
dev
eac
or
other
audio
device
nodes
access
data
misc
audio
read
data
audio
1006
access
to
camera
sockets
1007
dev
log
1008
compass
and
location
services
1009
dev
socket
vold
on
the
other
side
of
which
is
the
volume
daemon
1010
wifi
configuration
files
data
misc
wifi
1011
reserved
for
adbd
owns
dev
android_adb
1012
owns
some
application
data
directories
1013
access
data
misc
media
and
media
service
access
1014
access
data
misc
dhcp
access
dhcp
properties
1015
group
owner
of
emulated
sdcard
1016
data
misc
vpn
dev
ppp
1017
access
data
misc
keystore
system
keystore
1018
usb
devices
1019
access
to
data
drm
1020
multicast
dns
and
service
discovery
1021
access
data
misc
location
1023
group
owner
of
data
media
and
real
sdcard
1024
mtp
usb
driver
access
not
related
to
mtpd
kdswhu
9
6hfxulw
http
newandroidbook.com
src
android
system
core
include
private
android_filesystem_config.h
table
8
1
cont
android
aids
and
their
default
holders
1026
drm
rpc
1027
near
field
communication
support
data
nfc
and
nfc
service
lookup
1028
external
storage
read
access
1029
clat
ipv6
ipv4
1030
loop
radio
devices
1031
drm
plugins
access
to
data
mediadrm
1032
package
information
metadata
1033
pics
folder
of
sd
card
1034
audio
video
folders
of
sd
card
1035
all
sdcard
folders
android
system
properties
also
rely
on
uids
for
access
control
init's
property_service
limits
access
to
several
property
namespaces
as
was
shown
in
chapter
4
it
likewise
falls
on
the
as
the
crux
of
all
ipc
to
provide
basic
security
though
the
binder
eventually
provides
security
through
a
uid
pid
model
can
restrict
the
lookup
of
well
known
service
names
to
given
uids
though
uid
0
or
system
are
always
allowed
to
register
up
to
and
including
kitkat
this
was
in
a
hard
coded
array
as
shown
in
listing
8
1
listing
8
1
hard
coded
service
permissions
from
service_manager.c
on
kk
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
4
propn
http
newandroidbook.com
src
android
frameworks
native
cmds
servicemanager
service_manager.c
with
the
introduction
of
se
linux
and
the
slow
but
steady
migration
of
android
to
it
the
hard
coded
method
has
been
finally
abandoned
in
favor
of
integration
with
an
se
linux
policy
much
in
the
same
way
as
init's
properties
have
at
any
rate
it's
important
to
note
this
is
but
one
layer
of
security
refuses
to
allow
untrusted
aids
to
register
well
known
names
as
we
discuss
later
the
binder
allows
both
client
and
server
to
perform
additional
permission
checks
and
an
additional
layer
of
dalvik
level
permissions
is
also
employed
paranoid
android
gids
android
gids
of
3000
through
3999
are
also
recognized
by
the
kernel
when
the
is
set
this
restricts
all
aspects
of
networking
access
to
these
gids
only
by
enforcing
additional
gid
checks
in
the
kernel
socket
handling
code
note
that
overrides
these
settings
because
it
is
running
as
root
table
8
2
shows
the
known
network
ids
table
8
2
android
network
related
aids
and
their
holders
gid
define
members
permits
3001
creation
of
af_bluetooth
sockets
3002
creation
of
sco
rfcomm
or
l2cap
sockets
3003
dev
socket
dnsproxyd
and
af_inet
6
ipv4
ipv6
sockets
3004
create
raw
non
tcp
udp
or
multicast
sockets
3005
configure
interfaces
and
routing
tables
3006
reading
bandwidth
statistics
accounting
3007
modifying
bandwidth
statistics
accounting
isolated
services
as
of
jelly
bean
4.1
android
introduces
the
notion
of
isolated
services
this
feature
is
a
form
of
compartmentalization
similar
to
ios's
xpc
which
enables
an
application
to
run
its
services
in
complete
separation
in
a
different
process
with
a
separate
uid
isolated
services
use
the
uid
range
of
99000
through
99999
through
and
the
servicemanager
will
deny
them
any
request
as
a
consequence
they
cannot
lookup
any
system
services
and
are
effectively
limited
to
in
memory
operations
this
is
primarily
useful
for
applications
such
as
web
browsers
and
indeed
chrome
is
a
prime
example
of
using
this
mechanism
as
shown
in
output
8
1
isolated
services
are
marked
as
u
_i
output
8
1
chrome's
isolated
services
kdswhu
9
6hfxulw
file
users
morpheus
documents
android
book
ipc.html
security
file
users
morpheus
documents
android
book
security.html
dalviklevel
root
owned
processes
as
with
linux
the
root
user
uid
0
is
still
just
as
omnipotent
but
far
from
omnipresent
its
use
is
limited
to
the
absolute
bare
minimum
and
that
minimum
is
shrinking
from
one
android
release
to
another
quite
a
few
previous
android
exploits
targetted
root
owned
processes
with
vold
being
a
perennial
favorite
and
the
hope
is
that
by
reducing
their
number
the
attack
surface
could
be
greatly
reduced
the
is
an
example
of
such
a
process
whose
root
privileges
have
been
removed
beginning
with
jellybean
it
is
likely
impossible
to
remove
all
root
owned
processes
at
the
very
least
init
needs
to
retain
root
capabilities
as
does
zygote
whose
fork
assume
different
uids
something
only
uid
0
can
do
you
can
see
the
root
owned
processes
on
your
device
by
typing
the
ignores
kernel
threads
whose
ppid
is
2
table
8
3
shows
the
services
which
still
run
as
root
by
default
in
kitkat
but
note
your
device
may
have
more
as
added
by
the
device
vendor
table
8
3
android
services
still
running
as
root
service
rationale
init
somebody
has
to
maintain
root
privileges
in
the
system
and
launch
others
might
as
well
be
pid
1
ueventd
init
minimal
operation
healthd
minimal
operation
zygote
64
requires
setuid
to
change
into
aid
when
loading
apks
retains
capabilities
for
debugger
64
requires
root
privileges
to
use
in
order
to
read
process
memory
when
generating
tombstones
adb
developers
may
need
legitimate
root
access
system
trusts
adb
to
immediately
drop
privileges
to
if
is
0
or
is
1
vold
un
mounting
filesystems
and
more
netd
configuring
interfaces
assigning
ips
dhcp
and
more
lmkd
adjusting
oom
settings
possibly
killing
other
processes
as
stated
back
in
chapter
2
the
vendor
binaries
greatly
increase
the
attack
surface
of
android
especially
when
they
are
run
as
root
what
exacerbates
the
matter
is
that
whereas
the
aosp
binaries
remain
open
source
and
therefore
easy
to
analyze
for
security
by
all
the
vendor
binaries
are
closed
source
and
some
vendors
sacrifice
security
in
favor
of
functionality
when
you
hear
of
a
specific
vulnerability
in
a
device
e.g
htc
one
m8
rather
than
a
version
of
android
it
is
very
likely
the
cause
lies
within
a
vendor
binary
eventually
it
is
expected
that
android
will
leave
only
those
services
which
absolutely
must
have
root
and
others
will
follow
in
the
steps
of
to
do
so
android
will
have
to
increase
its
usage
of
another
important
linux
security
feature
capabilities
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
linux
capabilities
originally
part
of
the
posix
1e
draft
and
thus
meant
to
be
incorporated
as
a
standard
for
all
un
x
capabilities
were
an
early
adoption
into
the
2.2
line
of
kernels
though
the
posix
draft
was
eventually
withdrawn
capabilties
remained
implemented
in
linux
and
have
since
been
expanded
and
improved
on
distributions
of
linux
don't
make
use
of
capabilities
all
that
often
but
android
makes
extensive
use
of
them
the
idea
behind
capabilities
is
to
break
the
all
or
nothing
model
of
the
root
user
the
root
user
is
fully
omnipotent
whereas
all
other
users
are
effectively
impotent
because
of
this
if
a
user
needs
to
perform
some
privileged
operation
the
only
standard
solution
is
to
resort
to
setuid
become
uid
0
for
the
scope
of
the
operation
then
yield
superuser
privileges
and
revert
to
a
non
privileged
user
this
holds
true
for
even
relatively
simple
operations
setting
the
system
time
binding
privileged
1024
network
ports
mounting
certain
filesystems
and
more
as
a
result
un
x
systems
traditionally
contained
a
very
large
number
of
setuid
binaries
if
a
setuid
binary
can
be
trusted
then
in
theory
the
model
should
work
in
practice
however
setuid
poses
inherent
security
risks
if
a
setuid
binary
is
somehow
exploited
it
could
be
tricked
into
compromising
root
common
tricks
include
symlinks
and
race
conditions
diverting
the
binary
to
overwrite
system
configuration
files
and
code
injection
forcing
the
binary
to
execute
a
root
shell
hence
the
term
shellcode
for
injected
code
capabilities
offer
a
solution
to
this
problem
by
slicing
up
the
powers
of
root
into
distinct
areas
each
represented
by
a
bit
in
a
bitmask
and
allowing
or
restricting
privileged
operations
in
these
areas
only
by
toggling
the
bitmask
this
makes
them
an
implementation
of
the
principle
of
least
privilege
a
tenet
of
security
which
dictates
that
an
application
or
user
must
not
be
given
any
more
rights
than
are
absolutely
required
for
its
normal
operation
you
can
see
a
logical
view
of
capabilities
in
figure
8
1
figure
8
1
a
logical
representation
of
capabilities
kdswhu
9
6hfxulw
restricting
a
subset
of
allowed
privileges
to
only
those
absolutely
required
while
revoking
the
rest
increases
security
significantly
even
if
a
given
application
or
user
ends
up
being
malicious
or
cajoled
to
the
dark
path
by
code
injection
its
scope
of
damage
is
compartmentalized
capabilities
are
like
a
sandbox
allowing
only
those
operations
which
an
app
by
design
requires
while
at
the
same
time
preventing
it
from
running
amuck
and
compromising
system
security
in
fact
a
nice
side
effect
of
capabities
is
that
they
can
be
used
to
restrict
the
root
user
itself
in
cases
where
the
user
behind
the
uid
is
not
fully
trustworthy
init
still
starts
most
of
android's
server
processes
as
root
and
these
processes
have
the
full
capabilities
bitmask
as
they
launch
before
these
processes
actually
do
anything
however
they
drop
their
privileges
and
retain
only
the
capabilities
they
need
a
good
example
of
adhering
to
the
principle
of
least
privilege
can
be
seen
in
which
makes
sure
to
drop
all
but
the
privileges
it
needs
for
package
installation
listing
8
2
installd's
usage
of
capabilities
the
heaviest
user
of
capabilties
is
unsurprisingly
since
it
is
a
owned
process
but
still
needs
root
privileges
for
many
of
its
normal
operations
table
8
4
shows
the
linux
capabilities
and
the
android
processes
known
to
use
them
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
table
8
4
linux
capabilities
used
by
android
processes
capability
define
users
permits
0x01
change
file
and
group
ownership
0x02
override
discretionary
access
control
on
files
dirs
0x20
kill
processes
not
belonging
to
the
same
uid
0x40
allow
setuid
2
seteuid
2
and
setfsuid
2
0x80
allow
setgid
2
and
setgroups
2
0x400
bind
local
ports
at
under
1024
0x800
broadcasting
multicasting
0x1000
interface
configuration
routing
tables
etc
0x2000
raw
sockets
0x10000
insert
remove
module
into
kernel
0x800000
set
process
priority
and
affinity
0x1000000
set
resource
limits
for
processes
0x2000000
set
real
time
clock
0x4000000
configure
hangup
tty
devices
0x400000000
configure
kernel
ring
buffer
log
dmesg
0x1000000000
override
0
policies
dfwxdoo
ljqruhg
note
that
table
8
4
provides
a
limited
albeit
large
subset
of
the
linux
capabilities
it
is
likely
that
over
the
evolution
of
both
linux
and
android
more
capabilities
will
be
added
the
following
experiment
demonstrates
how
you
can
see
capabilities
used
by
processes
experiment
viewing
capabilities
and
group
memberships
you
can
easily
view
system_server's
capabilities
and
group
memberships
or
those
of
any
other
process
for
that
matter
by
looking
at
proc
pid
status
replacing
pid
with
the
pid
of
the
process
in
question
output
8
2
viewing
system_server's
capabilities
and
group
memberships
in
the
above
you
can
see
four
bitmasks
for
capabilities
those
inheritable
by
child
process
those
potentially
permitted
for
this
process
those
actively
in
effect
as
in
permitted
and
also
explicitly
required
by
the
process
and
the
bounding
set
the
bounding
set
added
in
linux
2.6.25
is
a
bitmask
which
limits
the
usage
of
kdswhu
9
6hfxulw
beginning
with
jb
4.3
calls
and
to
ensure
that
no
further
capabilities
can
be
added
to
its
child
processes
i.e
the
user
apps
it
is
likely
that
going
forward
and
will
both
drop
their
privileges
and
rely
on
capabilities
rather
than
retain
their
root
privileges
this
is
especially
important
considering
s
history
of
vulnerabilities
experiment
viewing
capabilities
and
group
memberships
cont
by
looking
over
pids
in
proc
you
can
single
out
the
processes
which
use
capabilities
this
requires
a
bit
of
shell
scripting
as
shown
in
the
following
output
output
8
3
processes
with
capabilities
as
the
above
showv
the
capabilities
are
in
line
with
table
note
that
some
vendors
above
htc
may
add
their
own
processes
above
qseecomd
with
additional
capabilities
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
figure
8
2
the
selinux
logo
selinux
selinux
security
enhanced
lqx
marks
a
step
further
in
the
evolution
of
linux
beyond
standard
un
x
originally
developed
by
the
nsa
selinux
is
a
set
of
patches
which
have
long
since
been
incorporated
into
the
mainline
kernel
with
the
aim
of
providing
a
mandatory
access
control
mac
framework
which
can
restrict
operations
to
a
predefined
policy
as
with
capabilities
selinux
implements
the
principle
of
least
privilege
but
with
much
finer
granularity
this
greatly
augments
the
security
posture
of
a
system
by
preventing
processes
from
operating
outside
strictly
defined
operational
bounds
so
long
as
the
process
is
well
behaving
this
should
pose
no
problem
if
the
process
misbehaves
however
as
most
often
is
the
case
of
malware
or
the
result
of
code
injection
selinux
will
block
any
operation
which
exceeds
those
bounds
the
approach
is
very
similar
to
ios's
sandbox
which
builds
on
the
trustedbsd
mac
framework
though
the
implementation
is
quite
different
though
long
included
in
linux
and
like
capabilities
not
always
implemented
by
default
selinux
was
introduced
into
android
with
jellybean
4.3
the
initial
introduction
was
gentle
setting
selinux
in
permissive
mode
wherein
any
violations
of
the
policy
are
merely
audited
with
kitkat
4.4
however
selinux
now
defaults
to
enforcing
mode
for
several
of
android's
services
specifically
and
though
still
permissive
for
all
other
processes
in
general
it
is
considered
a
good
practice
to
use
the
per
domain
permissive
mode
in
order
to
test
a
policy
before
setting
it
to
enforcing
and
it
is
likely
that
enforcement
will
expand
with
the
next
version
of
android
selinux's
port
to
android
commonly
referred
to
as
seandroid
was
first
described
in
a
paper1a
and
a
presentation1b
by
smalley
and
craig
of
the
nsa
who
have
followed
up
on
seandroid
with
an
excellent
presentation
in
the
2014
android
builders
summit1c
google
provides
basic
documentation
in
the
android
source
site2
of
the
mainline
linux
distributions
redhat
has
been
an
early
adopter
and
provides
a
comprehensive
guide3
seandroid
follows
the
same
principle
of
the
original
but
extends
it
to
accommodate
android
specific
features
such
as
system
properties
and
naturally
the
binder
via
kernel
hooks
samsung
further
extends
seandroid
and
uses
it
as
a
foundation
for
their
knox
secure
platform
currently
in
v2.0
knox
referred
to
by
some
as
obknoxious
boasts
a
stronger
security
policy
enforcing
and
confining
all
processes
except
init
and
the
kernel
threads
in
the
following
discussion
selinux
refers
to
those
features
found
in
both
linux
and
android
whereas
seandroid
refers
only
to
the
latter
the
main
principle
of
selinux
and
in
fact
most
mac
frameworks
is
that
of
labeling
a
label
assigns
a
type
to
a
resource
object
and
a
security
domain
for
a
process
subject
selinux
can
then
enforce
so
as
to
allow
only
processes
in
the
same
domain
likewise
labeled
to
access
the
resource
some
mac
frameworks
go
as
far
as
to
make
resources
with
different
labels
invisible
somewhat
akin
to
the
linux
concept
of
namespaces
although
selinux
does
not
go
that
far
depending
on
the
policy
domains
can
also
be
made
confined
so
that
processes
cannot
access
any
resource
but
those
allowed
the
policy
enforcement
is
performed
independently
of
other
layers
of
permissions
e.g
file
acls
the
policy
may
also
allow
relabeling
for
some
labels
relabelto
and
relabelfrom
also
called
a
domain
transition
in
some
cases
which
is
a
necessary
requirement
if
a
trusted
process
e.g
zygote
spawns
an
untrusted
one
virtually
any
user
application
an
selinux
label
is
merely
a
4
tuple
formatted
as
a
string
of
the
form
user
role
type
level
all
processes
with
the
same
label
i.e
in
the
same
domain
are
equivalent
seandroid
presently
only
defines
the
type
i.e
the
label
is
always
in
the
form
domain
as
of
kitkat
the
seandroid
policy
defines
individual
domains
for
all
daemons
i.e
each
daemon
gets
its
own
permissions
and
security
profiles
along
with
the
domains
shown
in
table
8
5
for
application
classes
kdswhu
9
6hfxulw
http
www.internetsociety.org
sites
default
files
02_4
pdf
http
www.internetsociety.org
sites
default
files
presentation02_4
pdf
http
events.linuxfoundation.org
sites
events
files
slides
abs2014_seforandroid_smalley.pdf
http
source.android.com
devices
tech
security
se
linux.html
https
access.redhat.com
site
documentation
en
us
red_hat_enterprise_linux
6
html
security
enhanced_linux
table
8
5
the
application
class
domains
in
android
4.4
label
domain
apps
restrictions
reserved
for
kernel
threads
unconfined
god
mode
isolated
processes
previously
connected
anonymous
unix
sockets
read
write
signed
with
media
key
allowed
to
access
network
signed
with
platform
key
signed
with
shared
key
signed
with
release
key
all
other
access
asec
sdcard
tcp
udp
sockets
ptys
the
keys
referred
to
in
table
8
5
are
defined
in
system
etc
security
mac_permissions.xml
which
is
part
of
the
middleware
mac
mmac
implementation
the
package
manager
recognizes
the
keys
used
for
signing
apps
and
labels
the
applications
accordingly
using
a
call
to
this
is
done
during
package
scanning
part
of
the
package
installation
as
described
in
volume
ii
note
the
term
middleware
here
applies
to
labeling
performed
strictly
in
user
mode
by
the
android
system
components
all
the
domains
inherit
from
the
base
which
allows
the
basic
application
profile
including
actions
such
as
using
the
binder
communicating
with
zygote
sufraceflinger
etc
you
can
find
the
type
enforcement
te
files
which
contain
the
detailed
definitions
for
all
domains
in
the
aosp's
external
sepolicy
directory
the
syntax
used
in
those
files
is
a
mixture
of
keywords
and
macros
from
temacros
which
allow
or
deny
operations
in
the
domain
as
shown
in
listing
8
3
listing
8
3
sample
te
file
debuggerd.te
the
files
in
external
sepolicy
form
the
baseline
which
all
devices
are
meant
to
automatically
inherit
from
rather
than
modify
them
vendors
are
encouraged
to
add
four
specific
variables
in
their
boardconfig.mk
file
specifying
to
override
add
or
omit
files
from
the
policy
and
to
provide
the
search
path
for
the
directories
containing
their
files
this
mitigates
the
risk
of
an
accidental
policy
change
due
to
file
error
which
may
result
in
security
holes
the
directory
also
contains
the
mac_permissions.xml
template
which
is
populated
with
keys
in
keys.conf
the
stock
type
enforcement
files
are
all
concatenated
and
compiled
into
the
resulting
sepolicy
file
which
is
a
binary
file
placed
on
the
root
file
system
doing
so
offers
further
security
because
the
root
filesystem
is
mounted
from
the
initramfs
which
is
itself
part
of
the
that
is
digitally
signed
and
therefore
hopefully
tamperproof
the
compilation
is
performed
merely
as
an
optimization
and
the
resulting
file
can
be
easily
decompiled
as
is
shown
in
the
experiment
sec
dispol
the
binary
policy
file
can
be
loaded
through
sys
fs
selinux
though
init
most
commonly
does
so
through
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
what
remains
then
is
to
define
the
process
of
assigning
the
labels
to
resources
through
contexts
the
resources
recognized
by
selinux
are
linux
file
objects
including
sockets
device
nodes
pipes
and
other
objects
with
a
file
representation
and
seandroid
extends
this
further
to
allow
for
properties
experiment
decompiling
an
android
sepolicy
file
if
you
have
a
linux
host
decompiling
an
sepolicy
can
be
performed
with
the
command
which
is
part
of
the
package
assuming
fedora
or
a
similar
derivative
this
first
involves
getting
the
package
if
you
don't
already
have
it
output
8
4
obtaining
the
package
once
you
have
the
command
all
you
need
is
to
transfer
the
policy
to
the
host
and
start
examining
it
the
command
is
an
interactive
one
though
the
policy
is
usually
the
one
defined
in
sepolicy
you
can
get
the
actively
loaded
policy
through
sysfs
as
well
the
sys
fs
selinux
directory
will
contain
many
interesting
entries
used
for
configuring
and
potentially
disabling
selinux
of
which
one
is
the
actively
loaded
policy
this
will
require
you
to
do
something
similar
to
the
following
output
8
5
decompiling
disassembling
the
active
policy
kdswhu
9
6hfxulw
application
contexts
the
seapp_contexts
file
provides
a
mapping
of
applications
in
the
form
of
uids
to
domains
this
is
used
to
label
processes
based
on
the
uid
and
the
seinfo
field
as
set
by
the
package
manager
according
to
the
package
signature
as
it
correlates
with
system
etc
security
mac_permissions.xml
you
can
see
the
labeling
of
processes
with
the
toolbox's
output
8
6
selinux
process
contexts
with
file
contexts
se
linux
can
associates
every
file
with
a
security
context
the
file_contexts
file
provides
all
the
contexts
for
protected
files
and
the
switch
of
s
can
display
them
as
shown
in
the
following
output
8
7
selinux
file
contexts
with
property
contexts
as
discussed
in
chapter
4
init's
property
service
restricts
access
to
certain
property
namespaces
by
a
hard
coded
uid
table
this
is
a
very
rigid
mechanism
and
hardly
scalable
as
new
properties
and
namespaces
are
added
in
between
android
releases
since
selinux
already
provides
the
notion
of
execution
contexts
it
is
trivial
to
extend
them
to
properties
as
well
as
of
jellybean
init
protects
access
to
properties
by
a
boolean
the
function
loads
the
property
contexts
from
two
files
data
security
property_contexts
when
present
and
property_contexts
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file_contexts
file
users
morpheus
documents
android
book
services.html
4
propn
output
8
8
selinux
property
contexts
if
you
go
back
to
chapter
4
you'll
see
that
the
property
contexts
essentially
mirror
the
definitions
in
the
table
the
main
difference
however
is
that
providing
the
contexts
in
an
external
file
provides
a
far
more
extensible
way
of
changing
and
modifying
properties
all
without
a
need
to
recompile
init
init
and
toolbox
commands
recall
from
chapter
4
that
the
android
init
has
a
rich
variety
of
commands
which
may
be
used
in
its
rc
files
with
the
introduction
of
selinux
additional
commands
have
been
added
to
allow
for
selinux
contexts
toolbox
has
likewise
been
modified
to
allow
selinux
modifications
from
the
shell
table
8
6
shows
these
commands
table
8
6
init
and
toolbox
commands
for
selinux
init
toolbox
usage
n
a
get
selinux
enforcement
status
secontext
n
a
set
change
selinux
context
init
uses
path
restore
selinux
context
for
path
0
1
toggle
selinux
enforcement
on
off
name
value
name
value
toggle
boolean
value
0
false
off
or
1
true
on
note
you
can
achieve
most
of
the
functionality
of
the
selinux
commands
by
accessing
files
in
sys
fs
selinux
which
is
in
fact
what
some
of
these
commands
do
though
this
would
require
both
root
access
and
an
unconfined
domain
init
which
remains
unconfined
can
also
relabel
processes
as
it
does
for
services
with
the
option
and
additionally
provides
the
property
trigger
to
reload
the
policy
disabling
selinux
altogether
can
be
accomplished
through
sys
fs
selinux
disable
or
through
the
kernel
command
line
argument
kdswhu
9
6hfxulw
file
users
morpheus
documents
android
book
services.html
4
propn
file
users
morpheus
documents
android
book
services.html
4
initcs
other
noteworthy
features
linux
has
some
additional
settings
which
android
enables
which
aim
to
improve
security
by
hardening
otherwise
insecure
defaults
this
section
discusses
them
briefly
at_secure
the
linux
kernel's
elf
loader
uses
an
auxilliary
vector
to
provide
metadata
for
the
images
it
loads
this
vector
can
be
accessed
through
the
proc
filesystem
as
proc
pid
auxv
one
of
its
entries
is
set
to
a
non
zero
value
for
set
ug
id
binaries
programs
with
capabilities
and
programs
which
force
an
selinux
domain
traversal
in
those
cases
bionic's
linker
system
bin
linker
is
configured
to
drop
unsafe
environment
variables
a
hard
coded
list
in
the
__is_unsafe_environment_variable
function
in
bionic
linker
linker_environ.cpp
chief
amongst
the
variables
are
and
a
favorite
technique
for
library
injection
address
space
layout
randomization
code
injection
attacks
use
the
target
process
address
space
as
their
playing
field
and
their
success
often
depends
on
intimate
knowledge
of
its
details
addresses
regions
and
protections
this
is
because
injection
attacks
either
directly
add
code
into
an
existing
program
or
subvert
its
execution
so
as
to
jump
to
already
existing
regions
in
both
cases
knowledge
of
the
layout
is
vital
because
jumping
to
an
incorrect
address
will
lead
to
a
crash
normally
since
process
launch
deterministically
into
a
private
address
space
a
hacker
can
to
paraphrase
an
old
java
motto
debug
once
hack
everywhere
address
space
layout
randomization
aslr
attempts
to
make
injection
attacks
harder
by
introducing
randomness
shuffling
the
layout
of
memory
regions
making
their
addresses
less
predictable
this
increases
the
chance
a
targetted
piece
of
code
will
be
shifted
in
memory
and
basically
trade
a
crash
in
place
of
compromise
by
malicious
code
a
lesser
evil
by
all
counts
linux
offers
randomization
capabilities
through
proc
sys
kernel
randomize_va_space
or
the
value
0
specifies
no
randomization
1
specifies
stack
randomization
and
2
specifies
both
stack
and
heap
which
is
the
default
executables
can
also
be
compiled
with
the
pie
position
independent
executable
option
the
pie
switch
which
is
mandatory
as
of
android
l
defined
as
app_pie
in
the
android.mk
files
experiment
testing
aslr
to
see
the
effects
of
aslr
you
can
use
the
following
shell
script
over
proc
the
script
iterates
over
all
processes
finds
the
location
of
libc.so
in
it
only
the
text
section
as
filtered
by
the
and
displays
it
along
with
the
pid
if
found
output
8
9
showing
the
effects
of
aslr
as
the
output
shows
the
library
is
often
randomized
yet
some
processes
still
share
the
same
location
for
libc
those
are
the
spawns
of
the
zygote
which
to
load
a
class
but
does
not
call
and
hence
remains
with
the
same
address
space
layout
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
kernel
space
aslr
has
yet
at
the
time
of
writing
to
make
it
into
android
introduced
for
the
first
time
in
ios
6.0
it
eventually
made
it
into
linux
with
version
3.14
which
is
actually
the
most
recent
at
the
time
these
lines
are
being
typed
it
is
quite
likely
to
be
introduced
into
android
with
the
version
to
follow
kitkat
aslr
provides
a
layer
of
defense
only
against
code
injected
through
an
input
vector
if
an
adversary
already
has
execution
privileges
s
he
can
invoke
the
powerful
apis
to
read
the
address
space
of
other
processes
and
even
inject
remote
threads
thankfully
one
has
to
obtain
root
privileges
first
selinux
can
and
should
be
used
to
prevent
access
to
altogether
kernel
hardening
unlike
mainline
linux
android
kernels
export
no
proc
kcore
by
default
as
this
entry
allows
kernel
read
only
memory
access
from
user
mode
by
root
the
proc
kallsyms
is
still
present
in
most
devices
and
actually
world
readable
by
default
but
protected
by
the
kernel.kptr_restrict
sysctl
which
is
set
by
default
to
2
to
prevent
any
addresses
from
being
displayed
kernel
ring
buffer
access
via
the
dmesg
is
likewise
protected
by
kernel.dmesg_restrict
stack
protections
as
sophisticated
as
attacks
can
get
they
still
for
the
most
part
rely
on
overwriting
a
function
pointer
which
when
called
causes
a
subversion
of
the
program
flow
not
all
programs
use
function
pointers
but
all
utilize
the
return
address
which
is
stored
on
the
stack
during
a
function
call
as
a
countermeasure
to
this
most
modern
compilers
offer
automatic
stack
protection
by
means
of
a
canary
like
the
proverbial
canary
in
the
coal
mine
a
stack
canary
is
a
random
value
written
to
the
stack
upon
function
entry
and
verified
right
before
the
function
returns
if
the
value
cannot
be
verified
the
stack
is
deemed
corrupt
and
the
program
voluntarily
aborts
rather
than
potential
trigger
malicious
code
this
form
of
protection
has
been
available
in
android
since
its
early
days
with
gcc's
note
that
it
does
not
provide
a
panacea
since
code
can
still
be
injected
via
function
pointers
aside
from
the
return
address
c
methods
make
good
candidates
data
execution
prevention
code
injection
attacks
rely
on
embedding
malicious
code
inside
input
whether
direct
from
the
user
or
from
other
sources
input
however
is
data
and
memory
used
for
data
the
heap
and
the
stack
can
be
flagged
as
non
executable
this
complicates
attacks
somewhat
because
just
using
the
classic
trampoline
technique
overwriting
a
pointer
or
the
stack
return
address
with
the
address
of
the
injected
code
won't
work
if
the
injected
code
is
in
the
data
segment
unfortunately
for
most
while
making
data
non
executable
complicates
the
simple
attacks
attacks
have
considerably
evolved
the
current
counterattack
is
return
oriented
programming
rop
a
fairly
old
technique
introduced
by
solar
designer
in
a
00
paper
as
return
to
libc
which
strings
together
gadgets
of
calls
back
into
existing
portions
of
code
in
the
program
simulating
function
calls
on
the
stack
because
these
are
calls
into
code
there's
nothing
to
make
non
executable
and
thus
the
protection
can
be
fairly
reliably
circumvented
compiler
level
protections
all
the
above
protections
are
in
a
way
treating
the
symptoms
rather
than
the
disease
at
the
end
of
the
day
the
only
proper
ways
to
combat
code
injection
attacks
which
exploit
memory
corruption
is
to
exercise
defensive
coding
which
involves
input
validation
and
strict
bounds
checking
on
memory
operations
newer
versions
of
android
have
taken
that
to
heart
with
the
source
compiled
with
enhanced
checks
most
notably
and
which
add
additional
checks
on
memory
copying
functions
and
prevent
format
string
attacks
kdswhu
9
6hfxulw
security
at
the
dalvik
level
dalvik
level
permissions
working
at
the
level
of
a
virtual
machine
rather
than
native
code
brings
with
it
tremendous
advantages
for
monitoring
operations
and
enforcing
security
at
the
native
level
one
would
have
to
monitor
system
calls
for
any
significant
resource
access
the
problem
with
system
calls
however
is
that
their
granularity
is
inaccurate
file
access
is
straightforward
open
read
write
close
but
other
operations
e.g
a
dns
lookup
are
a
lot
harder
to
monitor
as
they
involve
multiple
system
calls
therein
lies
the
advantage
of
the
virtual
machine
most
operations
are
carried
out
by
means
of
pre
supplied
packages
and
classes
and
those
come
built
in
with
permission
checks
android
actually
takes
this
a
step
further
whereas
in
a
normal
java
class
a
malicious
developer
could
ostensibly
import
other
classes
implement
functionality
from
scratch
or
use
jni
to
break
out
of
the
vm
in
order
to
avoid
permission
checks
though
this
is
next
to
impossible
in
android
the
user
application
is
entirely
powerless
devoid
of
all
capabilities
and
permissions
at
the
linux
level
so
any
access
to
the
underlying
system
resources
should
be
blocked
right
there
in
order
to
carry
out
any
operation
which
has
an
effect
outside
the
scope
of
the
application
one
has
to
involve
by
calling
while
any
app
can
freely
invoke
a
call
to
none
has
access
to
its
defined
permissions
which
will
check
this
check
is
performed
outside
the
application's
process
so
the
application
has
no
plausible
avenue
by
means
of
which
it
may
somehow
obtain
those
permissions
unless
they
were
a
priori
assigned
to
it
the
assignment
is
performed
when
the
application
is
loaded
and
installed
meaning
that
the
user
has
been
notified
of
the
application's
requested
permissions
has
hopefully
read
through
the
very
long
list
and
approved
them
again
hopefully
knowing
the
ramifications
of
hitting
ok
if
the
permission
requested
during
runtime
has
been
revoked
for
example
through
the
appops
service
or
through
a
security
exception
will
be
thrown
normally
this
will
crash
the
application
unless
the
developer
braced
for
such
an
exception
in
which
case
it
may
handle
the
exception
usually
popping
up
an
explanation
on
what
permission
was
required
or
at
other
times
failing
silently
what
follows
is
that
the
permissions
themselves
need
no
special
data
structures
or
complicated
metadata
a
permission
in
dalvik
is
nothing
more
than
a
simple
constant
value
which
is
granted
to
an
application
in
its
manifest
as
it
declares
it
an
application
can
likewise
define
its
own
constants
as
tags
in
the
manifest
when
the
package
manager
installs
an
app
it
adds
the
permissions
of
said
app
to
the
permissions
database
which
is
in
effect
part
of
the
package
database
data
system
packages.xml
this
database
contains
a
lot
more
valuable
information
including
public
keys
than
just
permissions
which
is
why
it
is
discussed
in
detail
in
volume
ii
but
the
pertinent
portions
of
it
are
shown
in
table
8
table
8
7
the
elements
pertaining
to
permissions
in
the
package
database
element
contains
permission
trees
an
array
of
tree
specifying
permission
namespaces
and
the
packages
wkich
define
them
permissions
an
array
of
permission
s
each
of
which
defines
the
permission
constant
name
as
defined
in
its
original
element
the
package
which
defined
this
permission
with
android
for
sdk
permissions
which
defines
the
permission
protection
level
and
flags
from
the
class
permissions
levels
are
0
1
2
or
3
with
flags
for
0x10
and
0x20
note
the
value
is
printed
as
a
decimal
integer
when
in
fact
it
should
be
hexadecimal
android
m
finally
fixes
this
naive
and
broken
model
followin
i
s's
desi
n
of
enforcin
permissions
durin
runtime
promptin
the
user
durin
the
action
with
the
help
of
an
out
of
process
entity
in
i
s
this
is
handled
by
the
tcc
daemon
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
base
core
java
android
content
pm
permissioninfo.java
table
8
7
cont
the
elements
pertaining
to
permissions
in
the
package
database
element
contains
package
each
installed
application
is
identified
by
its
attribute
reverse
dns
name
of
package
and
assigned
an
aid
via
the
attribute
specific
permissions
granted
to
the
application
are
listed
as
items
in
the
child
element
shared
user
aids
shared
between
two
or
more
applications
are
specified
by
the
attribute
and
once
more
specific
permissions
are
granted
this
time
to
the
aid
i.e
all
applications
sharing
it
as
items
in
the
child
element
if
you
inspect
the
package
database
as
root
you
will
find
that
the
element
contains
both
custom
permissions
i.e
those
declared
by
installed
apps
and
system
ones
the
built
in
system
permissions
along
with
protected
broadcasts
are
specified
in
the
system
framework
framework
res.apk
which
can
be
examined
using
as
shown
in
the
following
output
output
8
10
dumping
the
system
framework
framework
res.apk
from
a
nexus
9
as
the
above
shows
permission
are
bundled
into
groups
with
flags
defined
both
at
the
group
level
through
and
at
the
individual
level
through
this
bundling
and
categorizing
comes
in
handy
for
the
power
user
who
is
expected
to
use
the
upcall
script
to
display
or
manage
permissions
kdswhu
9
6hfxulw
make
that
flag
since
at
the
present
time
only
group
and
permission
are
used
but
this
scheme
does
allow
for
future
extension
experiment
using
the
command
you
can
use
to
display
permissions
both
of
the
android
frameworks
and
of
third
party
applications
to
do
so
try
output
8
11
listing
permissions
with
other
useful
switches
include
verbose
human
readable
output
in
your
locale
permission
groups
the
command
can
also
be
used
to
grant
and
revoke
optional
permissions
and
even
toggle
permission
enforcement
i.e
the
full
syntax
of
this
command
including
some
notable
changes
made
for
android
m
is
explained
in
volume
ii
the
appops
service
detailed
in
volume
ii
provided
a
powerful
gui
by
means
of
which
users
could
track
and
fine
grain
tune
application
permission
usage
the
gui
has
been
removed
as
part
of
kitkat's
4.4.2
security
update
but
the
service
is
alive
and
well
in
fact
lollipop
introduces
the
upcall
script
which
can
be
used
to
allow
deny
ignore
or
reset
an
application's
permissions
unfortunately
the
command
line
only
allows
a
small
subset
of
operations
and
and
but
those
could
be
extended
to
the
full
set
of
presently
48
operations
by
recompiling
note
however
that
is
another
layer
on
top
of
the
permissions
and
uses
a
separate
database
data
system
appops.xml
this
is
shown
in
output
8
12
output
8
12
demonstrating
the
upcall
script
in
l
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
mapping
permissions
to
linux
uids
the
system
etc
permissions
platform.xml
file
acts
as
a
glue
between
dalvik
level
permissions
and
those
of
linux
the
file
is
included
in
the
aosp
sources
and
is
well
documented
so
that
vendors
can
carefully
add
any
specific
permissions
or
aids
the
mapping
works
both
ways
that
is
a
given
can
be
set
to
grant
membership
to
a
and
vice
versa
by
using
to
a
given
named
permission
to
a
uid
listing
8
4
shows
a
sample
of
this
file
listing
8
4
an
example
system
etc
permissions
platform.xml
file
if
you
check
the
system
etc
permissions
directory
on
your
device
you
will
likely
find
several
more
xml
files
android.hardware
and
android.software
copied
during
the
build
process
from
the
aosp
files
as
well
as
possibly
some
vendor
provided
files
kdswhu
9
6hfxulw
dalvik
code
signing
permissions
by
themselves
are
somewhat
useless
after
all
any
app
can
declare
whatever
permissions
it
requires
in
its
androidmanifest.xml
and
the
unwitting
user
will
probably
click
ok
when
prompted
to
bolster
security
google
requires
digital
signatures
on
applications
uploaded
to
the
play
store
so
as
to
identify
the
developer
s
behind
them
and
add
accountability
thus
all
android
applications
must
be
signed
with
the
process
explained
in
volume
ii
what's
not
so
clear
is
by
whom
as
google
was
playing
catch
up
to
apple
and
opened
the
play
store
it
wanted
to
offer
an
advantage
to
developers
in
the
form
of
a
simpler
process
as
opposed
to
apple's
lengthy
validation
process
all
apps
must
be
vetted
by
apple
and
digitally
signed
by
them
google
offered
anyone
the
ability
to
just
create
a
key
pair
publish
their
public
key
and
use
the
private
key
to
sign
their
apk
file
the
rationale
was
that
this
achieves
a
similar
level
of
identifying
the
apk's
source
while
at
the
same
time
greatly
simplifying
the
process
of
submitting
applications
to
the
store
in
practice
this
led
to
an
explosion
of
malware
in
the
play
store
the
google
approach
was
that
any
malware
found
and
reported
would
be
removed
from
the
store
and
the
corresponding
public
keys
blacklisted
from
the
malware
author's
side
this
was
a
case
of
better
to
beg
forgiveness
than
ask
permission
as
the
malware
by
then
would
have
likely
propagated
by
the
time
it
was
detected
thus
achieving
its
purpose
this
coupled
with
the
fact
that
a
malware
developer
could
always
generate
a
new
key
pair
hollowed
out
the
entire
security
model
a
recent
study
published
in
rsa
20144
found
that
malicious
apps
have
grown
388
percent
from
2011
to
2013
while
the
number
of
malicious
apps
removed
annually
by
google
has
dropped
from
60
in
2011
to
23
in
2013
and
that
effectively
one
out
of
every
8
apps
in
the
store
is
in
fact
malicious
the
android
master
key
vulnerability
one
of
the
most
serious
vulnerabilities
discovered
in
android
in
2013
is
what
came
to
be
known
somewhat
erroneously
as
the
master
key
vulnerability
the
vulnerability
discovered
by
bluebox
security5a
and
refined
among
others
by
saurik5b
the
noted
creator
of
ios
cydia
occurred
in
of
mishandling
of
apk
files
which
contained
files
with
duplicate
names
apks
are
zip
files
and
normally
most
utilities
aapt
included
would
not
allow
duplicate
file
names
in
the
same
zip
technically
however
it
is
possible
and
introduced
a
peculiar
vulnerability
file
signature
verification
was
performed
on
the
first
entry
in
the
apk
whereas
extraction
was
performed
on
the
second
this
oddity
was
due
to
two
different
libraries
java's
and
dalvik's
native
implementation
being
used
for
the
tasks
as
a
consequence
it
followed
that
anyone
could
take
a
validly
signed
apk
file
and
just
add
additional
files
with
the
same
names
as
the
original
including
classes.dex
of
course
this
effectively
bypassed
android's
signature
validation
on
apks
though
fixed
the
bug
is
a
great
example
of
oftentimes
gaping
vulnerabilities
which
need
little
to
no
technical
knowledge
in
order
to
exploit
the
android
fake
id
vulnerability
the
2014
counterpart
of
the
master
key
vulnerability
became
known
as
the
fake
id
vulnerability
this
time
a
fault
in
android's
certificate
validation
allows
the
forgery
of
an
application's
identity
by
supplying
a
deliberately
broken
certificate
chain
packing
a
malicious
app
with
a
fake
certificate
along
with
a
real
though
unrelated
one
or
even
several
as
a
consequnce
a
malicious
app
could
inherit
the
permission
sets
given
to
trusted
apps
the
example
commonly
given
was
impersonating
adobe's
components
and
becoming
a
webkit
plugin
the
vulnerability
also
discovered
by
bluebox6
generated
a
big
buzz
at
the
black
hat
conference
of
that
year
especially
considering
it
was
exploitable
for
almost
four
years
since
eclair
at
the
time
affecting
all
devices
on
the
market
up
to
and
including
kitkat
google
eventually
patched
this
and
it
is
no
longer
an
issue
with
l
but
dorqj
zlwk
qxphurxv
rwkhu
h
dpsohv
it
just
comes
to
show
that
security
vulnerabilities
do
abound
as
an
anecdote
apple's
ios
6
x
7.0.4
all
suffered
a
similarly
embarassing
bug
the
so
called
ssl
goto
fail
which
was
the
result
of
code
accidentally
left
behind
that
effectively
bypassed
ssl
certificate
validation
apple
was
ridiculed
by
andro
philes
demonstrating
that
people
in
glass
houses
shouldn't
throw
stones
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
anatomy.html
signapk
http
www.riskiq.com
company
press
releases
riskiq
reports
malicious
mobile
apps
google
play
have
spiked
nearly
400
https
bluebox.com
technical
uncovering
android
master
key
that
makes
99
of
devices
vulnerable
http
www.saurik.com
id
17
http
bluebox.com
technical
android
fake
id
vulnerability
user
level
security
so
far
the
discussion
in
this
chapter
focused
on
application
level
security
android
also
needs
to
offer
security
at
the
user
level
allowing
only
the
legitimate
device
user
access
to
it
and
in
particular
its
sensitive
data
beginning
with
jellybean
android
supports
multiple
users
which
complicates
matters
a
little
the
lock
screen
the
lock
screen
is
a
device's
first
and
only
real
line
of
defense
against
theft
or
physical
interception
by
malicious
entities
it
is
also
the
screen
most
often
seen
by
the
user
when
the
device
awakens
from
its
frequent
slumber
as
such
it
must
be
made
resilient
on
the
one
hand
but
also
natural
and
quick
on
the
other
as
with
most
android
features
vendors
may
customize
this
screen
though
android
provides
an
implementation
which
is
often
used
as
is
passwords
pins
and
patterns
the
default
android
lock
screen
allows
either
passwords
pins
or
patterns
patterns
are
in
effect
pins
but
instead
of
remembering
actual
digits
the
user
simply
has
to
swipe
a
grid
usually
3x3
the
user
can
opt
for
an
actual
pin
instead
which
is
technically
stronger
than
a
pattern
in
that
its
length
may
be
xs
wr
fkdudfwhuv
and
it
may
repeat
digits
a
password
provides
a
further
enhancement
over
a
pin
in
that
it
allows
a
mix
of
different
case
letters
and
numbers
the
lock
screen
is
in
effect
just
an
activity
implemented
e
the
package
the
package
contains
all
the
primitives
for
the
system
supplied
lock
screens
and
methods
and
includes
the
following
classes
table
8
8
the
classes
in
class
provides
interface
used
for
biometric
methods
e.g
faceunlock
default
views
to
prompt
for
pin
or
password
credentials
implemented
by
keyguard
views
emulates
activity
lifecycle
keyguard
service
implementation
interface
implemented
by
keyguardhostview
mediates
events
to
the
keyguard
view
the
lock
screen
invocation
begins
when
the
power
manager
wakes
up
the
display
and
notifies
the
implementation
of
the
this
calls
the
s
which
waits
for
the
keyguard
from
there
it
falls
on
the
keyguard
to
draw
the
lock
screen
via
some
activity
and
handle
whatever
lock
credentials
mechanism
was
chosen
by
the
user
the
lock
screen
can
also
be
invoked
from
the
s
method
when
the
system
policy
enforces
automatic
locking
the
actual
logic
of
handling
the
lock
is
performed
by
which
calls
on
the
a
thread
of
the
service
in
turn
verifies
the
input
against
gesture.key
or
password.key
for
pins
and
passwords
alike
in
both
cases
neither
pattern
nor
passwords
are
actually
saved
in
the
file
but
their
hashes
are
the
service
additionally
uses
the
locksettings.db
file
which
is
a
sqlite
database
which
holds
the
various
settings
for
the
lock
screen
those
are
shown
in
table
8
9
kdswhu
9
6hfxulw
table
8
9
the
locksettings.db
database
keys
lockpatternutils
constant
key
name
lockscreen
lockedoutpermanently
lockedoutattempteddeadline
patterneverchosen
password_type
password_type_alternate
password_salt
disabled
biometric_weak_fallback
biometricweakeverchosen
power_button_instantly_locks
widgets_enabled
passwordhistory
putting
these
components
together
figure
8
3
demonstrates
a
slightly
simplified
flow
through
which
the
device
is
unlocked
figure
8
3
unlocking
the
device
the
is
an
l
addition
which
helps
unlock
the
device
without
a
pattern
but
by
alternate
lock
methods
such
as
a
paired
bluetooth
dongle
or
device
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
viewing
the
locksettings.db
if
your
device
is
rooted
and
you
have
the
sqlite3
binary
installed
you
can
inspect
the
locksettings.db
file
you
can
also
use
adb
to
pull
the
locksettings.db
to
your
host
output
8
13
viewing
the
lock
settings
database
the
columns
in
the
locksettings
table
includes
user
to
support
android
multi
user
login
as
of
jb
the
values
are
usually
boolean
0
1
but
not
always
there
are
some
flag
combinations
and
a
salt
for
the
key
file
you
can
use
sql
statements
to
change
the
lock
settings
from
within
sqlite3
though
they
will
be
cached
by
the
lock
settings
service
you
can
also
just
rename
the
file
if
you
do
so
and
restart
it
will
be
recreated
with
the
defaults
and
also
have
the
nice
side
effect
of
resetting
your
password
or
pattern
alternate
lock
methods
ice
cream
sandwich
introduced
face
recognition
as
an
alternative
to
the
traditional
methods
this
was
touted
to
much
fanfare
as
a
potential
differentiator
against
ios
unfortunately
the
recognition
rates
are
far
from
perfect
figures
range
from
as
low
as
60
to
90
face
recognition
can
also
easily
be
defeated
by
holding
up
a
picture
to
the
phone
iqwhuhvwlqjly
people
who
have
tried
this
method
found
it
works
with
greater
accuracy
than
the
user's
actual
face
the
motorola
atrix
4g
was
the
first
android
device
to
implement
fingerprint
scanning
as
an
alternative
method
this
also
suffered
poor
recognition
rates
apple's
acquisition
of
authentec
in
2012
suggested
fingerprint
authentication
was
coming
to
ios
and
indeed
it
made
its
debut
in
the
iphone
5s
samsung
initially
slammed
this
as
a
poor
uninnovative
feature
but
nonetheless
and
unsurprisingly
went
on
to
introduce
it
to
their
next
big
thing
the
galaxy
s5
other
android
vendors
are
quickly
following
and
it
seems
this
will
become
a
standard
feature
with
l
offering
built
in
support
through
its
service
another
important
addition
in
l
is
the
notion
of
unlocking
the
device
using
another
device
a
paired
bluetooth
device
such
as
android
wear
which
works
by
proximity
alone
leaving
the
device
unlocked
so
long
as
the
user
is
nearby
and
the
internals
of
are
discussed
in
volume
ii
kdswhu
9
6hfxulw
multi
user
support
for
the
majority
of
its
existence
android
has
operated
under
the
assumption
that
the
device
only
has
one
user
unlike
desktop
systems
which
have
long
allowed
user
login
and
switching
this
feature
was
only
introduced
into
android
with
jellybean
4.2
and
has
been
initially
introduced
only
into
tablets
android
already
uses
the
user
ids
for
the
individual
applications
as
explained
previously
to
implement
multi
user
support
it
builds
on
the
same
concept
by
carving
up
the
aid
space
into
non
overlapping
regions
and
allocating
one
of
every
human
user
application
ids
are
thus
renamed
from
to
and
users
are
created
with
separate
directories
in
data
user
application
data
directories
are
moved
to
data
user
with
the
primary
user
being
user
0
the
legacy
data
data
thus
becomes
the
primary
user's
directory
symlinked
from
data
user
0
the
user
profiles
themselves
are
stored
in
data
system
users
this
is
shown
in
the
following
experiment
experiment
enabling
multi
user
support
on
api
17
and
later
on
tablets
multi
user
support
will
be
enabled
by
default
as
of
jellybean
api
17
a
little
known
feature
however
is
that
you
can
enable
it
on
phones
as
well
all
it
takes
is
setting
a
system
property
to
any
value
greater
than
1
doing
so
on
the
android
emulator
will
bring
up
the
users
option
to
settings
as
shown
in
the
following
screenshot
screenshot
8
1
before
and
after
property
modification
adding
a
user
is
straightforward
though
the
system
will
force
you
to
set
a
lock
screen
in
order
to
differentiate
between
the
two
users
on
login
the
process
should
look
something
like
output
8
14
next
page
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
experiment
enabling
multi
user
support
on
api
17
and
later
cont
output
8
14
listing
multiple
user
profiles
in
data
system
users
from
the
command
line
the
same
effect
can
be
achieved
by
using
which
connects
to
the
user
manager
and
invokes
its
method
the
likewise
removes
a
user
depending
on
how
you
create
the
user
as
a
separate
user
or
a
restricted
user
which
shares
the
original
user's
apps
the
element
may
be
populated
with
the
following
boolean
attributes
all
defined
in
the
class
the
actual
handling
of
the
files
above
and
the
restrictions
is
performed
by
table
8
10
user
restrictions
restriction
kdswhu
9
6hfxulw
key
management
android
relies
extensively
on
cryptographic
keys
for
system
internal
use
validating
installed
packages
and
for
application
use
in
both
cases
the
keystore
service
discussed
in
chapter
4
plays
an
integral
part
in
abstracting
and
hiding
the
implementation
certificate
management
public
key
infrastructure
is
the
de
facto
fulcrum
of
all
internet
security
encryption
rests
on
several
key
assumptions
which
relate
to
the
algorithms
and
methods
behind
public
keys
the
most
important
of
which
is
a
trust
simply
put
this
means
that
if
you
know
a
subject's
public
key
the
key
can
be
used
not
just
for
encrypting
messages
to
it
but
also
authenticating
messages
from
it
this
in
turn
means
that
if
this
subject
vouches
for
another
public
key
by
authenticating
it
which
is
in
effect
what
a
certificate
is
wkhq
wkdw
sxeolf
nh
v
rzqhuvkls
fdq
eh
hvwdeolvkhg
in
this
way
a
trust
hierarchy
can
be
formed
this
principle
while
powerful
does
lead
to
a
chicken
and
egg
problem
you
can
authenticate
a
public
key
only
if
some
other
public
key
has
been
a
priori
used
to
authenticate
it
the
way
around
this
predicament
is
to
hard
code
the
initial
public
keys
in
the
operating
system
these
keys
are
encoded
in
the
form
of
root
certificates
public
keys
authenticating
themselves
when
passed
over
the
network
they
are
of
no
value
as
they
are
trivial
to
spoof
when
hard
coded
however
they
can
be
trusted
and
provide
the
basis
for
the
trust
hierarchy
android
hard
codes
root
certificates
in
system
etc
security
cacerts
the
certificates
are
encoded
in
their
pem
privacy
enhanced
mail
form
which
is
a
base64
encoding
of
the
certificate
between
delimiters
some
devices
will
also
have
the
plain
ascii
form
of
the
certificate
before
or
after
the
pem
encoding
if
not
it's
a
simple
matter
to
display
it
using
the
command
line
utility
which
is
built
in
to
linux
or
mac
os
shown
in
output
8
15
output
8
15
using
to
decode
a
pem
certificate
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services.html
keystore
of
special
importance
are
the
over
the
air
ota
update
certificates
stored
in
the
system
etc
security
otacerts.zip
archive
the
archive
usually
contains
one
rarely
more
certificates
which
are
used
for
validating
ota
updates
described
in
chapter
3
the
class
parses
this
file
hardcoded
as
in
its
method
using
a
once
again
any
certificates
would
be
encoded
in
pem
usually
without
human
readable
text
but
you
can
use
the
method
shown
in
output
8
13
to
decode
them
removing
this
file
is
a
good
method
to
combat
auto
updates
in
some
android
distributions
such
as
fireos
which
may
cause
you
to
lose
root
access
post
update
certificate
pinning
jellybean
api
17
introduces
certificate
pinning
which
has
become
a
common
add
on
to
ssl
certificate
validation
pinning
involves
hard
coding
the
expected
public
key
of
a
host
via
its
certificate
so
that
if
the
host
presents
a
certificate
which
does
not
match
the
pin
or
one
of
the
pins
in
a
pin
set
it
is
rejected
unlike
the
certificates
discussed
previously
which
are
in
system
etc
security
and
therefore
cannot
be
modified
pins
are
maintained
in
data
misc
keychain
pins
which
is
a
file
that
can
be
replaced
the
class
registers
a
broadcast
receiver
for
the
intent
and
when
such
an
intent
is
received
its
extras
are
expected
to
contain
the
following
the
file
name
containing
the
new
pins
which
is
expected
to
be
greater
than
the
current
version
of
the
current
pins
file
signature
of
the
file
supplied
its
version
and
hash
of
current
pins
file
the
s
inherited
from
gets
the
values
from
the
broadcast
intent
ensures
the
version
number
is
indeed
greater
than
the
current
version
of
the
pins
file
in
data
misc
keychain
metadata
version
and
that
the
current
file's
hash
matches
the
hash
specified
in
the
intent
iw
then
verifies
the
signature
using
the
certificate
stored
in
the
system
settings
database
under
the
if
everything
is
in
order
the
filename
from
the
intent
is
copied
over
the
existing
pins
file
and
the
metadata
version
is
updated
to
reflect
the
new
version
number
google
pins
all
of
its
many
certificates
by
default
and
the
vendor
may
pin
additional
ones
a
quick
way
of
looking
at
pins
is
shown
in
output
8
16
output
8
16
displaying
the
pinned
domains
the
android
explorations
blog7
contains
a
sample
application
demonstrating
the
creation
of
a
pins
file
and
its
update
operation
through
the
intent
kdswhu
9
6hfxulw
file
users
morpheus
documents
android
book
boot.html
ota
http
nelenkov.blogspot.com
2012
12
certificate
pinning
in
android
42
html
certificate
blacklisting
android
provides
the
class
to
handle
black
listing
effectively
revocation
of
certificates
the
class
instantiated
as
a
service
of
as
discussed
in
chapter
5
registers
an
observer
for
two
content
uris
content
settings
secure
pubkey_blacklist
stores
known
compromised
or
revoked
public
keys
or
certificates
content
written
here
ends
up
written
to
data
misc
keychain
pubkey_blacklist.txt
content
settings
secure
serial_blacklist
stores
known
compromised
or
revoked
serial
numbers
of
certificates
serial
numbers
written
here
are
saved
to
data
misc
keychain
serial_blacklist.txt
both
values
are
also
in
the
system's
secure
settings
as
can
be
seen
in
the
following
output
output
8
17
viewing
the
serial
and
pubkey
blacklists
secret
and
private
key
management
storing
secrets
symmetric
keys
or
the
private
part
of
a
public
key
pair
poses
serious
challenges
for
any
security
infrastructure
if
one
assumes
that
file
permissions
are
a
strong
enough
layer
of
security
the
secrets
can
be
placed
in
a
file
and
appropriately
locked
down
the
underlying
file
permissions
of
linux
however
are
inflexible
and
configuration
errors
could
lead
to
secret
leakage
likewise
there
is
the
problem
of
obtaining
root
access
which
effectively
voids
all
permissions
leaving
everything
in
the
clear
android
provides
access
to
secrets
via
the
service
this
service
has
already
been
discussed
in
chapter
4
keystores
for
applications
are
maintained
on
a
per
user
basis
in
the
data
misc
keystore
user_
directory
but
applications
have
no
direct
access
to
that
directory
and
must
go
through
the
keystore
service
which
is
the
sole
owner
of
the
directory
permissions
0700
the
service
also
provides
public
key
functions
and
without
allowing
applications
any
access
to
the
underlying
private
keys
this
allows
the
key
storage
to
be
potentially
implemented
in
hardware
indeed
android
offers
hardware
backed
secure
storage
on
those
devices
which
support
it
as
of
jellybean
as
discussed
in
chapter
11
the
hal
abstraction
provides
both
a
uniform
interface
for
encryption
operations
and
allows
its
implementation
in
both
software
and
hardware
thus
supporting
devices
implement
a
hardware
backed
keymaster
module
whereas
those
which
do
not
use
a
instead
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
file
users
morpheus
documents
android
book
services
ii.html
certblacklister
file
users
morpheus
documents
android
book
services.html
keystore
file
users
morpheus
documents
android
book
devices.html
keymaster
storage
security
data
encryption
while
most
users
remain
oblivious
to
the
need
for
encryption
on
their
devices
corporate
users
certainly
fear
the
compromising
of
data
which
would
ensue
should
a
device
be
lost
or
stolen
ios
provided
transparent
encryption
as
of
ios
4
and
coincidentally
so
has
android
as
of
honeycomb
by
using
the
very
same
dm
crypt
mechanism
utilized
by
obbs
and
asec
honeycomb
extends
the
notion
of
encryption
to
the
full
filesystem
layer
the
term
full
disk
encryption
is
therefore
somewhat
inaccurate
here
since
it
is
only
the
data
partition
which
is
normally
encrypted
this
actually
makes
more
sense
because
system
contains
no
sensitive
data
and
would
be
impacted
from
the
latency
incurred
by
crypto
operations
android's
documentation
provides
a
detailed
explanation
of
encryption
which
has
been
revised
for
android
l8
as
with
asecs
and
obbs
the
volume
manager
is
responsible
for
performing
both
the
filesystem
encryption
and
decryption
the
former
is
performed
when
selected
by
the
user
and
is
a
rather
lengthy
operation
the
latter
is
performed
transparently
when
the
encrypted
filesystem
is
mounted
as
a
block
device
using
the
device
mapper
note
that
unlike
obb
and
asec
the
decryption
keys
for
which
are
stashed
somewhere
on
the
device
in
plaintext
albeit
readable
only
by
root
the
key
for
the
data
partition
encryption
does
not
actually
reside
on
the
device
but
requires
the
user
to
interact
during
boot
and
supply
it
or
more
accurately
the
password
from
which
this
key
is
derived
this
requires
modifications
to
the
android
boot
process
as
well
as
an
interaction
between
init
and
vold
which
we
describe
in
chapter
4
prior
to
the
dm
crypt
solution
there
were
several
proposed
alternatives
for
file
system
encryption
most
notably
encfs
by
wang
et
al
9
but
the
dm
crypt
one
is
wkh
de
facto
standard
qrz
wkdw
kdv
enabled
lw
by
default
the
architecture
is
shown
in
figure
8
4
figure
8
4
the
dm
crypt
architecture
android
m
pr1
further
employs
dm
crypt
with
a
new
feature
called
adoptable
storage
which
enables
the
user
to
extend
android
filesystem
encryption
to
external
storage
e.g
usb
drivers
as
usual
this
is
handled
by
vold
who
maintains
the
encryption
keys
in
mnt
vold
and
mounts
the
decrypted
volumes
under
mnt
expand
kdswhu
9
6hfxulw
https
source.android.com
devices
tech
encryption
index.html
file
users
morpheus
documents
android
book
filesystems.html
obb
file
users
morpheus
documents
android
book
filesystems.html
asec
file
users
morpheus
documents
android
book
services.html
vold
http
cs.gmu.edu
astavrou
research
android_encrypted_file_system_mdm_12
pdf
access
to
the
storage
device
is
already
inherently
slow
while
not
as
slow
as
hard
drives
flash
devices
run
at
significantly
slower
rates
than
the
cpu
adding
the
overhead
of
an
encryption
or
decryption
routine
adds
several
more
microseconds
per
access
but
when
viewed
percentage
wise
this
accounts
for
a
fractional
gain
at
best
the
linux
kernel
optimizes
access
with
caching
as
can
be
seen
in
figure
8
4
the
linux
kernel
helps
optimize
data
access
by
caching
device
data
because
dm
crypt
appears
as
a
block
device
it
exists
under
the
caches
and
therefore
can
benefit
from
it
data
is
decrypted
only
once
and
read
write
operations
can
occur
on
the
cached
decrypted
copy
when
the
data
is
flushed
back
to
the
underlying
device
it
can
be
re
encrypted
and
then
find
its
way
to
the
underlying
physical
device
to
begin
with
access
to
data
isn't
as
often
as
to
system
unlike
access
to
the
system
partition
which
stores
android's
vast
frameworks
and
static
configuration
access
to
data
occurs
only
when
an
app
is
loaded
or
some
runtime
configuration
change
occurs
secure
boot
kitkat
introduced
a
new
feature
for
securing
the
boot
process
using
the
kernel's
device
mapper
this
feature
known
as
dm
verity
originated
in
chromium
os
and
has
been
ported
into
linux
and
thus
android
beginning
with
kernel
version
3.4
recall
from
chapter
3
that
a
chain
of
trust
also
known
as
the
verified
boot
path
has
been
established
from
the
rom
via
the
boot
loader
and
onto
the
kernel
and
the
root
file
system
i.e
the
boot
partition
while
the
bootloader
actually
does
verify
system
it
does
so
only
when
flashing
the
entire
partition
which
leaves
open
the
avenue
for
a
root
owned
process
be
it
rooting
or
malware
to
make
persistent
changes
in
system
by
remounting
it
as
read
write
and
modifying
files
in
it
using
dm
verity
effectively
extends
the
boot
chain
of
trust
one
more
level
onto
system
verifying
the
integrity
of
a
partition
is
the
simple
matter
of
hashing
all
of
its
blocks
dm
verity
uses
sha
256
and
comparing
that
hash
against
a
stored
digitally
signed
hash
value
to
do
so
effectively
however
one
has
to
avoid
the
lengthy
process
of
reading
the
entire
partition
which
can
delay
boot
to
get
around
this
limitation
dm
verity
reads
the
entire
partition
only
once
and
records
the
hash
value
of
each
4k
block
in
the
leaf
nodes
of
the
tree
multiple
leaf
nodes
are
rehashed
in
the
second
level
of
the
tree
and
then
onward
to
the
third
until
a
single
hash
value
is
calculated
for
the
entire
partition
this
is
known
as
the
root
hash
this
hash
is
digitally
signed
with
the
vendor's
private
key
and
can
be
verified
with
its
public
key
since
disk
operations
are
performed
in
full
blocks
it
is
a
straightforward
to
add
an
additional
hash
verification
on
the
block
as
it
is
placed
into
the
kernel's
buffer
page
cache
and
before
it
is
returned
to
the
requester
if
the
hash
check
fails
an
i
o
error
occurs
and
the
block
is
known
to
be
corrupted
the
dm
verity
feature
is
touted
for
malware
prevention
since
it
effectively
prevents
any
modification
of
system
but
does
have
the
side
effect
of
preventing
unauthorized
persistent
rooting
as
well
malware
could
definitely
attempt
to
make
modifications
to
system
but
android
would
detect
them
potentially
refusing
to
boot
yet
the
same
would
apply
for
any
persistent
root
back
door
e.g
dropping
a
setuid
system
xbin
su
from
the
vendor's
perspective
this
is
fine
most
vendors
would
only
provide
root
via
bootloader
unlocking
which
breaks
the
chain
of
trust
at
its
very
first
link
further
dm
verity
requires
only
a
subtle
modification
to
the
update
process
discussed
in
chapter
3
namely
that
the
vendor
regenerate
the
signature
when
system
is
modified
during
an
update
otherwise
system
remains
read
only
throughout
the
device's
lifetime
and
the
signature
must
therefore
remain
intact
the
kernel
mode
implementation
of
dm
verity
is
rather
small
a
20k
file
of
drivers
dm
dm
verity.c
which
plugs
into
the
linux
device
mapper
as
discussed
in
volume
iii
google
details
the
verified
boot
process
in
the
android
documentation10
the
android
explorations
blog11
once
more
provides
further
detail
including
using
the
during
the
building
of
the
image
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
an
oft
asked
question
pertains
to
the
potential
performance
impact
of
encryption
encryption
naturally
requires
more
processing
by
the
cpu
to
decrypt
and
re
encrypt
the
data
which
can
impact
performance
and
to
an
extent
power
consumption
while
there
have
been
differing
accounts
the
overall
view
is
that
the
performance
impact
ranges
from
negligible
to
manageable
this
is
corroborated
by
the
following
performance
impact
file
users
morpheus
documents
android
book
boot.html
locking
file
users
morpheus
documents
android
book
boot.html
ota
https
source.android.com
devices
tech
security
dm
verity.html
http
nelenkov.blogspot.com
2014
05
using
kitkat
verified
boot.html
rooting
android
most
vendors
provide
adb
functionality
on
their
devices
and
leave
the
operating
system
relatively
open
for
developers
but
few
if
any
provide
root
access
to
the
device
there
is
a
strong
rationale
not
to
do
so
considering
that
obtaining
root
access
to
a
unix
system
brings
with
it
virtual
omnipotence
and
android
is
no
different
leaving
behind
open
access
to
root
would
also
potentially
provide
an
attack
vector
for
malware
which
android
knows
no
shortage
of
with
root
access
any
file
on
the
system
could
be
read
or
worse
overwritten
which
would
give
an
attacker
both
access
to
private
data
as
well
as
the
ability
to
hijack
control
of
the
device
the
same
can
be
said
for
apple's
ios
also
a
unix
system
based
on
darwin
but
herein
lies
the
significant
difference
between
the
two
apple's
developers
have
engineered
the
system
from
the
ground
up
literally
from
the
very
hardware
to
the
uppermost
layers
of
software
to
be
rock
solid
and
not
to
allow
root
access
in
fact
not
to
allow
any
access
aside
from
a
sandboxed
app
model
at
all
costs
android
is
built
on
linux
which
itself
is
a
mix
of
code
strains
from
different
contributors
not
all
of
which
adhere
to
the
strictest
security
standards
additionally
several
vendors
leave
an
avenue
which
can
be
exploited
by
a
human
user
in
possession
of
the
device
to
gain
root
access
redirecting
the
system
to
boot
an
alternate
configuration
another
way
of
looking
at
it
is
android
considers
the
application
to
be
the
enemy
whereas
ios
considers
the
user
itself
to
be
one
boot
to
root
when
android
devices
boot
they
normally
do
so
by
the
process
described
in
chapter
3
it
is
possible
however
to
divert
the
boot
process
to
an
alternate
boot
for
safe
boot
system
upgrade
or
recovery
this
can
usually
be
done
by
pressing
a
physical
button
combination
usually
one
or
both
of
the
volume
buttons
and
the
home
button
if
it
exists
or
by
a
fastboot
command
when
the
device
is
connected
over
usb
once
the
boot
flow
is
diverted
the
boot
loader
can
be
directed
to
load
an
alternate
boot
image
either
the
on
flash
recovery
image
an
update
supplied
on
the
sd
card
or
over
usb
an
image
supplied
through
fastboot
if
a
device's
bootloader
can
be
unlocked
as
explained
in
chapter
3
the
device
can
be
rooted
it's
that
simple
as
previously
mentioned
unlocking
the
boot
loader
will
cause
data
to
be
effaced
in
an
effort
to
prevent
the
user's
sensitive
data
from
falling
into
the
wrong
hands
additionally
some
boot
loaders
will
permanently
set
a
flag
indicating
that
the
loader
has
been
tampered
with
even
if
it
is
re
locked
at
some
point
this
is
to
note
that
the
boot
loader
basically
shirks
all
responsibility
for
system
security
as
it
will
no
longer
enforce
digital
signatures
on
images
flashed
all
it
takes
to
root
the
device
is
really
just
one
part
of
the
device
image
the
init
ram
disk
initramfs
because
the
kernel
mounts
the
initrd
as
the
root
filesystem
and
starts
its
init
with
root
privileges
supplying
an
alternate
init
or
even
just
a
different
init.rc
file
suffices
to
obtain
root
access
from
that
point
onwards
it's
a
simple
matter
of
convenience
it's
straightforward
to
simply
have
adb
maintain
root
privileges
by
setting
or
replace
adb
to
a
version
which
doesn't
drop
privileges
most
rooting
tools
however
usually
drop
a
su
binary
into
system
bin
or
system
xbin
and
use
to
toggle
the
setuid
bit
so
when
it
is
invoked
from
the
shell
the
setuid
effect
will
kick
in
and
automatically
bestow
root
permissions
the
code
for
such
a
binary
pre
kit
kat
is
so
simple
it
can
be
summarized
in
three
functional
lines
listing
8
5
a
simple
implementation
of
su
for
non
se
linux
enforced
devices
kdswhu
9
6hfxulw
q
uhfhqw
exlogv
dge
lv
frqglwlrqdoo
frpslohg
lighi
2
b
b5227
vr
dv
wr
ljqruh
wklv
surshuw
file
users
morpheus
documents
android
book
boot.html
b
bp
file
users
morpheus
documents
android
book
boot.html
locking
you
can
find
a
similar
implementation
with
command
line
options
in
the
aosp's
system
extras
su
su.c
as
of
kitkat
however
the
introduction
of
se
linux
in
enforcing
mode
makes
the
binary
less
trivial
in
that
its
parent
the
shell
is
already
confined
to
a
restricted
execution
context
which
it
cannot
break
out
of
this
requires
the
binary
to
make
an
ipc
call
to
a
process
in
the
init
or
u:r:kernel:s0
unrestricted
context
to
then
spawn
a
shell
e.g
the
weaksauce
exploit
with
daemonsu
as
explained
on
the
book's
companion
website12
if
you've
rooted
a
kitkat
or
later
device
with
se
linux
in
enforcing
mode
you
can
likely
see
this
for
yourself
as
shown
in
the
following
output
output
8
18
viewing
an
implementation
accommodating
for
selinux
the
practice
of
rooting
is
so
popular
that
there
are
quite
a
few
superuser
applications
which
provide
a
gui
interface
to
administer
root
access
once
the
device
is
rooted
the
applications
actually
offer
a
programmatic
api
via
permissions
and
intents
to
allow
other
applications
access
to
root
one
noteable
example
is
chainfire's
supersu
which
defines
its
own
dalvik
level
permissions
and
and
enables
applications
to
broadcast
intents
in
order
to
obtain
superuser
privileges
this
application
also
cleverly
works
around
se
linux
as
can
be
seen
from
the
output
above
rooting
via
exploiting
whether
or
not
a
vendor
has
left
the
boot
root
backdoor
open
often
there
exist
additional
backdoors
these
unlike
the
former
are
quite
unintentional
and
all
rely
on
some
form
of
system
vulnerability
exploitation
the
ways
to
do
so
are
myriad
and
often
unpredictable
until
discovered
but
they
all
share
the
same
common
denominator
find
some
insecure
configuration
setting
or
software
component
and
trigger
some
code
path
by
means
of
which
root
access
can
be
obtained
as
mentioned
in
the
threat
modeling
section
of
this
chapter
the
security
jargon
for
these
attack
types
is
privilege
escalation
as
it
refers
to
the
process
wherein
a
lower
privilege
process
that
is
some
app
can
increase
its
privileges
usually
first
to
those
of
the
system
user
and
then
root
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
6498
6503
init
use
the
toolbox
specific
z
flag
to
ps
to
show
selinux
contexts
s
z
6498
which
gets
the
u:r:init
unrestricted
se
linux
context
from
daemonsu
eu.chainfire.supersu
is
the
gui
app
u:r:shell:s0
shell
6498
601
system
bin
sh
u:r:shell:s0
shell
6503
6498
su
u:r:init:s0
root
6506
5319
daemonsu
0
6503
u:r:init:s0
root
6510
6506
tmp
mksh
u:r:untrusted_app:s0
u0_a140
6528
575
eu.chainfire.supersu
u:r:init:s0
root
6578
6510
ps
http
newandroidbook.com
articles
htc.html
b1
there
is
a
strong
similarity
between
exploit
based
rooting
methods
and
jailbreaking
for
ios
in
both
cases
it
takes
the
discovery
and
exploitation
of
software
bugs
and
both
methods
should
not
be
possible
in
a
perfect
world
at
least
according
to
google
and
apple
once
these
methods
are
discovered
their
days
are
numbered
the
operating
system
is
fairly
quickly
patched
and
suggested
to
the
user
for
download
and
updated
or
even
auto
updated
as
for
example
with
the
amazon
kindle
one
prominent
example
was
in
gingerbread
wherein
google
itself
pushed
an
update
for
a
vulnerability
in
the
linux
kernel
known
at
the
time
to
have
been
actively
exploited
by
malware
a
thorough
discussion
of
exploitation
techniques
is
thus
beyond
the
scope
of
this
work
and
quite
frankly
is
pointless
since
all
known
exploits
at
this
time
have
been
patched
exploits
generally
obtain
root
by
passing
crafted
input
to
a
process
already
running
as
root
vold
has
been
a
perennial
favorite
corrupting
its
memory
stack
or
heap
and
usually
overwriting
a
function
pointer
or
commonly
a
return
address
to
subvert
its
execution
and
direct
it
at
the
attacker
controlled
input
an
additional
trick
return
oriented
programming
rop
is
often
used
to
direct
execution
to
snippets
of
code
which
already
exist
in
the
program
but
run
in
an
attacker
controlled
manner
this
method
which
is
somewhat
like
biological
dna
splicing
and
recombination
defeats
data
execution
prevention
methods
such
as
arm's
xn
bits
a
lengthy
discussion
of
past
exploits
and
rop
methods
can
be
found
in
the
android
hacker's
handbook
it
should
be
noted
that
not
all
exploits
necessarily
involve
code
injection
some
are
much
more
simple
and
elegant
for
example
the
weaksauce
exploit
for
htc
one
phones
discssued
in
the
book's
companion
website12
similarly
the
latest
vulnerability
in
android
at
the
time
of
writing
was
not
really
due
to
android
but
to
the
linux
kernel
geohot's
clever
towelroot
exploit14
used
a
well
known
kernel
bug
in
handling
fast
mutexes
cve
2014
3153
to
gain
root
while
towelroot
itself
is
not
malware
per
se
but
a
rooting
utility
malware
could
use
the
exact
same
bug
to
surreptitiously
gain
root
access
without
the
user's
knowledge
or
consent
to
paraphrase
a
quote
attributed
to
donald
rumsfeld
there
are
known
unknowns
those
are
essentially
the
0
days
which
were
unknown
but
have
been
discovered
and
patched
but
there
are
also
unknown
unknowns
the
latter
are
the
0
days
which
are
likely
to
exist
but
have
not
been
discovered
yet
or
worse
have
been
discovered
but
not
publicized
yet
any
hacker
uncovering
a
0
day
in
effect
obtains
a
skeleton
key
to
all
android
devices
vulnerable
to
that
particular
issue
a
malicious
hacker
can
incorporate
this
into
powerful
malware
or
not
even
bother
and
directly
sell
it
on
the
open
market
though
not
as
lucrative
as
ios
exploits
android
0
days
can
fetch
anywhere
between
50,000
and
500,000
dollars
depending
on
vector
local
remote
and
impact
security
aspects
of
rooting
because
a
boot
based
rooting
method
requires
user
intervention
and
or
connecting
the
device
to
a
host
it
is
generally
not
considered
to
be
an
insecurity
of
the
android
system
it
does
however
leave
a
clear
attack
vector
for
an
adversary
who
gains
possession
of
the
device
this
could
be
an
issue
if
the
device
is
lost
stolen
or
just
left
outside
one's
reach
for
a
sufficient
amount
of
time
it
would
take
a
skilled
attacker
no
more
than
10
20
minutes
to
root
a
device
steal
all
the
personal
data
from
it
and
leave
a
backdoor
or
two
this
is
why
most
bootloaders
are
often
locked
and
while
an
unlock
of
the
bootloader
is
possible
it
will
force
a
factory
reset
and
erasure
of
all
personal
data
once
the
bootloader
is
unlocked
however
the
device
is
vulnerable
unless
the
bootloader
is
locked
again
exploitation
attacks
are
even
simpler
in
the
sense
that
they
do
not
require
the
user
to
manually
divert
the
system
boot
process
in
fact
these
attacks
require
no
user
intervention
at
all
therein
lies
their
advantage
for
those
looking
for
a
simple
1
click
root
method
but
also
their
great
risk
as
they
can
be
carried
out
without
the
user's
knowledge
often
when
installing
a
seemingly
innocuous
app
which
like
the
proverbial
trojan
horse
compromises
the
entire
system
kdswhu
9
6hfxulw
http
www.amazon.com
gp
product
111860864x
ref
as_li_tl
ie
utf8
camp
1789
creative
9325
creativeasin
111860864x
linkcode
as2
tag
newosxbookcom
20
http
newandroidbook.com
articles
htc.html
b
http
www.towelroot.com
explotation
attacks
are
even
more
dangerous
when
they
are
http
borne
when
the
vulnerability
exploited
or
part
thereof
involves
the
browser
it
suffices
to
visit
a
malicious
website
or
inadvertently
access
some
content
from
it
for
example
through
an
ad
network
for
malicious
payload
to
target
the
browser
and
gain
the
initial
foothold
on
the
device
indeed
sophisticated
malware
consists
of
multiple
payloads
injected
over
several
stages
initially
obtaining
remote
execution
then
followed
by
obtaining
remote
root
what
follows
is
that
rooting
the
device
can
in
fact
be
dangerous
if
not
carried
out
through
trusted
sources
when
an
eager
user
downloads
a
rooting
utility
whether
one
click
or
tethered
if
the
download
source
is
not
a
trusted
one
it
could
be
hard
virtually
impossible
to
detect
additional
payloads
or
backdoors
which
may
be
injected
by
such
utilities
less
than
proper
tools
may
jump
on
the
chance
to
also
change
system
binaries
or
frameworks
for
example
disabling
the
dalvik
permission
mechanism
for
malware
purposes
malware
could
possibly
inject
a
rootkit
all
the
way
down
to
the
linux
kernel
though
most
would
probably
not
put
that
much
effort
when
it's
fairly
trivial
to
hack
the
higher
layers
somewhat
ironically
some
of
the
superuser
applications
themselves
had
vulnerabilities
in
the
past
which
enabled
rogue
applications
to
detect
a
rooted
device
and
escalate
their
own
privileges
through
the
applications
q.v
cve
2013
6774
the
last
but
hardly
least
impact
of
rooting
a
device
one
has
to
consider
is
that
on
applications
android's
application
content
protections
disintegrate
on
a
rooted
device
obbs
can
be
read
by
root
as
can
the
keys
to
asec
storage
application
encryption
likewise
fails
and
though
hardware
backed
credential
storage
offers
some
resistance
its
client
processes
memory
can
easily
be
read
via
methods
and
the
like
drm
solutions
also
fail
miserably
unfortunately
there's
no
foolproof
way
of
detecting
a
rooted
device
from
a
running
application
and
refusing
to
execute
on
one
arguably
the
same
can
be
said
for
jailbroken
ios
after
all
apple's
fairplay
protections
and
application
encryptions
though
stronger
than
android's
are
equally
frangible
yet
one
has
to
keep
in
mind
that
ios
only
has
an
exploitation
vector
with
an
ever
increasing
level
of
difficulty
in
between
releases
whereas
most
android
devices
do
allow
boot
to
root
coupled
with
the
ease
of
dalvik
bytecode
decompilation
this
poses
a
serious
concern
for
application
developers
summary
this
chapter
attempted
to
provides
an
overview
of
android's
myriad
security
features
both
those
inherited
from
linux
and
those
which
are
specific
to
android
and
mostly
implemented
in
the
dalvik
level
special
attention
has
been
given
to
the
android
port
of
selinux
which
though
currently
not
in
full
effect
is
already
adopted
by
samsung
in
knox
and
is
likely
to
play
a
larger
part
in
upcoming
releases
of
android
while
trying
to
be
as
detailed
as
possible
this
review
is
by
no
means
comprehensive
the
interested
reader
is
referred
to
android
security
specific
books
such
as
nikolay
elenkov's
android
security
internals15
which
devotes
full
chapters
to
what
was
covered
here
in
sections
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
http
www.amazon.com
gp
product
1593275811
ref
as_li_tl
ie
utf8
camp
1789
creative
9325
creativeasin
1593275811
linkcode
as2
tag
newosxbookcom
20
linkid
lbf642zjnlga3fn2
references
1
a
seandroid
a
paper
smalley
craig
http
www.internetsociety.org
sites
default
files
02_4
pdf
b
seandroid
a
presentation
smalley
craig
http
www.internetsociety.org
sites
default
files
presentation02_4
pdf
c
seandroid
at
abs
smalley
craig
http
events.linuxfoundation.org
sites
events
files
slides
abs2014_seforandroid_smalley.pdf
2
android
developer
selinux
http
source.android.com
devices
tech
security
se
linux.html
3
redhat
rhel6
and
selinux
https
access.redhat.com
site
documentation
en
us
red_hat_enterprise_linux
6
html
security
enhanced_linux
4
riskiq
mobile
apps
on
google
play
http
www.riskiq.com
company
press
releases
riskiq
reports
malicious
mobile
apps
google
play
have
spiked
nearly
400
5
a
bluebox
android
master
key
vulnerability
https
bluebox.com
technical
uncovering
android
master
key
that
makes
99
of
devices
vulnerable
b
saurik
android
master
key
vulnerability
www.saurik.com
id
17
6
bluebox
android
fake
id
vulnerability
http
bluebox.com
technical
android
fake
id
vulnerability
7
android
explorations
certificate
pinning
in
4.2
http
nelenkov.blogspot.com
2012
12
certificate
pinning
in
android
42
html
8
android
documentation
device
encryption
https
source.android.com
devices
tech
encryption
index.html
9
encfs
by
wang
et
al
http
cs.gmu.edu
astavrou
research
android_encrypted_file_system_mdm_12
pdf
10
android
documentation
dm
verity
https
source.android.com
devices
tech
security
dm
verity.html
11
android
explorations
kitkat
verified
boot
http
nelenkov.blogspot.com
2014
05
using
kitkat
verified
boot.html
12
newandroidbook.com
analyzing
the
weaksauce
exploit
http
newandroidbook.com
articles
htc.html
13
android
hacker's
handbook
wiley
2014
by
joshua
drake
and
others
14
towelroot.com
http
www.towelroot.com
15
android
security
internals
no
starch
2014
by
nikolay
elenkov
kdswhu
9
6hfxulw
http
www.internetsociety.org
sites
default
files
02_4
pdf
http
www.internetsociety.org
sites
default
files
presentation02_4
pdf
http
events.linuxfoundation.org
sites
events
files
slides
abs2014_seforandroid_smalley.pdf
http
source.android.com
devices
tech
security
se
linux.html
https
access.redhat.com
site
documentation
en
us
red_hat_enterprise_linux
6
html
security
enhanced_linux
http
www.riskiq.com
company
press
releases
riskiq
reports
malicious
mobile
apps
google
play
have
spiked
nearly
400
https
bluebox.com
technical
uncovering
android
master
key
that
makes
99
of
devices
vulnerable
http
www.saurik.com
id
17
http
bluebox.com
technical
android
fake
id
vulnerability
http
nelenkov.blogspot.com
2012
12
certificate
pinning
in
android
42
html
https
source.android.com
devices
tech
encryption
index.html
http
cs.gmu.edu
astavrou
research
android_encrypted_file_system_mdm_12
pdf
https
source.android.com
devices
tech
security
dm
verity.html
http
nelenkov.blogspot.com
2014
05
using
kitkat
verified
boot.html
http
newandroidbook.com
articles
htc.html
b1
http
www.towelroot.com
qgurlg
qwhuqdov
rqihfwlrqhu
v
rrnerrn
9roxph
had
enough
if
this
has
only
begun
to
whet
your
appetite
for
more
on
android
stay
tuned
for
volume
ii
coming
soon
which
picks
up
where
this
leaves
off
and
discusses
the
true
internals
of
the
system
the
framework
services
graphics
audio
and
multimedia
and
much
more
from
the
programmer's
view
feel
free
to
drop
me
a
line
and
let
me
know
what
you
liked
and
what
you
hated
also
remember
to
check
out
newandroidbook.com
for
more
updates
and
tons
of
bonus
material
hope
to
see
you
next
volume
3rvw
6fulswxp
http
www.newandroidbook.com
android
may
be
an
open
source
system
but
how
many
people
can
actually
sit
down
and
sift
through
millions
lines
of
java
c
c
and
xml
just
to
figure
out
how
it
works
android
internals
a
confectioner's
cookbook
is
the
first
time
the
inner
workings
of
the
world's
most
popular
operating
system
have
been
documented
without
going
into
the
lengthy
code
it
presents
the
logic
and
flow
of
android's
various
components
using
detailed
illustrations
verbose
annotations
and
hands
on
experiments
volume
i
takes
the
power
user's
point
of
view
the
utilities
and
functionality
accessible
through
in
particular
we
explore
partitions
and
filesystems
the
boot
process
init
and
its
configuration
files
the
native
daemons
in
system
bin
the
framework
service
architecture
and
monitoring
through
linux
interfaces
security
all
versions
of
android
up
to
and
including
lollipop
are
covered
with
examples
taken
from
the
wide
gamut
of
android
devices
nexi
samsung
galaxy
s
series
nvidia
shield
amazon
kindle
htc
one
m8
and
the
android
emulator
this
is
the
first
in
a
multi
volume
series
aiming
to
explore
android
down
to
its
last
class
stay
tuned
for
volume
ii
the
programmer's
view
which
picks
up
where
the
power
user's
view
ends
and
dives
deeper
still
into
the
frameworks
input
audio
video
and
network
architecture
wading
through
the
inevitable
quagmire
of
code
jonathan
levin
is
a
longtime
trainer
and
consultant
specializing
in
the
system
and
kernel
levels
of
the
big
three
windows
linux
and
mac
os
x
as
well
as
their
mobile
derivatives
he
is
the
founder
and
cto
of
technologeeks.com
a
partnership
of
experts
offering
training
and
consulting
on
system
kernel
programming
debugging
and
more
fresh
after
his
take
on
ios
in
mac
os
x
and
ios
internals
wiley
2012
with
a
2nd
edition
coming
in
2015
jonathan
turns
his
attention
to
the
other
operating
system
and
brings
an
even
greater
level
of
detail
to
the
operating
system
that
is
to
mobile
what
windows
was
to
the
desktop
and
this
time
it's
personal
this
entire
work
is
self
published
cover
material
table
of
contents
about
about
this
book
i
introduction
android
version
history
android
vs
linux
android
derivatives
pondering
the
way
ahead
ii
partitions
filesystems
partitioning
scheme
android
filesystem
contents
protected
filesystems
the
linux
pseudo
filesystems
iii
boot
backup
recovery
android
images
the
boot
process
shutdown
reboot
application
backup
restore
system
recovery
updates
iv
init
roles
and
responsibilities
init
and
usb
other
roles
of
init
v
daemons
core
services
network
services
graphics
and
media
services
other
services
vi
the
framework
service
architecture
revisiting
servicemanager
the
service
calling
pattern
the
binder
system_server
vii
through
a
linux
lens
user
mode
memory
management
tracing
system
calls
viii
security
threat
modeling
mobile
security
security
at
the
linux
level
security
at
the
dalvik
level
user
level
security
key
management
storage
security
rooting
android
